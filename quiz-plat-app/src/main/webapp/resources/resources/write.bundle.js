/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "5c3e65ba91221df480fb";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			for(var chunkId in installedChunks)
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"write": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/resources/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([1,"vendors"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css":
/*!*****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \".minicolors {\\n  position: relative;\\n}\\n\\n.minicolors-sprite {\\n  background-image: url(/resources/write/jquery.minicolors.png);\\n}\\n\\n.minicolors-swatch {\\n  position: absolute;\\n  vertical-align: middle;\\n  background-position: -80px 0;\\n  border: solid 1px #ccc;\\n  cursor: text;\\n  padding: 0;\\n  margin: 0;\\n  display: inline-block;\\n}\\n\\n.minicolors-swatch-color {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n}\\n\\n.minicolors input[type=hidden] + .minicolors-swatch {\\n  width: 28px;\\n  position: static;\\n  cursor: pointer;\\n}\\n\\n.minicolors input[type=hidden][disabled] + .minicolors-swatch {\\n  cursor: default;\\n}\\n\\n/* Panel */\\n.minicolors-panel {\\n  position: fixed;\\n  width: 173px;\\n  background: white;\\n  border: solid 1px #CCC;\\n  box-shadow: 0 0 20px rgba(0, 0, 0, .2);\\n  z-index: 99999;\\n  box-sizing: content-box;\\n  display: none;\\n  top:50%;\\n  left:50%;\\n  transform:translateX(-50%);\\n}\\n\\n.minicolors-panel.minicolors-visible {\\n  display: block;\\n}\\n\\n/* Panel positioning */\\n.minicolors-position-top .minicolors-panel {\\n  top: -154px;\\n}\\n\\n.minicolors-position-right .minicolors-panel {\\n  right: 0;\\n}\\n\\n.minicolors-position-bottom .minicolors-panel {\\n  top: auto;\\n}\\n\\n.minicolors-position-left .minicolors-panel {\\n  left: 0;\\n}\\n\\n.minicolors-with-opacity .minicolors-panel {\\n  width: 194px;\\n}\\n\\n.minicolors .minicolors-grid {\\n  position: relative;\\n  top: 1px;\\n  left: 1px; /* LTR */\\n  width: 150px;\\n  height: 150px;\\n  margin-bottom: 2px;\\n  background-position: -120px 0;\\n  cursor: crosshair;\\n}\\n[dir=rtl] .minicolors .minicolors-grid {\\n  right: 1px;\\n}\\n\\n.minicolors .minicolors-grid-inner {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 150px;\\n  height: 150px;\\n}\\n\\n.minicolors-slider-saturation .minicolors-grid {\\n  background-position: -420px 0;\\n}\\n\\n.minicolors-slider-saturation .minicolors-grid-inner {\\n  background-position: -270px 0;\\n  background-image: inherit;\\n}\\n\\n.minicolors-slider-brightness .minicolors-grid {\\n  background-position: -570px 0;\\n}\\n\\n.minicolors-slider-brightness .minicolors-grid-inner {\\n  background-color: black;\\n}\\n\\n.minicolors-slider-wheel .minicolors-grid {\\n  background-position: -720px 0;\\n}\\n\\n.minicolors-slider,\\n.minicolors-opacity-slider {\\n  position: absolute;\\n  top: 1px;\\n  left: 152px; /* LTR */\\n  width: 20px;\\n  height: 150px;\\n  background-color: white;\\n  background-position: 0 0;\\n  cursor: row-resize;\\n}\\n[dir=rtl] .minicolors-slider,\\n[dir=rtl] .minicolors-opacity-slider {\\n  right: 152px;\\n}\\n\\n.minicolors-slider-saturation .minicolors-slider {\\n  background-position: -60px 0;\\n}\\n\\n.minicolors-slider-brightness .minicolors-slider {\\n  background-position: -20px 0;\\n}\\n\\n.minicolors-slider-wheel .minicolors-slider {\\n  background-position: -20px 0;\\n}\\n\\n.minicolors-opacity-slider {\\n  left: 173px; /* LTR */\\n  background-position: -40px 0;\\n  display: none;\\n}\\n[dir=rtl] .minicolors-opacity-slider {\\n  right: 173px;\\n}\\n\\n.minicolors-with-opacity .minicolors-opacity-slider {\\n  display: block;\\n}\\n\\n/* Pickers */\\n.minicolors-grid .minicolors-picker {\\n  position: absolute;\\n  top: 70px;\\n  left: 70px;\\n  width: 12px;\\n  height: 12px;\\n  border: solid 1px black;\\n  border-radius: 10px;\\n  margin-top: -6px;\\n  margin-left: -6px;\\n  background: none;\\n}\\n\\n.minicolors-grid .minicolors-picker > div {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 8px;\\n  height: 8px;\\n  border-radius: 8px;\\n  border: solid 2px white;\\n  box-sizing: content-box;\\n}\\n\\n.minicolors-picker {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 18px;\\n  height: 2px;\\n  background: white;\\n  border: solid 1px black;\\n  margin-top: -2px;\\n  box-sizing: content-box;\\n}\\n\\n/* Swatches */\\n.minicolors-swatches,\\n.minicolors-swatches li {\\n  margin: 5px 0 3px 5px; /* LTR */\\n  padding: 0;\\n  list-style: none;\\n  overflow: hidden;\\n}\\n[dir=rtl] .minicolors-swatches,\\n[dir=rtl] .minicolors-swatches li {\\n  margin: 5px 5px 3px 0;\\n}\\n\\n.minicolors-swatches .minicolors-swatch {\\n  position: relative;\\n  float: left; /* LTR */\\n  cursor: pointer;\\n  margin:0 4px 0 0; /* LTR */\\n}\\n[dir=rtl] .minicolors-swatches .minicolors-swatch {\\n  float: right;\\n  margin:0 0 0 4px;\\n}\\n\\n.minicolors-with-opacity .minicolors-swatches .minicolors-swatch {\\n  margin-right: 7px; /* LTR */\\n}\\n[dir=rtl] .minicolors-with-opacity .minicolors-swatches .minicolors-swatch {\\n  margin-right: 0;\\n  margin-left: 7px;\\n}\\n\\n.minicolors-swatch.selected {\\n  border-color: #000;\\n}\\n\\n/* Inline controls */\\n.minicolors-inline {\\n  display: inline-block;\\n}\\n\\n.minicolors-inline .minicolors-input {\\n  display: none !important;\\n}\\n\\n.minicolors-inline .minicolors-panel {\\n  position: relative;\\n  top: auto;\\n  left: auto; /* LTR */\\n  box-shadow: none;\\n  z-index: auto;\\n  display: inline-block;\\n}\\n[dir=rtl] .minicolors-inline .minicolors-panel {\\n  right: auto;\\n}\\n\\n/* Default theme */\\n.minicolors-theme-default .minicolors-swatch {\\n  top: 0;\\n  left: 0;\\n  width: 18px;\\n  height: 18px;\\n}\\n[dir=rtl] .minicolors-theme-default .minicolors-swatch {\\n  right: 5px;\\n}\\n.minicolors-theme-default .minicolors-swatches .minicolors-swatch {\\n  margin-bottom: 2px;\\n  top: 0;\\n  left: 0; /* LTR */\\n  width: 18px;\\n  height: 18px;\\n}\\n[dir=rtl] .minicolors-theme-default .minicolors-swatches .minicolors-swatch {\\n  right: 0;\\n}\\n.minicolors-theme-default.minicolors-position-right .minicolors-swatch {\\n  left: auto; /* LTR */\\n  right: 5px; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-default.minicolors-position-left .minicolors-swatch {\\n  right: auto;\\n  left: 5px;\\n}\\n.minicolors-theme-default.minicolors {\\n  width: auto;\\n  display: inline-block;\\n}\\n.minicolors-theme-default .minicolors-input {\\n  height: 20px;\\n  width: auto;\\n  display: inline-block;\\n  padding-left: 26px; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-default .minicolors-input {\\n  text-align: right;\\n  unicode-bidi: plaintext;\\n  padding-left: 1px;\\n  padding-right: 26px;\\n}\\n.minicolors-theme-default.minicolors-position-right .minicolors-input {\\n  padding-right: 26px; /* LTR */\\n  padding-left: inherit; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-default.minicolors-position-left .minicolors-input {\\n  padding-right: inherit;\\n  padding-left: 26px;\\n}\\n\\n/* Bootstrap theme */\\n.minicolors-theme-bootstrap .minicolors-swatch {\\n  z-index: 2;\\n  top: 3px;\\n  left: 3px; /* LTR */\\n  width: 28px;\\n  height: 28px;\\n  border-radius: 3px;\\n}\\n[dir=rtl] .minicolors-theme-bootstrap .minicolors-swatch {\\n  right: 3px;\\n}\\n.minicolors-theme-bootstrap .minicolors-swatches .minicolors-swatch {\\n  margin-bottom: 2px;\\n  top: 0;\\n  left: 0; /* LTR */\\n  width: 20px;\\n  height: 20px;\\n}\\n[dir=rtl] .minicolors-theme-bootstrap .minicolors-swatches .minicolors-swatch {\\n  right: 0;\\n}\\n.minicolors-theme-bootstrap .minicolors-swatch-color {\\n  border-radius: inherit;\\n}\\n.minicolors-theme-bootstrap.minicolors-position-right > .minicolors-swatch {\\n  left: auto; /* LTR */\\n  right: 3px; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-bootstrap.minicolors-position-left > .minicolors-swatch {\\n  right: auto;\\n  left: 3px;\\n}\\n.minicolors-theme-bootstrap .minicolors-input {\\n  float: none;\\n  padding-left: 44px; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-bootstrap .minicolors-input {\\n  text-align: right;\\n  unicode-bidi: plaintext;\\n  padding-left: 12px;\\n  padding-right: 44px;\\n}\\n.minicolors-theme-bootstrap.minicolors-position-right .minicolors-input {\\n  padding-right: 44px; /* LTR */\\n  padding-left: 12px; /* LTR */\\n}\\n[dir=rtl] .minicolors-theme-bootstrap.minicolors-position-left .minicolors-input {\\n  padding-right: 12px;\\n  padding-left: 44px;\\n}\\n.minicolors-theme-bootstrap .minicolors-input.input-lg + .minicolors-swatch {\\n  top: 4px;\\n  left: 4px; /* LTR */\\n  width: 37px;\\n  height: 37px;\\n  border-radius: 5px;\\n}\\n[dir=rtl] .minicolors-theme-bootstrap .minicolors-input.input-lg + .minicolors-swatch {\\n  right: 4px;\\n}\\n.minicolors-theme-bootstrap .minicolors-input.input-sm + .minicolors-swatch {\\n  width: 24px;\\n  height: 24px;\\n}\\n.minicolors-theme-bootstrap .minicolors-input.input-xs + .minicolors-swatch {\\n  width: 18px;\\n  height: 18px;\\n}\\n.input-group .minicolors-theme-bootstrap:not(:first-child) .minicolors-input {\\n  border-top-left-radius: 0; /* LTR */\\n  border-bottom-left-radius: 0; /* LTR */\\n}\\n[dir=rtl] .input-group .minicolors-theme-bootstrap .minicolors-input {\\n  border-radius: 4px;\\n}\\n[dir=rtl] .input-group .minicolors-theme-bootstrap:not(:first-child) .minicolors-input {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n[dir=rtl] .input-group .minicolors-theme-bootstrap:not(:last-child) .minicolors-input {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n/* bootstrap input-group rtl override */\\n[dir=rtl] .input-group .form-control,\\n[dir=rtl] .input-group-addon,\\n[dir=rtl] .input-group-btn > .btn,\\n[dir=rtl] .input-group-btn > .btn-group > .btn,\\n[dir=rtl] .input-group-btn > .dropdown-toggle {\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n}\\n[dir=rtl] .input-group .form-control:first-child,\\n[dir=rtl] .input-group-addon:first-child,\\n[dir=rtl] .input-group-btn:first-child > .btn,\\n[dir=rtl] .input-group-btn:first-child > .btn-group > .btn,\\n[dir=rtl] .input-group-btn:first-child > .dropdown-toggle,\\n[dir=rtl] .input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle),\\n[dir=rtl] .input-group-btn:last-child > .btn-group:not(:last-child) > .btn {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n  border-left: 0;\\n}\\n[dir=rtl] .input-group .form-control:last-child,\\n[dir=rtl] .input-group-addon:last-child,\\n[dir=rtl] .input-group-btn:last-child > .btn,\\n[dir=rtl] .input-group-btn:last-child > .btn-group > .btn,\\n[dir=rtl] .input-group-btn:last-child > .dropdown-toggle,\\n[dir=rtl] .input-group-btn:first-child > .btn:not(:first-child),\\n[dir=rtl] .input-group-btn:first-child > .btn-group:not(:first-child) > .btn {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n\\n/* Semantic Ui theme */\\n.minicolors-theme-semanticui .minicolors-swatch {\\n  top: 0;\\n  left: 0; /* LTR */\\n  padding: 18px;\\n}\\n[dir=rtl] .minicolors-theme-semanticui .minicolors-swatch {\\n  right: 0;\\n}\\n.minicolors-theme-semanticui input {\\n  text-indent: 30px;\\n}\\n\", \"\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL2pxdWVyeS5taW5pY29sb3JzLmNzcz80MDE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLDJHQUFzRDtBQUN6RjtBQUNBLGNBQWMsUUFBUyxnQkFBZ0IsdUJBQXVCLEdBQUcsd0JBQXdCLGtFQUFrRSxHQUFHLHdCQUF3Qix1QkFBdUIsMkJBQTJCLGlDQUFpQywyQkFBMkIsaUJBQWlCLGVBQWUsY0FBYywwQkFBMEIsR0FBRyw4QkFBOEIsdUJBQXVCLFdBQVcsWUFBWSxhQUFhLGNBQWMsR0FBRyx5REFBeUQsZ0JBQWdCLHFCQUFxQixvQkFBb0IsR0FBRyxtRUFBbUUsb0JBQW9CLEdBQUcsb0NBQW9DLG9CQUFvQixpQkFBaUIsc0JBQXNCLDJCQUEyQiwyQ0FBMkMsbUJBQW1CLDRCQUE0QixrQkFBa0IsWUFBWSxhQUFhLCtCQUErQixHQUFHLDBDQUEwQyxtQkFBbUIsR0FBRyx5RUFBeUUsZ0JBQWdCLEdBQUcsa0RBQWtELGFBQWEsR0FBRyxtREFBbUQsY0FBYyxHQUFHLGlEQUFpRCxZQUFZLEdBQUcsZ0RBQWdELGlCQUFpQixHQUFHLGtDQUFrQyx1QkFBdUIsYUFBYSxjQUFjLDJCQUEyQixrQkFBa0IsdUJBQXVCLGtDQUFrQyxzQkFBc0IsR0FBRywwQ0FBMEMsZUFBZSxHQUFHLHdDQUF3Qyx1QkFBdUIsV0FBVyxZQUFZLGlCQUFpQixrQkFBa0IsR0FBRyxvREFBb0Qsa0NBQWtDLEdBQUcsMERBQTBELGtDQUFrQyw4QkFBOEIsR0FBRyxvREFBb0Qsa0NBQWtDLEdBQUcsMERBQTBELDRCQUE0QixHQUFHLCtDQUErQyxrQ0FBa0MsR0FBRyxxREFBcUQsdUJBQXVCLGFBQWEsZ0JBQWdCLDBCQUEwQixrQkFBa0IsNEJBQTRCLDZCQUE2Qix1QkFBdUIsR0FBRyx1RUFBdUUsaUJBQWlCLEdBQUcsc0RBQXNELGlDQUFpQyxHQUFHLHNEQUFzRCxpQ0FBaUMsR0FBRyxpREFBaUQsaUNBQWlDLEdBQUcsZ0NBQWdDLGdCQUFnQiwyQ0FBMkMsa0JBQWtCLEdBQUcsd0NBQXdDLGlCQUFpQixHQUFHLHlEQUF5RCxtQkFBbUIsR0FBRyx3REFBd0QsdUJBQXVCLGNBQWMsZUFBZSxnQkFBZ0IsaUJBQWlCLDRCQUE0Qix3QkFBd0IscUJBQXFCLHNCQUFzQixxQkFBcUIsR0FBRywrQ0FBK0MsdUJBQXVCLFdBQVcsWUFBWSxlQUFlLGdCQUFnQix1QkFBdUIsNEJBQTRCLDRCQUE0QixHQUFHLHdCQUF3Qix1QkFBdUIsV0FBVyxZQUFZLGdCQUFnQixnQkFBZ0Isc0JBQXNCLDRCQUE0QixxQkFBcUIsNEJBQTRCLEdBQUcsb0VBQW9FLDBCQUEwQix5QkFBeUIscUJBQXFCLHFCQUFxQixHQUFHLHNFQUFzRSwwQkFBMEIsR0FBRyw2Q0FBNkMsdUJBQXVCLGdCQUFnQiw4QkFBOEIscUJBQXFCLGFBQWEscURBQXFELGlCQUFpQixxQkFBcUIsR0FBRyxzRUFBc0Usc0JBQXNCLGFBQWEsOEVBQThFLG9CQUFvQixxQkFBcUIsR0FBRyxpQ0FBaUMsdUJBQXVCLEdBQUcsK0NBQStDLDBCQUEwQixHQUFHLDBDQUEwQyw2QkFBNkIsR0FBRywwQ0FBMEMsdUJBQXVCLGNBQWMsZUFBZSwrQkFBK0Isa0JBQWtCLDBCQUEwQixHQUFHLGtEQUFrRCxnQkFBZ0IsR0FBRyx1RUFBdUUsV0FBVyxZQUFZLGdCQUFnQixpQkFBaUIsR0FBRywwREFBMEQsZUFBZSxHQUFHLHFFQUFxRSx1QkFBdUIsV0FBVyxZQUFZLDBCQUEwQixpQkFBaUIsR0FBRywrRUFBK0UsYUFBYSxHQUFHLDBFQUEwRSxlQUFlLHlCQUF5QixhQUFhLG1GQUFtRixnQkFBZ0IsY0FBYyxHQUFHLHdDQUF3QyxnQkFBZ0IsMEJBQTBCLEdBQUcsK0NBQStDLGlCQUFpQixnQkFBZ0IsMEJBQTBCLHVCQUF1QixhQUFhLHlEQUF5RCxzQkFBc0IsNEJBQTRCLHNCQUFzQix3QkFBd0IsR0FBRyx5RUFBeUUsd0JBQXdCLG9DQUFvQyxhQUFhLGtGQUFrRiwyQkFBMkIsdUJBQXVCLEdBQUcsMkVBQTJFLGVBQWUsYUFBYSxjQUFjLDBCQUEwQixpQkFBaUIsdUJBQXVCLEdBQUcsNERBQTRELGVBQWUsR0FBRyx1RUFBdUUsdUJBQXVCLFdBQVcsWUFBWSwwQkFBMEIsaUJBQWlCLEdBQUcsaUZBQWlGLGFBQWEsR0FBRyx3REFBd0QsMkJBQTJCLEdBQUcsOEVBQThFLGVBQWUseUJBQXlCLGFBQWEsdUZBQXVGLGdCQUFnQixjQUFjLEdBQUcsaURBQWlELGdCQUFnQix1QkFBdUIsYUFBYSwyREFBMkQsc0JBQXNCLDRCQUE0Qix1QkFBdUIsd0JBQXdCLEdBQUcsMkVBQTJFLHdCQUF3QixpQ0FBaUMsYUFBYSxvRkFBb0Ysd0JBQXdCLHVCQUF1QixHQUFHLCtFQUErRSxhQUFhLGNBQWMsMEJBQTBCLGlCQUFpQix1QkFBdUIsR0FBRyx5RkFBeUYsZUFBZSxHQUFHLCtFQUErRSxnQkFBZ0IsaUJBQWlCLEdBQUcsK0VBQStFLGdCQUFnQixpQkFBaUIsR0FBRyxnRkFBZ0YsOEJBQThCLDJDQUEyQyxhQUFhLHdFQUF3RSx1QkFBdUIsR0FBRywwRkFBMEYsK0JBQStCLGtDQUFrQyxHQUFHLHlGQUF5Riw4QkFBOEIsaUNBQWlDLEdBQUcsc1BBQXNQLDJCQUEyQix1QkFBdUIsR0FBRywyYUFBMmEsOEJBQThCLGlDQUFpQyxtQkFBbUIsR0FBRyxvWkFBb1osK0JBQStCLGtDQUFrQyxHQUFHLDhFQUE4RSxXQUFXLFlBQVksNEJBQTRCLEdBQUcsNkRBQTZELGFBQWEsR0FBRyxzQ0FBc0Msc0JBQXNCLEdBQUciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9yZXNvdXJjZXMvd3JpdGUvanF1ZXJ5Lm1pbmljb2xvcnMuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWluaWNvbG9ycyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5taW5pY29sb3JzLXNwcml0ZSB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL3Jlc291cmNlcy93cml0ZS9qcXVlcnkubWluaWNvbG9ycy5wbmcpO1xcbn1cXG5cXG4ubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC04MHB4IDA7XFxuICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xcbiAgY3Vyc29yOiB0ZXh0O1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLm1pbmljb2xvcnMtc3dhdGNoLWNvbG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuLm1pbmljb2xvcnMgaW5wdXRbdHlwZT1oaWRkZW5dICsgLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIHdpZHRoOiAyOHB4O1xcbiAgcG9zaXRpb246IHN0YXRpYztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLm1pbmljb2xvcnMgaW5wdXRbdHlwZT1oaWRkZW5dW2Rpc2FibGVkXSArIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qIFBhbmVsICovXFxuLm1pbmljb2xvcnMtcGFuZWwge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2lkdGg6IDE3M3B4O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBib3JkZXI6IHNvbGlkIDFweCAjQ0NDO1xcbiAgYm94LXNoYWRvdzogMCAwIDIwcHggcmdiYSgwLCAwLCAwLCAuMik7XFxuICB6LWluZGV4OiA5OTk5OTtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHRvcDo1MCU7XFxuICBsZWZ0OjUwJTtcXG4gIHRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO1xcbn1cXG5cXG4ubWluaWNvbG9ycy1wYW5lbC5taW5pY29sb3JzLXZpc2libGUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qIFBhbmVsIHBvc2l0aW9uaW5nICovXFxuLm1pbmljb2xvcnMtcG9zaXRpb24tdG9wIC5taW5pY29sb3JzLXBhbmVsIHtcXG4gIHRvcDogLTE1NHB4O1xcbn1cXG5cXG4ubWluaWNvbG9ycy1wb3NpdGlvbi1yaWdodCAubWluaWNvbG9ycy1wYW5lbCB7XFxuICByaWdodDogMDtcXG59XFxuXFxuLm1pbmljb2xvcnMtcG9zaXRpb24tYm90dG9tIC5taW5pY29sb3JzLXBhbmVsIHtcXG4gIHRvcDogYXV0bztcXG59XFxuXFxuLm1pbmljb2xvcnMtcG9zaXRpb24tbGVmdCAubWluaWNvbG9ycy1wYW5lbCB7XFxuICBsZWZ0OiAwO1xcbn1cXG5cXG4ubWluaWNvbG9ycy13aXRoLW9wYWNpdHkgLm1pbmljb2xvcnMtcGFuZWwge1xcbiAgd2lkdGg6IDE5NHB4O1xcbn1cXG5cXG4ubWluaWNvbG9ycyAubWluaWNvbG9ycy1ncmlkIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogMXB4O1xcbiAgbGVmdDogMXB4OyAvKiBMVFIgKi9cXG4gIHdpZHRoOiAxNTBweDtcXG4gIGhlaWdodDogMTUwcHg7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTIwcHggMDtcXG4gIGN1cnNvcjogY3Jvc3NoYWlyO1xcbn1cXG5bZGlyPXJ0bF0gLm1pbmljb2xvcnMgLm1pbmljb2xvcnMtZ3JpZCB7XFxuICByaWdodDogMXB4O1xcbn1cXG5cXG4ubWluaWNvbG9ycyAubWluaWNvbG9ycy1ncmlkLWlubmVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTUwcHg7XFxuICBoZWlnaHQ6IDE1MHB4O1xcbn1cXG5cXG4ubWluaWNvbG9ycy1zbGlkZXItc2F0dXJhdGlvbiAubWluaWNvbG9ycy1ncmlkIHtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC00MjBweCAwO1xcbn1cXG5cXG4ubWluaWNvbG9ycy1zbGlkZXItc2F0dXJhdGlvbiAubWluaWNvbG9ycy1ncmlkLWlubmVyIHtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC0yNzBweCAwO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogaW5oZXJpdDtcXG59XFxuXFxuLm1pbmljb2xvcnMtc2xpZGVyLWJyaWdodG5lc3MgLm1pbmljb2xvcnMtZ3JpZCB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNTcwcHggMDtcXG59XFxuXFxuLm1pbmljb2xvcnMtc2xpZGVyLWJyaWdodG5lc3MgLm1pbmljb2xvcnMtZ3JpZC1pbm5lciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG59XFxuXFxuLm1pbmljb2xvcnMtc2xpZGVyLXdoZWVsIC5taW5pY29sb3JzLWdyaWQge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTcyMHB4IDA7XFxufVxcblxcbi5taW5pY29sb3JzLXNsaWRlcixcXG4ubWluaWNvbG9ycy1vcGFjaXR5LXNsaWRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDFweDtcXG4gIGxlZnQ6IDE1MnB4OyAvKiBMVFIgKi9cXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAxNTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1xcbiAgY3Vyc29yOiByb3ctcmVzaXplO1xcbn1cXG5bZGlyPXJ0bF0gLm1pbmljb2xvcnMtc2xpZGVyLFxcbltkaXI9cnRsXSAubWluaWNvbG9ycy1vcGFjaXR5LXNsaWRlciB7XFxuICByaWdodDogMTUycHg7XFxufVxcblxcbi5taW5pY29sb3JzLXNsaWRlci1zYXR1cmF0aW9uIC5taW5pY29sb3JzLXNsaWRlciB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNjBweCAwO1xcbn1cXG5cXG4ubWluaWNvbG9ycy1zbGlkZXItYnJpZ2h0bmVzcyAubWluaWNvbG9ycy1zbGlkZXIge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTIwcHggMDtcXG59XFxuXFxuLm1pbmljb2xvcnMtc2xpZGVyLXdoZWVsIC5taW5pY29sb3JzLXNsaWRlciB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjBweCAwO1xcbn1cXG5cXG4ubWluaWNvbG9ycy1vcGFjaXR5LXNsaWRlciB7XFxuICBsZWZ0OiAxNzNweDsgLyogTFRSICovXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDBweCAwO1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLW9wYWNpdHktc2xpZGVyIHtcXG4gIHJpZ2h0OiAxNzNweDtcXG59XFxuXFxuLm1pbmljb2xvcnMtd2l0aC1vcGFjaXR5IC5taW5pY29sb3JzLW9wYWNpdHktc2xpZGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKiBQaWNrZXJzICovXFxuLm1pbmljb2xvcnMtZ3JpZCAubWluaWNvbG9ycy1waWNrZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA3MHB4O1xcbiAgbGVmdDogNzBweDtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgYm9yZGVyOiBzb2xpZCAxcHggYmxhY2s7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgbWFyZ2luLXRvcDogLTZweDtcXG4gIG1hcmdpbi1sZWZ0OiAtNnB4O1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG59XFxuXFxuLm1pbmljb2xvcnMtZ3JpZCAubWluaWNvbG9ycy1waWNrZXIgPiBkaXYge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiA4cHg7XFxuICBoZWlnaHQ6IDhweDtcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gIGJvcmRlcjogc29saWQgMnB4IHdoaXRlO1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcblxcbi5taW5pY29sb3JzLXBpY2tlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDE4cHg7XFxuICBoZWlnaHQ6IDJweDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm9yZGVyOiBzb2xpZCAxcHggYmxhY2s7XFxuICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcblxcbi8qIFN3YXRjaGVzICovXFxuLm1pbmljb2xvcnMtc3dhdGNoZXMsXFxuLm1pbmljb2xvcnMtc3dhdGNoZXMgbGkge1xcbiAgbWFyZ2luOiA1cHggMCAzcHggNXB4OyAvKiBMVFIgKi9cXG4gIHBhZGRpbmc6IDA7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXN3YXRjaGVzLFxcbltkaXI9cnRsXSAubWluaWNvbG9ycy1zd2F0Y2hlcyBsaSB7XFxuICBtYXJnaW46IDVweCA1cHggM3B4IDA7XFxufVxcblxcbi5taW5pY29sb3JzLXN3YXRjaGVzIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmbG9hdDogbGVmdDsgLyogTFRSICovXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBtYXJnaW46MCA0cHggMCAwOyAvKiBMVFIgKi9cXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXN3YXRjaGVzIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW46MCAwIDAgNHB4O1xcbn1cXG5cXG4ubWluaWNvbG9ycy13aXRoLW9wYWNpdHkgLm1pbmljb2xvcnMtc3dhdGNoZXMgLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIG1hcmdpbi1yaWdodDogN3B4OyAvKiBMVFIgKi9cXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXdpdGgtb3BhY2l0eSAubWluaWNvbG9ycy1zd2F0Y2hlcyAubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDdweDtcXG59XFxuXFxuLm1pbmljb2xvcnMtc3dhdGNoLnNlbGVjdGVkIHtcXG4gIGJvcmRlci1jb2xvcjogIzAwMDtcXG59XFxuXFxuLyogSW5saW5lIGNvbnRyb2xzICovXFxuLm1pbmljb2xvcnMtaW5saW5lIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLm1pbmljb2xvcnMtaW5saW5lIC5taW5pY29sb3JzLWlucHV0IHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLm1pbmljb2xvcnMtaW5saW5lIC5taW5pY29sb3JzLXBhbmVsIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogYXV0bztcXG4gIGxlZnQ6IGF1dG87IC8qIExUUiAqL1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG4gIHotaW5kZXg6IGF1dG87XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy1pbmxpbmUgLm1pbmljb2xvcnMtcGFuZWwge1xcbiAgcmlnaHQ6IGF1dG87XFxufVxcblxcbi8qIERlZmF1bHQgdGhlbWUgKi9cXG4ubWluaWNvbG9ycy10aGVtZS1kZWZhdWx0IC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy10aGVtZS1kZWZhdWx0IC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICByaWdodDogNXB4O1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1kZWZhdWx0IC5taW5pY29sb3JzLXN3YXRjaGVzIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwOyAvKiBMVFIgKi9cXG4gIHdpZHRoOiAxOHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG5bZGlyPXJ0bF0gLm1pbmljb2xvcnMtdGhlbWUtZGVmYXVsdCAubWluaWNvbG9ycy1zd2F0Y2hlcyAubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgcmlnaHQ6IDA7XFxufVxcbi5taW5pY29sb3JzLXRoZW1lLWRlZmF1bHQubWluaWNvbG9ycy1wb3NpdGlvbi1yaWdodCAubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgbGVmdDogYXV0bzsgLyogTFRSICovXFxuICByaWdodDogNXB4OyAvKiBMVFIgKi9cXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXRoZW1lLWRlZmF1bHQubWluaWNvbG9ycy1wb3NpdGlvbi1sZWZ0IC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICByaWdodDogYXV0bztcXG4gIGxlZnQ6IDVweDtcXG59XFxuLm1pbmljb2xvcnMtdGhlbWUtZGVmYXVsdC5taW5pY29sb3JzIHtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1kZWZhdWx0IC5taW5pY29sb3JzLWlucHV0IHtcXG4gIGhlaWdodDogMjBweDtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcGFkZGluZy1sZWZ0OiAyNnB4OyAvKiBMVFIgKi9cXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXRoZW1lLWRlZmF1bHQgLm1pbmljb2xvcnMtaW5wdXQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICB1bmljb2RlLWJpZGk6IHBsYWludGV4dDtcXG4gIHBhZGRpbmctbGVmdDogMXB4O1xcbiAgcGFkZGluZy1yaWdodDogMjZweDtcXG59XFxuLm1pbmljb2xvcnMtdGhlbWUtZGVmYXVsdC5taW5pY29sb3JzLXBvc2l0aW9uLXJpZ2h0IC5taW5pY29sb3JzLWlucHV0IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDI2cHg7IC8qIExUUiAqL1xcbiAgcGFkZGluZy1sZWZ0OiBpbmhlcml0OyAvKiBMVFIgKi9cXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXRoZW1lLWRlZmF1bHQubWluaWNvbG9ycy1wb3NpdGlvbi1sZWZ0IC5taW5pY29sb3JzLWlucHV0IHtcXG4gIHBhZGRpbmctcmlnaHQ6IGluaGVyaXQ7XFxuICBwYWRkaW5nLWxlZnQ6IDI2cHg7XFxufVxcblxcbi8qIEJvb3RzdHJhcCB0aGVtZSAqL1xcbi5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcCAubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgei1pbmRleDogMjtcXG4gIHRvcDogM3B4O1xcbiAgbGVmdDogM3B4OyAvKiBMVFIgKi9cXG4gIHdpZHRoOiAyOHB4O1xcbiAgaGVpZ2h0OiAyOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5bZGlyPXJ0bF0gLm1pbmljb2xvcnMtdGhlbWUtYm9vdHN0cmFwIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICByaWdodDogM3B4O1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAgLm1pbmljb2xvcnMtc3dhdGNoZXMgLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7IC8qIExUUiAqL1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAgLm1pbmljb2xvcnMtc3dhdGNoZXMgLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIHJpZ2h0OiAwO1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAgLm1pbmljb2xvcnMtc3dhdGNoLWNvbG9yIHtcXG4gIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XFxufVxcbi5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcC5taW5pY29sb3JzLXBvc2l0aW9uLXJpZ2h0ID4gLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIGxlZnQ6IGF1dG87IC8qIExUUiAqL1xcbiAgcmlnaHQ6IDNweDsgLyogTFRSICovXFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAubWluaWNvbG9ycy1wb3NpdGlvbi1sZWZ0ID4gLm1pbmljb2xvcnMtc3dhdGNoIHtcXG4gIHJpZ2h0OiBhdXRvO1xcbiAgbGVmdDogM3B4O1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAgLm1pbmljb2xvcnMtaW5wdXQge1xcbiAgZmxvYXQ6IG5vbmU7XFxuICBwYWRkaW5nLWxlZnQ6IDQ0cHg7IC8qIExUUiAqL1xcbn1cXG5bZGlyPXJ0bF0gLm1pbmljb2xvcnMtdGhlbWUtYm9vdHN0cmFwIC5taW5pY29sb3JzLWlucHV0IHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgdW5pY29kZS1iaWRpOiBwbGFpbnRleHQ7XFxuICBwYWRkaW5nLWxlZnQ6IDEycHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA0NHB4O1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAubWluaWNvbG9ycy1wb3NpdGlvbi1yaWdodCAubWluaWNvbG9ycy1pbnB1dCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0NHB4OyAvKiBMVFIgKi9cXG4gIHBhZGRpbmctbGVmdDogMTJweDsgLyogTFRSICovXFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAubWluaWNvbG9ycy1wb3NpdGlvbi1sZWZ0IC5taW5pY29sb3JzLWlucHV0IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDEycHg7XFxuICBwYWRkaW5nLWxlZnQ6IDQ0cHg7XFxufVxcbi5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcCAubWluaWNvbG9ycy1pbnB1dC5pbnB1dC1sZyArIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICB0b3A6IDRweDtcXG4gIGxlZnQ6IDRweDsgLyogTFRSICovXFxuICB3aWR0aDogMzdweDtcXG4gIGhlaWdodDogMzdweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuW2Rpcj1ydGxdIC5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcCAubWluaWNvbG9ycy1pbnB1dC5pbnB1dC1sZyArIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICByaWdodDogNHB4O1xcbn1cXG4ubWluaWNvbG9ycy10aGVtZS1ib290c3RyYXAgLm1pbmljb2xvcnMtaW5wdXQuaW5wdXQtc20gKyAubWluaWNvbG9ycy1zd2F0Y2gge1xcbiAgd2lkdGg6IDI0cHg7XFxuICBoZWlnaHQ6IDI0cHg7XFxufVxcbi5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcCAubWluaWNvbG9ycy1pbnB1dC5pbnB1dC14cyArIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICB3aWR0aDogMThweDtcXG4gIGhlaWdodDogMThweDtcXG59XFxuLmlucHV0LWdyb3VwIC5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcDpub3QoOmZpcnN0LWNoaWxkKSAubWluaWNvbG9ycy1pbnB1dCB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwOyAvKiBMVFIgKi9cXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7IC8qIExUUiAqL1xcbn1cXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwIC5taW5pY29sb3JzLXRoZW1lLWJvb3RzdHJhcCAubWluaWNvbG9ycy1pbnB1dCB7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxufVxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAgLm1pbmljb2xvcnMtdGhlbWUtYm9vdHN0cmFwOm5vdCg6Zmlyc3QtY2hpbGQpIC5taW5pY29sb3JzLWlucHV0IHtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxufVxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAgLm1pbmljb2xvcnMtdGhlbWUtYm9vdHN0cmFwOm5vdCg6bGFzdC1jaGlsZCkgLm1pbmljb2xvcnMtaW5wdXQge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxufVxcbi8qIGJvb3RzdHJhcCBpbnB1dC1ncm91cCBydGwgb3ZlcnJpZGUgKi9cXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwIC5mb3JtLWNvbnRyb2wsXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1hZGRvbixcXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwLWJ0biA+IC5idG4sXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1idG4gPiAuYnRuLWdyb3VwID4gLmJ0bixcXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwLWJ0biA+IC5kcm9wZG93bi10b2dnbGUge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG59XFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cCAuZm9ybS1jb250cm9sOmZpcnN0LWNoaWxkLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYWRkb246Zmlyc3QtY2hpbGQsXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1idG46Zmlyc3QtY2hpbGQgPiAuYnRuLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYnRuOmZpcnN0LWNoaWxkID4gLmJ0bi1ncm91cCA+IC5idG4sXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1idG46Zmlyc3QtY2hpbGQgPiAuZHJvcGRvd24tdG9nZ2xlLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYnRuOmxhc3QtY2hpbGQgPiAuYnRuOm5vdCg6bGFzdC1jaGlsZCk6bm90KC5kcm9wZG93bi10b2dnbGUpLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYnRuOmxhc3QtY2hpbGQgPiAuYnRuLWdyb3VwOm5vdCg6bGFzdC1jaGlsZCkgPiAuYnRuIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWxlZnQ6IDA7XFxufVxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAgLmZvcm0tY29udHJvbDpsYXN0LWNoaWxkLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYWRkb246bGFzdC1jaGlsZCxcXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwLWJ0bjpsYXN0LWNoaWxkID4gLmJ0bixcXG5bZGlyPXJ0bF0gLmlucHV0LWdyb3VwLWJ0bjpsYXN0LWNoaWxkID4gLmJ0bi1ncm91cCA+IC5idG4sXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1idG46bGFzdC1jaGlsZCA+IC5kcm9wZG93bi10b2dnbGUsXFxuW2Rpcj1ydGxdIC5pbnB1dC1ncm91cC1idG46Zmlyc3QtY2hpbGQgPiAuYnRuOm5vdCg6Zmlyc3QtY2hpbGQpLFxcbltkaXI9cnRsXSAuaW5wdXQtZ3JvdXAtYnRuOmZpcnN0LWNoaWxkID4gLmJ0bi1ncm91cDpub3QoOmZpcnN0LWNoaWxkKSA+IC5idG4ge1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG59XFxuXFxuLyogU2VtYW50aWMgVWkgdGhlbWUgKi9cXG4ubWluaWNvbG9ycy10aGVtZS1zZW1hbnRpY3VpIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwOyAvKiBMVFIgKi9cXG4gIHBhZGRpbmc6IDE4cHg7XFxufVxcbltkaXI9cnRsXSAubWluaWNvbG9ycy10aGVtZS1zZW1hbnRpY3VpIC5taW5pY29sb3JzLXN3YXRjaCB7XFxuICByaWdodDogMDtcXG59XFxuLm1pbmljb2xvcnMtdGhlbWUtc2VtYW50aWN1aSBpbnB1dCB7XFxuICB0ZXh0LWluZGVudDogMzBweDtcXG59XFxuXCIsIFwiXCJdKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css":
/*!*****************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \".write_form{padding:10px 20px;}\\n.title{font-size:21px;margin:15px 0;}\\n\\n.write_tit{font-size:15px;}\\n.write_tit,\\n\\n.write_cont{display:block;width:100%;padding:10px;border:1px solid black;box-sizing:border-box;margin-top:20px;}\\n.write_cont{min-height:30vh;}\\n.write_cont.ty_summary{min-height:10vh;}\\n.write_cont b{font-weight:bold;}\\n.write_cont li{padding-left:5px;word-break:break-all;}\\n.write_cont ul li:before{content:\\\"\\\";display:inline-block;width:10px;height:10px;border-radius:50%;background:black;margin-right:5px;}\\n.write_cont ol{list-style:decimal;margin-left:15px;}\\n\\n.btnarea{display:flex;align-items:center;justify-content: space-evenly;padding:10px;border:1px solid black;}\\n.btnarea + .btnarea{margin-top:-1px;}\\n.btnarea .btn{display:block;line-height:1;font-size:21px;color:#ff5b59;font-weight:bold;}\\n\\n.inserted_image{width:100px;height:100px;}\\n.inserted_image.on{max-width:100%;max-height:100%;width:auto;height:auto;position:fixed;top:0;left:0;right:0;bottom:0;margin:auto;overflow:auto;}\\n\\n.fontsize input{border:1px solid black; width:30px; margin-left:5px;}\\n.submit{display:block;margin:auto;border:1px solid black; border-radius:20px; padding: 10px 80px; margin: 50px auto;}\", \"\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL3dyaXRlLmNzcz9hNzI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLDJHQUFzRDtBQUN6RjtBQUNBLGNBQWMsUUFBUyxlQUFlLG1CQUFtQixTQUFTLGVBQWUsZUFBZSxlQUFlLGdCQUFnQiw2QkFBNkIsY0FBYyxXQUFXLGFBQWEsdUJBQXVCLHNCQUFzQixpQkFBaUIsY0FBYyxpQkFBaUIseUJBQXlCLGlCQUFpQixnQkFBZ0Isa0JBQWtCLGlCQUFpQixpQkFBaUIsc0JBQXNCLDJCQUEyQixhQUFhLHFCQUFxQixXQUFXLFlBQVksa0JBQWtCLGlCQUFpQixrQkFBa0IsaUJBQWlCLG1CQUFtQixrQkFBa0IsYUFBYSxhQUFhLG1CQUFtQiw4QkFBOEIsYUFBYSx3QkFBd0Isc0JBQXNCLGlCQUFpQixnQkFBZ0IsY0FBYyxjQUFjLGVBQWUsY0FBYyxrQkFBa0Isb0JBQW9CLFlBQVksY0FBYyxxQkFBcUIsZUFBZSxnQkFBZ0IsV0FBVyxZQUFZLGVBQWUsTUFBTSxPQUFPLFFBQVEsU0FBUyxZQUFZLGVBQWUsb0JBQW9CLHVCQUF1QixZQUFZLGtCQUFrQixVQUFVLGNBQWMsWUFBWSx1QkFBdUIsb0JBQW9CLG9CQUFvQixvQkFBb0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9yZXNvdXJjZXMvd3JpdGUvd3JpdGUuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud3JpdGVfZm9ybXtwYWRkaW5nOjEwcHggMjBweDt9XFxuLnRpdGxle2ZvbnQtc2l6ZToyMXB4O21hcmdpbjoxNXB4IDA7fVxcblxcbi53cml0ZV90aXR7Zm9udC1zaXplOjE1cHg7fVxcbi53cml0ZV90aXQsXFxuXFxuLndyaXRlX2NvbnR7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO3BhZGRpbmc6MTBweDtib3JkZXI6MXB4IHNvbGlkIGJsYWNrO2JveC1zaXppbmc6Ym9yZGVyLWJveDttYXJnaW4tdG9wOjIwcHg7fVxcbi53cml0ZV9jb250e21pbi1oZWlnaHQ6MzB2aDt9XFxuLndyaXRlX2NvbnQudHlfc3VtbWFyeXttaW4taGVpZ2h0OjEwdmg7fVxcbi53cml0ZV9jb250IGJ7Zm9udC13ZWlnaHQ6Ym9sZDt9XFxuLndyaXRlX2NvbnQgbGl7cGFkZGluZy1sZWZ0OjVweDt3b3JkLWJyZWFrOmJyZWFrLWFsbDt9XFxuLndyaXRlX2NvbnQgdWwgbGk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOmJsYWNrO21hcmdpbi1yaWdodDo1cHg7fVxcbi53cml0ZV9jb250IG9se2xpc3Qtc3R5bGU6ZGVjaW1hbDttYXJnaW4tbGVmdDoxNXB4O31cXG5cXG4uYnRuYXJlYXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O3BhZGRpbmc6MTBweDtib3JkZXI6MXB4IHNvbGlkIGJsYWNrO31cXG4uYnRuYXJlYSArIC5idG5hcmVhe21hcmdpbi10b3A6LTFweDt9XFxuLmJ0bmFyZWEgLmJ0bntkaXNwbGF5OmJsb2NrO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOjIxcHg7Y29sb3I6I2ZmNWI1OTtmb250LXdlaWdodDpib2xkO31cXG5cXG4uaW5zZXJ0ZWRfaW1hZ2V7d2lkdGg6MTAwcHg7aGVpZ2h0OjEwMHB4O31cXG4uaW5zZXJ0ZWRfaW1hZ2Uub257bWF4LXdpZHRoOjEwMCU7bWF4LWhlaWdodDoxMDAlO3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7bWFyZ2luOmF1dG87b3ZlcmZsb3c6YXV0bzt9XFxuXFxuLmZvbnRzaXplIGlucHV0e2JvcmRlcjoxcHggc29saWQgYmxhY2s7IHdpZHRoOjMwcHg7IG1hcmdpbi1sZWZ0OjVweDt9XFxuLnN1Ym1pdHtkaXNwbGF5OmJsb2NrO21hcmdpbjphdXRvO2JvcmRlcjoxcHggc29saWQgYmxhY2s7IGJvcmRlci1yYWRpdXM6MjBweDsgcGFkZGluZzogMTBweCA4MHB4OyBtYXJnaW46IDUwcHggYXV0bzt9XCIsIFwiXCJdKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css\n");

/***/ }),

/***/ "./src/resources/write/index.js":
/*!**************************************!*\
  !*** ./src/resources/write/index.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _write__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./write */ \"./src/resources/write/write.js\");\n/* harmony import */ var _write__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_write__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _squire__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./squire */ \"./src/resources/write/squire.js\");\n/* harmony import */ var _squire__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_squire__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _minicolors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minicolors */ \"./src/resources/write/minicolors.js\");\n/* harmony import */ var _minicolors__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_minicolors__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _write_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./write.css */ \"./src/resources/write/write.css\");\n/* harmony import */ var _write_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_write_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jquery_minicolors_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jquery.minicolors.css */ \"./src/resources/write/jquery.minicolors.css\");\n/* harmony import */ var _jquery_minicolors_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jquery_minicolors_css__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL2luZGV4LmpzPzdhZDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBIiwiZmlsZSI6Ii4vc3JjL3Jlc291cmNlcy93cml0ZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi93cml0ZSc7XG5pbXBvcnQgJy4vc3F1aXJlJztcbmltcG9ydCAnLi9taW5pY29sb3JzJztcbiBcbmltcG9ydCAnLi93cml0ZS5jc3MnO1xuaW1wb3J0ICcuL2pxdWVyeS5taW5pY29sb3JzLmNzcyc7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/resources/write/index.js\n");

/***/ }),

/***/ "./src/resources/write/jquery.minicolors.css":
/*!***************************************************!*\
  !*** ./src/resources/write/jquery.minicolors.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!./jquery.minicolors.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\nif (true) {\n  if (!content.locals) {\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js!./jquery.minicolors.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css\",\n      function () {\n        var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!./jquery.minicolors.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/jquery.minicolors.css\");\n\n        if (typeof newContent === 'string') {\n          newContent = [[module.i, newContent, '']];\n        }\n        \n        update(newContent);\n      }\n    )\n  }\n\n  module.hot.dispose(function() { \n    update();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL2pxdWVyeS5taW5pY29sb3JzLmNzcz81NDhkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxnS0FBd0U7O0FBRTlGO0FBQ0EsY0FBYyxRQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlKQUE4RTs7QUFFbkc7QUFDQTtBQUNBOztBQUVBLElBQUksSUFBVTtBQUNkO0FBQ0E7QUFDQSxNQUFNLGdLQUF3RTtBQUM5RTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLGdLQUF3RTs7QUFFekc7QUFDQSx5QkFBeUIsUUFBUztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQztBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vc3JjL3Jlc291cmNlcy93cml0ZS9qcXVlcnkubWluaWNvbG9ycy5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vanF1ZXJ5Lm1pbmljb2xvcnMuY3NzXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2Fscykge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vanF1ZXJ5Lm1pbmljb2xvcnMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9qcXVlcnkubWluaWNvbG9ycy5jc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgXG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/resources/write/jquery.minicolors.css\n");

/***/ }),

/***/ "./src/resources/write/minicolors.js":
/*!*******************************************!*\
  !*** ./src/resources/write/minicolors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//\n// jQuery MiniColors: A tiny color picker built on jQuery\n//\n// Developed by Cory LaViska for A Beautiful Site, LLC\n//\n// Licensed under the MIT license: http://opensource.org/licenses/MIT\n//\n(function (factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  'use strict'; // Defaults\n\n  $.minicolors = {\n    defaults: {\n      animationSpeed: 50,\n      animationEasing: 'swing',\n      change: null,\n      changeDelay: 0,\n      control: 'hue',\n      defaultValue: '',\n      format: 'hex',\n      hide: null,\n      hideSpeed: 100,\n      inline: false,\n      keywords: '',\n      letterCase: 'lowercase',\n      opacity: false,\n      position: 'bottom',\n      show: null,\n      showSpeed: 100,\n      theme: 'default',\n      swatches: []\n    }\n  }; // Public methods\n\n  $.extend($.fn, {\n    minicolors: function (method, data) {\n      switch (method) {\n        // Destroy the control\n        case 'destroy':\n          $(this).each(function () {\n            destroy($(this));\n          });\n          return $(this);\n        // Hide the color picker\n\n        case 'hide':\n          hide();\n          return $(this);\n        // Get/set opacity\n\n        case 'opacity':\n          // Getter\n          if (data === undefined) {\n            // Getter\n            return $(this).attr('data-opacity');\n          } else {\n            // Setter\n            $(this).each(function () {\n              updateFromInput($(this).attr('data-opacity', data));\n            });\n          }\n\n          return $(this);\n        // Get an RGB(A) object based on the current color/opacity\n\n        case 'rgbObject':\n          return rgbObject($(this), method === 'rgbaObject');\n        // Get an RGB(A) string based on the current color/opacity\n\n        case 'rgbString':\n        case 'rgbaString':\n          return rgbString($(this), method === 'rgbaString');\n        // Get/set settings on the fly\n\n        case 'settings':\n          if (data === undefined) {\n            return $(this).data('minicolors-settings');\n          } else {\n            // Setter\n            $(this).each(function () {\n              var settings = $(this).data('minicolors-settings') || {};\n              destroy($(this));\n              $(this).minicolors($.extend(true, settings, data));\n            });\n          }\n\n          return $(this);\n        // Show the color picker\n\n        case 'show':\n          show($(this).eq(0));\n          return $(this);\n        // Get/set the hex color value\n\n        case 'value':\n          if (data === undefined) {\n            // Getter\n            return $(this).val();\n          } else {\n            // Setter\n            $(this).each(function () {\n              if (typeof data === 'object' && data !== null) {\n                if (data.opacity !== undefined) {\n                  $(this).attr('data-opacity', keepWithin(data.opacity, 0, 1));\n                }\n\n                if (data.color) {\n                  $(this).val(data.color);\n                }\n              } else {\n                $(this).val(data);\n              }\n\n              updateFromInput($(this));\n            });\n          }\n\n          return $(this);\n        // Initializes the control\n\n        default:\n          if (method !== 'create') data = method;\n          $(this).each(function () {\n            init($(this), data);\n          });\n          return $(this);\n      }\n    }\n  }); // Initialize input elements\n\n  function init(input, settings) {\n    var minicolors = $('<div class=\"minicolors\" />');\n    var defaults = $.minicolors.defaults;\n    var name;\n    var size;\n    var swatches;\n    var swatch;\n    var swatchString;\n    var panel;\n    var i; // Do nothing if already initialized\n\n    if (input.data('minicolors-initialized')) return; // Handle settings\n\n    settings = $.extend(true, {}, defaults, settings); // The wrapper\n\n    minicolors.addClass('minicolors-theme-' + settings.theme).toggleClass('minicolors-with-opacity', settings.opacity); // Custom positioning\n\n    if (settings.position !== undefined) {\n      $.each(settings.position.split(' '), function () {\n        minicolors.addClass('minicolors-position-' + this);\n      });\n    } // Input size\n\n\n    if (settings.format === 'rgb') {\n      size = settings.opacity ? '25' : '20';\n    } else {\n      size = settings.keywords ? '11' : '7';\n    } // The input\n\n\n    input.addClass('minicolors-input').data('minicolors-initialized', false).data('minicolors-settings', settings).prop('size', size).wrap(minicolors).after('<div class=\"minicolors-panel minicolors-slider-' + settings.control + '\">' + '<div class=\"minicolors-slider minicolors-sprite\">' + '<div class=\"minicolors-picker\"></div>' + '</div>' + '<div class=\"minicolors-opacity-slider minicolors-sprite\">' + '<div class=\"minicolors-picker\"></div>' + '</div>' + '<div class=\"minicolors-grid minicolors-sprite\">' + '<div class=\"minicolors-grid-inner\"></div>' + '<div class=\"minicolors-picker\"><div></div></div>' + '</div>' + '</div>'); // The swatch\n\n    if (!settings.inline) {\n      input.after('<span class=\"minicolors-swatch minicolors-sprite minicolors-input-swatch\"><span class=\"minicolors-swatch-color\"></span></span>');\n      input.next('.minicolors-input-swatch').on('click', function (event) {\n        event.preventDefault();\n        input.focus();\n      });\n    } // Prevent text selection in IE\n\n\n    panel = input.parent().find('.minicolors-panel');\n    panel.on('selectstart', function () {\n      return false;\n    }).end(); // Swatches\n\n    if (settings.swatches && settings.swatches.length !== 0) {\n      panel.addClass('minicolors-with-swatches');\n      swatches = $('<ul class=\"minicolors-swatches\"></ul>').appendTo(panel);\n\n      for (i = 0; i < settings.swatches.length; ++i) {\n        // allow for custom objects as swatches\n        if ($.type(settings.swatches[i]) === 'object') {\n          name = settings.swatches[i].name;\n          swatch = settings.swatches[i].color;\n        } else {\n          name = '';\n          swatch = settings.swatches[i];\n        }\n\n        swatchString = swatch;\n        swatch = isRgb(swatch) ? parseRgb(swatch, true) : hex2rgb(parseHex(swatch, true));\n        $('<li class=\"minicolors-swatch minicolors-sprite\"><span class=\"minicolors-swatch-color\" title=\"' + name + '\"></span></li>').appendTo(swatches).data('swatch-color', swatchString).find('.minicolors-swatch-color').css({\n          backgroundColor: rgb2hex(swatch),\n          opacity: swatch.a\n        });\n        settings.swatches[i] = swatch;\n      }\n    } // Inline controls\n\n\n    if (settings.inline) input.parent().addClass('minicolors-inline');\n    updateFromInput(input, false);\n    input.data('minicolors-initialized', true);\n  } // Returns the input back to its original state\n\n\n  function destroy(input) {\n    var minicolors = input.parent(); // Revert the input element\n\n    input.removeData('minicolors-initialized').removeData('minicolors-settings').removeProp('size').removeClass('minicolors-input'); // Remove the wrap and destroy whatever remains\n\n    minicolors.before(input).remove();\n  } // Shows the specified dropdown panel\n\n\n  function show(input) {\n    var minicolors = input.parent();\n    var panel = minicolors.find('.minicolors-panel');\n    var settings = input.data('minicolors-settings'); // Do nothing if uninitialized, disabled, inline, or already open\n\n    if (!input.data('minicolors-initialized') || input.prop('disabled') || minicolors.hasClass('minicolors-inline') || minicolors.hasClass('minicolors-focus')) return;\n    hide();\n    minicolors.addClass('minicolors-focus');\n\n    if (panel.animate) {\n      panel.stop(true, true).fadeIn(settings.showSpeed, function () {\n        if (settings.show) settings.show.call(input.get(0));\n      });\n    } else {\n      panel.show();\n      if (settings.show) settings.show.call(input.get(0));\n    }\n  } // Hides all dropdown panels\n\n\n  function hide() {\n    $('.minicolors-focus').each(function () {\n      var minicolors = $(this);\n      var input = minicolors.find('.minicolors-input');\n      var panel = minicolors.find('.minicolors-panel');\n      var settings = input.data('minicolors-settings');\n\n      if (panel.animate) {\n        panel.fadeOut(settings.hideSpeed, function () {\n          if (settings.hide) settings.hide.call(input.get(0));\n          minicolors.removeClass('minicolors-focus');\n        });\n      } else {\n        panel.hide();\n        if (settings.hide) settings.hide.call(input.get(0));\n        minicolors.removeClass('minicolors-focus');\n      }\n    });\n  } // Moves the selected picker\n\n\n  function move(target, event, animate) {\n    var input = target.parents('.minicolors').find('.minicolors-input');\n    var settings = input.data('minicolors-settings');\n    var picker = target.find('[class$=-picker]');\n    var offsetX = target.offset().left;\n    var offsetY = target.offset().top;\n    var x = Math.round(event.pageX - offsetX);\n    var y = Math.round(event.pageY - offsetY);\n    var duration = animate ? settings.animationSpeed : 0;\n    var wx, wy, r, phi, styles; // Touch support\n\n    if (event.originalEvent.changedTouches) {\n      x = event.originalEvent.changedTouches[0].pageX - offsetX;\n      y = event.originalEvent.changedTouches[0].pageY - offsetY;\n    } // Constrain picker to its container\n\n\n    if (x < 0) x = 0;\n    if (y < 0) y = 0;\n    if (x > target.width()) x = target.width();\n    if (y > target.height()) y = target.height(); // Constrain color wheel values to the wheel\n\n    if (target.parent().is('.minicolors-slider-wheel') && picker.parent().is('.minicolors-grid')) {\n      wx = 75 - x;\n      wy = 75 - y;\n      r = Math.sqrt(wx * wx + wy * wy);\n      phi = Math.atan2(wy, wx);\n      if (phi < 0) phi += Math.PI * 2;\n\n      if (r > 75) {\n        r = 75;\n        x = 75 - 75 * Math.cos(phi);\n        y = 75 - 75 * Math.sin(phi);\n      }\n\n      x = Math.round(x);\n      y = Math.round(y);\n    } // Move the picker\n\n\n    styles = {\n      top: y + 'px'\n    };\n\n    if (target.is('.minicolors-grid')) {\n      styles.left = x + 'px';\n    }\n\n    if (picker.animate) {\n      picker.stop(true).animate(styles, duration, settings.animationEasing, function () {\n        updateFromControl(input, target);\n      });\n    } else {\n      picker.css(styles);\n      updateFromControl(input, target);\n    }\n  } // Sets the input based on the color picker values\n\n\n  function updateFromControl(input, target) {\n    function getCoords(picker, container) {\n      var left, top;\n      if (!picker.length || !container) return null;\n      left = picker.offset().left;\n      top = picker.offset().top;\n      return {\n        x: left - container.offset().left + picker.outerWidth() / 2,\n        y: top - container.offset().top + picker.outerHeight() / 2\n      };\n    }\n\n    var hue, saturation, brightness, x, y, r, phi;\n    var hex = input.val();\n    var opacity = input.attr('data-opacity'); // Helpful references\n\n    var minicolors = input.parent();\n    var settings = input.data('minicolors-settings');\n    var swatch = minicolors.find('.minicolors-input-swatch'); // Panel objects\n\n    var grid = minicolors.find('.minicolors-grid');\n    var slider = minicolors.find('.minicolors-slider');\n    var opacitySlider = minicolors.find('.minicolors-opacity-slider'); // Picker objects\n\n    var gridPicker = grid.find('[class$=-picker]');\n    var sliderPicker = slider.find('[class$=-picker]');\n    var opacityPicker = opacitySlider.find('[class$=-picker]'); // Picker positions\n\n    var gridPos = getCoords(gridPicker, grid);\n    var sliderPos = getCoords(sliderPicker, slider);\n    var opacityPos = getCoords(opacityPicker, opacitySlider); // Handle colors\n\n    if (target.is('.minicolors-grid, .minicolors-slider, .minicolors-opacity-slider')) {\n      // Determine HSB values\n      switch (settings.control) {\n        case 'wheel':\n          // Calculate hue, saturation, and brightness\n          x = grid.width() / 2 - gridPos.x;\n          y = grid.height() / 2 - gridPos.y;\n          r = Math.sqrt(x * x + y * y);\n          phi = Math.atan2(y, x);\n          if (phi < 0) phi += Math.PI * 2;\n\n          if (r > 75) {\n            r = 75;\n            gridPos.x = 69 - 75 * Math.cos(phi);\n            gridPos.y = 69 - 75 * Math.sin(phi);\n          }\n\n          saturation = keepWithin(r / 0.75, 0, 100);\n          hue = keepWithin(phi * 180 / Math.PI, 0, 360);\n          brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);\n          hex = hsb2hex({\n            h: hue,\n            s: saturation,\n            b: brightness\n          }); // Update UI\n\n          slider.css('backgroundColor', hsb2hex({\n            h: hue,\n            s: saturation,\n            b: 100\n          }));\n          break;\n\n        case 'saturation':\n          // Calculate hue, saturation, and brightness\n          hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);\n          saturation = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);\n          brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);\n          hex = hsb2hex({\n            h: hue,\n            s: saturation,\n            b: brightness\n          }); // Update UI\n\n          slider.css('backgroundColor', hsb2hex({\n            h: hue,\n            s: 100,\n            b: brightness\n          }));\n          minicolors.find('.minicolors-grid-inner').css('opacity', saturation / 100);\n          break;\n\n        case 'brightness':\n          // Calculate hue, saturation, and brightness\n          hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);\n          saturation = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);\n          brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);\n          hex = hsb2hex({\n            h: hue,\n            s: saturation,\n            b: brightness\n          }); // Update UI\n\n          slider.css('backgroundColor', hsb2hex({\n            h: hue,\n            s: saturation,\n            b: 100\n          }));\n          minicolors.find('.minicolors-grid-inner').css('opacity', 1 - brightness / 100);\n          break;\n\n        default:\n          // Calculate hue, saturation, and brightness\n          hue = keepWithin(360 - parseInt(sliderPos.y * (360 / slider.height()), 10), 0, 360);\n          saturation = keepWithin(Math.floor(gridPos.x * (100 / grid.width())), 0, 100);\n          brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);\n          hex = hsb2hex({\n            h: hue,\n            s: saturation,\n            b: brightness\n          }); // Update UI\n\n          grid.css('backgroundColor', hsb2hex({\n            h: hue,\n            s: 100,\n            b: 100\n          }));\n          break;\n      } // Handle opacity\n\n\n      if (settings.opacity) {\n        opacity = parseFloat(1 - opacityPos.y / opacitySlider.height()).toFixed(2);\n      } else {\n        opacity = 1;\n      }\n\n      updateInput(input, hex, opacity);\n    } else {\n      // Set swatch color\n      swatch.find('span').css({\n        backgroundColor: hex,\n        opacity: opacity\n      }); // Handle change event\n\n      doChange(input, hex, opacity);\n    }\n  } // Sets the value of the input and does the appropriate conversions\n  // to respect settings, also updates the swatch\n\n\n  function updateInput(input, value, opacity) {\n    var rgb; // Helpful references\n\n    var minicolors = input.parent();\n    var settings = input.data('minicolors-settings');\n    var swatch = minicolors.find('.minicolors-input-swatch');\n    if (settings.opacity) input.attr('data-opacity', opacity); // Set color string\n\n    if (settings.format === 'rgb') {\n      // Returns RGB(A) string\n      // Checks for input format and does the conversion\n      if (isRgb(value)) {\n        rgb = parseRgb(value, true);\n      } else {\n        rgb = hex2rgb(parseHex(value, true));\n      }\n\n      opacity = input.attr('data-opacity') === '' ? 1 : keepWithin(parseFloat(input.attr('data-opacity')).toFixed(2), 0, 1);\n      if (isNaN(opacity) || !settings.opacity) opacity = 1;\n\n      if (input.minicolors('rgbObject').a <= 1 && rgb && settings.opacity) {\n        // Set RGBA string if alpha\n        value = 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat(opacity) + ')';\n      } else {\n        // Set RGB string (alpha = 1)\n        value = 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';\n      }\n    } else {\n      // Returns hex color\n      // Checks for input format and does the conversion\n      if (isRgb(value)) {\n        value = rgbString2hex(value);\n      }\n\n      value = convertCase(value, settings.letterCase);\n    } // Update value from picker\n\n\n    input.val(value); // Set swatch color\n\n    swatch.find('span').css({\n      backgroundColor: value,\n      opacity: opacity\n    }); // Handle change event\n\n    doChange(input, value, opacity);\n  } // Sets the color picker values from the input\n\n\n  function updateFromInput(input, preserveInputValue) {\n    var hex, hsb, opacity, keywords, alpha, value, x, y, r, phi; // Helpful references\n\n    var minicolors = input.parent();\n    var settings = input.data('minicolors-settings');\n    var swatch = minicolors.find('.minicolors-input-swatch'); // Panel objects\n\n    var grid = minicolors.find('.minicolors-grid');\n    var slider = minicolors.find('.minicolors-slider');\n    var opacitySlider = minicolors.find('.minicolors-opacity-slider'); // Picker objects\n\n    var gridPicker = grid.find('[class$=-picker]');\n    var sliderPicker = slider.find('[class$=-picker]');\n    var opacityPicker = opacitySlider.find('[class$=-picker]'); // Determine hex/HSB values\n\n    if (isRgb(input.val())) {\n      // If input value is a rgb(a) string, convert it to hex color and update opacity\n      hex = rgbString2hex(input.val());\n      alpha = keepWithin(parseFloat(getAlpha(input.val())).toFixed(2), 0, 1);\n\n      if (alpha) {\n        input.attr('data-opacity', alpha);\n      }\n    } else {\n      hex = convertCase(parseHex(input.val(), true), settings.letterCase);\n    }\n\n    if (!hex) {\n      hex = convertCase(parseInput(settings.defaultValue, true), settings.letterCase);\n    }\n\n    hsb = hex2hsb(hex); // Get array of lowercase keywords\n\n    keywords = !settings.keywords ? [] : $.map(settings.keywords.split(','), function (a) {\n      return $.trim(a.toLowerCase());\n    }); // Set color string\n\n    if (input.val() !== '' && $.inArray(input.val().toLowerCase(), keywords) > -1) {\n      value = convertCase(input.val());\n    } else {\n      value = isRgb(input.val()) ? parseRgb(input.val()) : hex;\n    } // Update input value\n\n\n    if (!preserveInputValue) input.val(value); // Determine opacity value\n\n    if (settings.opacity) {\n      // Get from data-opacity attribute and keep within 0-1 range\n      opacity = input.attr('data-opacity') === '' ? 1 : keepWithin(parseFloat(input.attr('data-opacity')).toFixed(2), 0, 1);\n      if (isNaN(opacity)) opacity = 1;\n      input.attr('data-opacity', opacity);\n      swatch.find('span').css('opacity', opacity); // Set opacity picker position\n\n      y = keepWithin(opacitySlider.height() - opacitySlider.height() * opacity, 0, opacitySlider.height());\n      opacityPicker.css('top', y + 'px');\n    } // Set opacity to zero if input value is transparent\n\n\n    if (input.val().toLowerCase() === 'transparent') {\n      swatch.find('span').css('opacity', 0);\n    } // Update swatch\n\n\n    swatch.find('span').css('backgroundColor', hex); // Determine picker locations\n\n    switch (settings.control) {\n      case 'wheel':\n        // Set grid position\n        r = keepWithin(Math.ceil(hsb.s * 0.75), 0, grid.height() / 2);\n        phi = hsb.h * Math.PI / 180;\n        x = keepWithin(75 - Math.cos(phi) * r, 0, grid.width());\n        y = keepWithin(75 - Math.sin(phi) * r, 0, grid.height());\n        gridPicker.css({\n          top: y + 'px',\n          left: x + 'px'\n        }); // Set slider position\n\n        y = 150 - hsb.b / (100 / grid.height());\n        if (hex === '') y = 0;\n        sliderPicker.css('top', y + 'px'); // Update panel color\n\n        slider.css('backgroundColor', hsb2hex({\n          h: hsb.h,\n          s: hsb.s,\n          b: 100\n        }));\n        break;\n\n      case 'saturation':\n        // Set grid position\n        x = keepWithin(5 * hsb.h / 12, 0, 150);\n        y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());\n        gridPicker.css({\n          top: y + 'px',\n          left: x + 'px'\n        }); // Set slider position\n\n        y = keepWithin(slider.height() - hsb.s * (slider.height() / 100), 0, slider.height());\n        sliderPicker.css('top', y + 'px'); // Update UI\n\n        slider.css('backgroundColor', hsb2hex({\n          h: hsb.h,\n          s: 100,\n          b: hsb.b\n        }));\n        minicolors.find('.minicolors-grid-inner').css('opacity', hsb.s / 100);\n        break;\n\n      case 'brightness':\n        // Set grid position\n        x = keepWithin(5 * hsb.h / 12, 0, 150);\n        y = keepWithin(grid.height() - Math.ceil(hsb.s / (100 / grid.height())), 0, grid.height());\n        gridPicker.css({\n          top: y + 'px',\n          left: x + 'px'\n        }); // Set slider position\n\n        y = keepWithin(slider.height() - hsb.b * (slider.height() / 100), 0, slider.height());\n        sliderPicker.css('top', y + 'px'); // Update UI\n\n        slider.css('backgroundColor', hsb2hex({\n          h: hsb.h,\n          s: hsb.s,\n          b: 100\n        }));\n        minicolors.find('.minicolors-grid-inner').css('opacity', 1 - hsb.b / 100);\n        break;\n\n      default:\n        // Set grid position\n        x = keepWithin(Math.ceil(hsb.s / (100 / grid.width())), 0, grid.width());\n        y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());\n        gridPicker.css({\n          top: y + 'px',\n          left: x + 'px'\n        }); // Set slider position\n\n        y = keepWithin(slider.height() - hsb.h / (360 / slider.height()), 0, slider.height());\n        sliderPicker.css('top', y + 'px'); // Update panel color\n\n        grid.css('backgroundColor', hsb2hex({\n          h: hsb.h,\n          s: 100,\n          b: 100\n        }));\n        break;\n    } // Fire change event, but only if minicolors is fully initialized\n\n\n    if (input.data('minicolors-initialized')) {\n      doChange(input, value, opacity);\n    }\n  } // Runs the change and changeDelay callbacks\n\n\n  function doChange(input, value, opacity) {\n    var settings = input.data('minicolors-settings');\n    var lastChange = input.data('minicolors-lastChange');\n    var obj, sel, i; // Only run if it actually changed\n\n    if (!lastChange || lastChange.value !== value || lastChange.opacity !== opacity) {\n      // Remember last-changed value\n      input.data('minicolors-lastChange', {\n        value: value,\n        opacity: opacity\n      }); // Check and select applicable swatch\n\n      if (settings.swatches && settings.swatches.length !== 0) {\n        if (!isRgb(value)) {\n          obj = hex2rgb(value);\n        } else {\n          obj = parseRgb(value, true);\n        }\n\n        sel = -1;\n\n        for (i = 0; i < settings.swatches.length; ++i) {\n          if (obj.r === settings.swatches[i].r && obj.g === settings.swatches[i].g && obj.b === settings.swatches[i].b && obj.a === settings.swatches[i].a) {\n            sel = i;\n            break;\n          }\n        }\n\n        input.parent().find('.minicolors-swatches .minicolors-swatch').removeClass('selected');\n\n        if (sel !== -1) {\n          input.parent().find('.minicolors-swatches .minicolors-swatch').eq(i).addClass('selected');\n        }\n      } // Fire change event\n\n\n      if (settings.change) {\n        if (settings.changeDelay) {\n          // Call after a delay\n          clearTimeout(input.data('minicolors-changeTimeout'));\n          input.data('minicolors-changeTimeout', setTimeout(function () {\n            settings.change.call(input.get(0), value, opacity);\n          }, settings.changeDelay));\n        } else {\n          // Call immediately\n          settings.change.call(input.get(0), value, opacity);\n        }\n      }\n\n      input.trigger('change').trigger('input');\n    }\n  } // Generates an RGB(A) object based on the input's value\n\n\n  function rgbObject(input) {\n    var rgb,\n        opacity = $(input).attr('data-opacity');\n\n    if (isRgb($(input).val())) {\n      rgb = parseRgb($(input).val(), true);\n    } else {\n      var hex = parseHex($(input).val(), true);\n      rgb = hex2rgb(hex);\n    }\n\n    if (!rgb) return null;\n    if (opacity !== undefined) $.extend(rgb, {\n      a: parseFloat(opacity)\n    });\n    return rgb;\n  } // Generates an RGB(A) string based on the input's value\n\n\n  function rgbString(input, alpha) {\n    var rgb,\n        opacity = $(input).attr('data-opacity');\n\n    if (isRgb($(input).val())) {\n      rgb = parseRgb($(input).val(), true);\n    } else {\n      var hex = parseHex($(input).val(), true);\n      rgb = hex2rgb(hex);\n    }\n\n    if (!rgb) return null;\n    if (opacity === undefined) opacity = 1;\n\n    if (alpha) {\n      return 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat(opacity) + ')';\n    } else {\n      return 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';\n    }\n  } // Converts to the letter case specified in settings\n\n\n  function convertCase(string, letterCase) {\n    return letterCase === 'uppercase' ? string.toUpperCase() : string.toLowerCase();\n  } // Parses a string and returns a valid hex string when possible\n\n\n  function parseHex(string, expand) {\n    string = string.replace(/^#/g, '');\n    if (!string.match(/^[A-F0-9]{3,6}/ig)) return '';\n    if (string.length !== 3 && string.length !== 6) return '';\n\n    if (string.length === 3 && expand) {\n      string = string[0] + string[0] + string[1] + string[1] + string[2] + string[2];\n    }\n\n    return '#' + string;\n  } // Parses a string and returns a valid RGB(A) string when possible\n\n\n  function parseRgb(string, obj) {\n    var values = string.replace(/[^\\d,.]/g, '');\n    var rgba = values.split(',');\n    rgba[0] = keepWithin(parseInt(rgba[0], 10), 0, 255);\n    rgba[1] = keepWithin(parseInt(rgba[1], 10), 0, 255);\n    rgba[2] = keepWithin(parseInt(rgba[2], 10), 0, 255);\n\n    if (rgba[3] !== undefined) {\n      rgba[3] = keepWithin(parseFloat(rgba[3], 10), 0, 1);\n    } // Return RGBA object\n\n\n    if (obj) {\n      if (rgba[3] !== undefined) {\n        return {\n          r: rgba[0],\n          g: rgba[1],\n          b: rgba[2],\n          a: rgba[3]\n        };\n      } else {\n        return {\n          r: rgba[0],\n          g: rgba[1],\n          b: rgba[2]\n        };\n      }\n    } // Return RGBA string\n\n\n    if (typeof rgba[3] !== 'undefined' && rgba[3] <= 1) {\n      return 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + rgba[3] + ')';\n    } else {\n      return 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')';\n    }\n  } // Parses a string and returns a valid color string when possible\n\n\n  function parseInput(string, expand) {\n    if (isRgb(string)) {\n      // Returns a valid rgb(a) string\n      return parseRgb(string);\n    } else {\n      return parseHex(string, expand);\n    }\n  } // Keeps value within min and max\n\n\n  function keepWithin(value, min, max) {\n    if (value < min) value = min;\n    if (value > max) value = max;\n    return value;\n  } // Checks if a string is a valid RGB(A) string\n\n\n  function isRgb(string) {\n    var rgb = string.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return rgb && rgb.length === 4 ? true : false;\n  } // Function to get alpha from a RGB(A) string\n\n\n  function getAlpha(rgba) {\n    rgba = rgba.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+(\\.\\d{1,2})?|\\.\\d{1,2})[\\s+]?/i);\n    return rgba && rgba.length === 6 ? rgba[4] : '1';\n  } // Converts an HSB object to an RGB object\n\n\n  function hsb2rgb(hsb) {\n    var rgb = {};\n    var h = Math.round(hsb.h);\n    var s = Math.round(hsb.s * 255 / 100);\n    var v = Math.round(hsb.b * 255 / 100);\n\n    if (s === 0) {\n      rgb.r = rgb.g = rgb.b = v;\n    } else {\n      var t1 = v;\n      var t2 = (255 - s) * v / 255;\n      var t3 = (t1 - t2) * (h % 60) / 60;\n      if (h === 360) h = 0;\n\n      if (h < 60) {\n        rgb.r = t1;\n        rgb.b = t2;\n        rgb.g = t2 + t3;\n      } else if (h < 120) {\n        rgb.g = t1;\n        rgb.b = t2;\n        rgb.r = t1 - t3;\n      } else if (h < 180) {\n        rgb.g = t1;\n        rgb.r = t2;\n        rgb.b = t2 + t3;\n      } else if (h < 240) {\n        rgb.b = t1;\n        rgb.r = t2;\n        rgb.g = t1 - t3;\n      } else if (h < 300) {\n        rgb.b = t1;\n        rgb.g = t2;\n        rgb.r = t2 + t3;\n      } else if (h < 360) {\n        rgb.r = t1;\n        rgb.g = t2;\n        rgb.b = t1 - t3;\n      } else {\n        rgb.r = 0;\n        rgb.g = 0;\n        rgb.b = 0;\n      }\n    }\n\n    return {\n      r: Math.round(rgb.r),\n      g: Math.round(rgb.g),\n      b: Math.round(rgb.b)\n    };\n  } // Converts an RGB string to a hex string\n\n\n  function rgbString2hex(rgb) {\n    rgb = rgb.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n  } // Converts an RGB object to a hex string\n\n\n  function rgb2hex(rgb) {\n    var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];\n    $.each(hex, function (nr, val) {\n      if (val.length === 1) hex[nr] = '0' + val;\n    });\n    return '#' + hex.join('');\n  } // Converts an HSB object to a hex string\n\n\n  function hsb2hex(hsb) {\n    return rgb2hex(hsb2rgb(hsb));\n  } // Converts a hex string to an HSB object\n\n\n  function hex2hsb(hex) {\n    var hsb = rgb2hsb(hex2rgb(hex));\n    if (hsb.s === 0) hsb.h = 360;\n    return hsb;\n  } // Converts an RGB object to an HSB object\n\n\n  function rgb2hsb(rgb) {\n    var hsb = {\n      h: 0,\n      s: 0,\n      b: 0\n    };\n    var min = Math.min(rgb.r, rgb.g, rgb.b);\n    var max = Math.max(rgb.r, rgb.g, rgb.b);\n    var delta = max - min;\n    hsb.b = max;\n    hsb.s = max !== 0 ? 255 * delta / max : 0;\n\n    if (hsb.s !== 0) {\n      if (rgb.r === max) {\n        hsb.h = (rgb.g - rgb.b) / delta;\n      } else if (rgb.g === max) {\n        hsb.h = 2 + (rgb.b - rgb.r) / delta;\n      } else {\n        hsb.h = 4 + (rgb.r - rgb.g) / delta;\n      }\n    } else {\n      hsb.h = -1;\n    }\n\n    hsb.h *= 60;\n\n    if (hsb.h < 0) {\n      hsb.h += 360;\n    }\n\n    hsb.s *= 100 / 255;\n    hsb.b *= 100 / 255;\n    return hsb;\n  } // Converts a hex string to an RGB object\n\n\n  function hex2rgb(hex) {\n    hex = parseInt(hex.indexOf('#') > -1 ? hex.substring(1) : hex, 16);\n    return {\n      r: hex >> 16,\n      g: (hex & 0x00FF00) >> 8,\n      b: hex & 0x0000FF\n    };\n  } // Handle events\n\n\n  $([document]) // Hide on clicks outside of the control\n  .on('mousedown.minicolors touchstart.minicolors', function (event) {\n    if (!$(event.target).parents().add(event.target).hasClass('minicolors')) {\n      hide();\n    }\n  }) // Start moving\n  .on('mousedown.minicolors touchstart.minicolors', '.minicolors-grid, .minicolors-slider, .minicolors-opacity-slider', function (event) {\n    var target = $(this);\n    event.preventDefault();\n    $(event.delegateTarget).data('minicolors-target', target);\n    move(target, event, true);\n  }) // Move pickers\n  .on('mousemove.minicolors touchmove.minicolors', function (event) {\n    var target = $(event.delegateTarget).data('minicolors-target');\n    if (target) move(target, event);\n  }) // Stop moving\n  .on('mouseup.minicolors touchend.minicolors', function () {\n    $(this).removeData('minicolors-target');\n  }) // Selected a swatch\n  .on('click.minicolors', '.minicolors-swatches li', function (event) {\n    event.preventDefault();\n    var target = $(this),\n        input = target.parents('.minicolors').find('.minicolors-input'),\n        color = target.data('swatch-color');\n    updateInput(input, color, getAlpha(color));\n    updateFromInput(input);\n  }) // Show panel when swatch is clicked\n  .on('mousedown.minicolors touchstart.minicolors', '.minicolors-input-swatch', function (event) {\n    var input = $(this).parent().find('.minicolors-input');\n    event.preventDefault();\n    show(input);\n  }) // Show on focus\n  .on('focus.minicolors', '.minicolors-input', function () {\n    var input = $(this);\n    if (!input.data('minicolors-initialized')) return;\n    show(input);\n  }) // Update value on blur\n  .on('blur.minicolors', '.minicolors-input', function () {\n    var input = $(this);\n    var settings = input.data('minicolors-settings');\n    var keywords;\n    var hex;\n    var rgba;\n    var swatchOpacity;\n    var value;\n    if (!input.data('minicolors-initialized')) return; // Get array of lowercase keywords\n\n    keywords = !settings.keywords ? [] : $.map(settings.keywords.split(','), function (a) {\n      return $.trim(a.toLowerCase());\n    }); // Set color string\n\n    if (input.val() !== '' && $.inArray(input.val().toLowerCase(), keywords) > -1) {\n      value = input.val();\n    } else {\n      // Get RGBA values for easy conversion\n      if (isRgb(input.val())) {\n        rgba = parseRgb(input.val(), true);\n      } else {\n        hex = parseHex(input.val(), true);\n        rgba = hex ? hex2rgb(hex) : null;\n      } // Convert to format\n\n\n      if (rgba === null) {\n        value = settings.defaultValue;\n      } else if (settings.format === 'rgb') {\n        value = settings.opacity ? parseRgb('rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + input.attr('data-opacity') + ')') : parseRgb('rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')');\n      } else {\n        value = rgb2hex(rgba);\n      }\n    } // Update swatch opacity\n\n\n    swatchOpacity = settings.opacity ? input.attr('data-opacity') : 1;\n    if (value.toLowerCase() === 'transparent') swatchOpacity = 0;\n    input.closest('.minicolors').find('.minicolors-input-swatch > span').css('opacity', swatchOpacity); // Set input value\n\n    input.val(value); // Is it blank?\n\n    if (input.val() === '') input.val(parseInput(settings.defaultValue, true)); // Adjust case\n\n    input.val(convertCase(input.val(), settings.letterCase));\n  }) // Handle keypresses\n  .on('keydown.minicolors', '.minicolors-input', function (event) {\n    var input = $(this);\n    if (!input.data('minicolors-initialized')) return;\n\n    switch (event.which) {\n      case 9:\n        // tab\n        hide();\n        break;\n\n      case 13: // enter\n\n      case 27:\n        // esc\n        hide();\n        input.blur();\n        break;\n    }\n  }) // Update on keyup\n  .on('keyup.minicolors', '.minicolors-input', function () {\n    var input = $(this);\n    if (!input.data('minicolors-initialized')) return;\n    updateFromInput(input, true);\n  }) // Update on paste\n  .on('paste.minicolors', '.minicolors-input', function () {\n    var input = $(this);\n    if (!input.data('minicolors-initialized')) return;\n    setTimeout(function () {\n      updateFromInput(input, true);\n    }, 1);\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL21pbmljb2xvcnMuanM/NDlhOCJdLCJuYW1lcyI6WyJmYWN0b3J5IiwiZGVmaW5lIiwiJCIsIm1pbmljb2xvcnMiLCJkZWZhdWx0cyIsImFuaW1hdGlvblNwZWVkIiwiYW5pbWF0aW9uRWFzaW5nIiwiY2hhbmdlIiwiY2hhbmdlRGVsYXkiLCJjb250cm9sIiwiZGVmYXVsdFZhbHVlIiwiZm9ybWF0IiwiaGlkZSIsImhpZGVTcGVlZCIsImlubGluZSIsImtleXdvcmRzIiwibGV0dGVyQ2FzZSIsIm9wYWNpdHkiLCJwb3NpdGlvbiIsInNob3ciLCJzaG93U3BlZWQiLCJ0aGVtZSIsInN3YXRjaGVzIiwiZXh0ZW5kIiwiZm4iLCJtZXRob2QiLCJkYXRhIiwiZWFjaCIsImRlc3Ryb3kiLCJ1bmRlZmluZWQiLCJhdHRyIiwidXBkYXRlRnJvbUlucHV0IiwicmdiT2JqZWN0IiwicmdiU3RyaW5nIiwic2V0dGluZ3MiLCJlcSIsInZhbCIsImtlZXBXaXRoaW4iLCJjb2xvciIsImluaXQiLCJpbnB1dCIsIm5hbWUiLCJzaXplIiwic3dhdGNoIiwic3dhdGNoU3RyaW5nIiwicGFuZWwiLCJpIiwiYWRkQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInNwbGl0IiwicHJvcCIsIndyYXAiLCJhZnRlciIsIm5leHQiLCJvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJmb2N1cyIsInBhcmVudCIsImZpbmQiLCJlbmQiLCJsZW5ndGgiLCJhcHBlbmRUbyIsInR5cGUiLCJpc1JnYiIsInBhcnNlUmdiIiwiaGV4MnJnYiIsInBhcnNlSGV4IiwiY3NzIiwiYmFja2dyb3VuZENvbG9yIiwicmdiMmhleCIsImEiLCJyZW1vdmVEYXRhIiwicmVtb3ZlUHJvcCIsInJlbW92ZUNsYXNzIiwiYmVmb3JlIiwicmVtb3ZlIiwiaGFzQ2xhc3MiLCJhbmltYXRlIiwic3RvcCIsImZhZGVJbiIsImNhbGwiLCJnZXQiLCJmYWRlT3V0IiwibW92ZSIsInRhcmdldCIsInBhcmVudHMiLCJwaWNrZXIiLCJvZmZzZXRYIiwib2Zmc2V0IiwibGVmdCIsIm9mZnNldFkiLCJ0b3AiLCJ4IiwiTWF0aCIsInJvdW5kIiwicGFnZVgiLCJ5IiwicGFnZVkiLCJkdXJhdGlvbiIsInd4Iiwid3kiLCJyIiwicGhpIiwic3R5bGVzIiwib3JpZ2luYWxFdmVudCIsImNoYW5nZWRUb3VjaGVzIiwid2lkdGgiLCJoZWlnaHQiLCJpcyIsInNxcnQiLCJhdGFuMiIsIlBJIiwiY29zIiwic2luIiwidXBkYXRlRnJvbUNvbnRyb2wiLCJnZXRDb29yZHMiLCJjb250YWluZXIiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJodWUiLCJzYXR1cmF0aW9uIiwiYnJpZ2h0bmVzcyIsImhleCIsImdyaWQiLCJzbGlkZXIiLCJvcGFjaXR5U2xpZGVyIiwiZ3JpZFBpY2tlciIsInNsaWRlclBpY2tlciIsIm9wYWNpdHlQaWNrZXIiLCJncmlkUG9zIiwic2xpZGVyUG9zIiwib3BhY2l0eVBvcyIsImZsb29yIiwiaHNiMmhleCIsImgiLCJzIiwiYiIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJ1cGRhdGVJbnB1dCIsImRvQ2hhbmdlIiwidmFsdWUiLCJyZ2IiLCJpc05hTiIsImciLCJyZ2JTdHJpbmcyaGV4IiwiY29udmVydENhc2UiLCJwcmVzZXJ2ZUlucHV0VmFsdWUiLCJoc2IiLCJhbHBoYSIsImdldEFscGhhIiwicGFyc2VJbnB1dCIsImhleDJoc2IiLCJtYXAiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJpbkFycmF5IiwiY2VpbCIsImxhc3RDaGFuZ2UiLCJvYmoiLCJzZWwiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidHJpZ2dlciIsInN0cmluZyIsInRvVXBwZXJDYXNlIiwiZXhwYW5kIiwicmVwbGFjZSIsIm1hdGNoIiwidmFsdWVzIiwicmdiYSIsIm1pbiIsIm1heCIsImhzYjJyZ2IiLCJ2IiwidDEiLCJ0MiIsInQzIiwidG9TdHJpbmciLCJzbGljZSIsIm5yIiwiam9pbiIsInJnYjJoc2IiLCJkZWx0YSIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJkb2N1bWVudCIsImFkZCIsImRlbGVnYXRlVGFyZ2V0Iiwic3dhdGNoT3BhY2l0eSIsImNsb3Nlc3QiLCJ3aGljaCIsImJsdXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0MsV0FBVUEsT0FBVixFQUFtQjtBQUNsQixNQUFHLElBQUgsRUFBK0M7QUFDN0M7QUFDQUMscUNBQU8sQ0FBQyx5RUFBRCxDQUFELG9DQUFhRCxPQUFiO0FBQUE7QUFBQTtBQUFBLG9HQUFOO0FBQ0QsR0FIRCxNQUdPLEVBTU47QUFDRixDQVhBLEVBV0MsVUFBVUUsQ0FBVixFQUFhO0FBQ2IsZUFEYSxDQUdiOztBQUNBQSxHQUFDLENBQUNDLFVBQUYsR0FBZTtBQUNiQyxZQUFRLEVBQUU7QUFDUkMsb0JBQWMsRUFBRSxFQURSO0FBRVJDLHFCQUFlLEVBQUUsT0FGVDtBQUdSQyxZQUFNLEVBQUUsSUFIQTtBQUlSQyxpQkFBVyxFQUFFLENBSkw7QUFLUkMsYUFBTyxFQUFFLEtBTEQ7QUFNUkMsa0JBQVksRUFBRSxFQU5OO0FBT1JDLFlBQU0sRUFBRSxLQVBBO0FBUVJDLFVBQUksRUFBRSxJQVJFO0FBU1JDLGVBQVMsRUFBRSxHQVRIO0FBVVJDLFlBQU0sRUFBRSxLQVZBO0FBV1JDLGNBQVEsRUFBRSxFQVhGO0FBWVJDLGdCQUFVLEVBQUUsV0FaSjtBQWFSQyxhQUFPLEVBQUUsS0FiRDtBQWNSQyxjQUFRLEVBQUUsUUFkRjtBQWVSQyxVQUFJLEVBQUUsSUFmRTtBQWdCUkMsZUFBUyxFQUFFLEdBaEJIO0FBaUJSQyxXQUFLLEVBQUUsU0FqQkM7QUFrQlJDLGNBQVEsRUFBRTtBQWxCRjtBQURHLEdBQWYsQ0FKYSxDQTJCYjs7QUFDQXBCLEdBQUMsQ0FBQ3FCLE1BQUYsQ0FBU3JCLENBQUMsQ0FBQ3NCLEVBQVgsRUFBZTtBQUNickIsY0FBVSxFQUFFLFVBQVNzQixNQUFULEVB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QWUsQ0FBQ1MsS0FBRCxFQUFRLElBQVIsQ0FBZjtBQUNELEtBRlMsRUFFUCxDQUZPLENBQVY7QUFHRCxHQWpJSDtBQWtJRCxDQS9sQ0EsQ0FBRCIsImZpbGUiOiIuL3NyYy9yZXNvdXJjZXMvd3JpdGUvbWluaWNvbG9ycy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBqUXVlcnkgTWluaUNvbG9yczogQSB0aW55IGNvbG9yIHBpY2tlciBidWlsdCBvbiBqUXVlcnlcbi8vXG4vLyBEZXZlbG9wZWQgYnkgQ29yeSBMYVZpc2thIGZvciBBIEJlYXV0aWZ1bCBTaXRlLCBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6IGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbi8vXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgfVxufShmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRGVmYXVsdHNcbiAgJC5taW5pY29sb3JzID0ge1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBhbmltYXRpb25TcGVlZDogNTAsXG4gICAgICBhbmltYXRpb25FYXNpbmc6ICdzd2luZycsXG4gICAgICBjaGFuZ2U6IG51bGwsXG4gICAgICBjaGFuZ2VEZWxheTogMCxcbiAgICAgIGNvbnRyb2w6ICdodWUnLFxuICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgICAgIGZvcm1hdDogJ2hleCcsXG4gICAgICBoaWRlOiBudWxsLFxuICAgICAgaGlkZVNwZWVkOiAxMDAsXG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAga2V5d29yZHM6ICcnLFxuICAgICAgbGV0dGVyQ2FzZTogJ2xvd2VyY2FzZScsXG4gICAgICBvcGFjaXR5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgIHNob3c6IG51bGwsXG4gICAgICBzaG93U3BlZWQ6IDEwMCxcbiAgICAgIHRoZW1lOiAnZGVmYXVsdCcsXG4gICAgICBzd2F0Y2hlczogW11cbiAgICB9XG4gIH07XG5cbiAgLy8gUHVibGljIG1ldGhvZHNcbiAgJC5leHRlbmQoJC5mbiwge1xuICAgIG1pbmljb2xvcnM6IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSkge1xuXG4gICAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICAvLyBEZXN0cm95IHRoZSBjb250cm9sXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlc3Ryb3koJCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJCh0aGlzKTtcblxuICAgICAgLy8gSGlkZSB0aGUgY29sb3IgcGlja2VyXG4gICAgICBjYXNlICdoaWRlJzpcbiAgICAgICAgaGlkZSgpO1xuICAgICAgICByZXR1cm4gJCh0aGlzKTtcblxuICAgICAgLy8gR2V0L3NldCBvcGFjaXR5XG4gICAgICBjYXNlICdvcGFjaXR5JzpcbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEdldHRlclxuICAgICAgICAgIHJldHVybiAkKHRoaXMpLmF0dHIoJ2RhdGEtb3BhY2l0eScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNldHRlclxuICAgICAgICAgICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZyb21JbnB1dCgkKHRoaXMpLmF0dHIoJ2RhdGEtb3BhY2l0eScsIGRhdGEpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCh0aGlzKTtcblxuICAgICAgLy8gR2V0IGFuIFJHQihBKSBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29sb3Ivb3BhY2l0eVxuICAgICAgY2FzZSAncmdiT2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIHJnYk9iamVjdCgkKHRoaXMpLCBtZXRob2QgPT09ICdyZ2JhT2JqZWN0Jyk7XG5cbiAgICAgIC8vIEdldCBhbiBSR0IoQSkgc3RyaW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvbG9yL29wYWNpdHlcbiAgICAgIGNhc2UgJ3JnYlN0cmluZyc6XG4gICAgICBjYXNlICdyZ2JhU3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHJnYlN0cmluZygkKHRoaXMpLCBtZXRob2QgPT09ICdyZ2JhU3RyaW5nJyk7XG5cbiAgICAgIC8vIEdldC9zZXQgc2V0dGluZ3Mgb24gdGhlIGZseVxuICAgICAgY2FzZSAnc2V0dGluZ3MnOlxuICAgICAgICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gJCh0aGlzKS5kYXRhKCdtaW5pY29sb3JzLXNldHRpbmdzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgICAgJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJCh0aGlzKS5kYXRhKCdtaW5pY29sb3JzLXNldHRpbmdzJykgfHwge307XG4gICAgICAgICAgICBkZXN0cm95KCQodGhpcykpO1xuICAgICAgICAgICAgJCh0aGlzKS5taW5pY29sb3JzKCQuZXh0ZW5kKHRydWUsIHNldHRpbmdzLCBkYXRhKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQodGhpcyk7XG5cbiAgICAgIC8vIFNob3cgdGhlIGNvbG9yIHBpY2tlclxuICAgICAgY2FzZSAnc2hvdyc6XG4gICAgICAgIHNob3coJCh0aGlzKS5lcSgwKSk7XG4gICAgICAgIHJldHVybiAkKHRoaXMpO1xuXG4gICAgICAvLyBHZXQvc2V0IHRoZSBoZXggY29sb3IgdmFsdWVcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgICAgcmV0dXJuICQodGhpcykudmFsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgICAgJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodHlwZW9mKGRhdGEpID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdkYXRhLW9wYWNpdHknLCBrZWVwV2l0aGluKGRhdGEub3BhY2l0eSwgMCwgMSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGRhdGEuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnZhbChkYXRhLmNvbG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJCh0aGlzKS52YWwoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVGcm9tSW5wdXQoJCh0aGlzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQodGhpcyk7XG5cbiAgICAgIC8vIEluaXRpYWxpemVzIHRoZSBjb250cm9sXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZihtZXRob2QgIT09ICdjcmVhdGUnKSBkYXRhID0gbWV0aG9kO1xuICAgICAgICAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaW5pdCgkKHRoaXMpLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkKHRoaXMpO1xuXG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEluaXRpYWxpemUgaW5wdXQgZWxlbWVudHNcbiAgZnVuY3Rpb24gaW5pdChpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgbWluaWNvbG9ycyA9ICQoJzxkaXYgY2xhc3M9XCJtaW5pY29sb3JzXCIgLz4nKTtcbiAgICB2YXIgZGVmYXVsdHMgPSAkLm1pbmljb2xvcnMuZGVmYXVsdHM7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHNpemU7XG4gICAgdmFyIHN3YXRjaGVzO1xuICAgIHZhciBzd2F0Y2g7XG4gICAgdmFyIHN3YXRjaFN0cmluZztcbiAgICB2YXIgcGFuZWw7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBEbyBub3RoaW5nIGlmIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICBpZihpbnB1dC5kYXRhKCdtaW5pY29sb3JzLWluaXRpYWxpemVkJykpIHJldHVybjtcblxuICAgIC8vIEhhbmRsZSBzZXR0aW5nc1xuICAgIHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBzZXR0aW5ncyk7XG5cbiAgICAvLyBUaGUgd3JhcHBlclxuICAgIG1pbmljb2xvcnNcbiAgICAgIC5hZGRDbGFzcygnbWluaWNvbG9ycy10aGVtZS0nICsgc2V0dGluZ3MudGhlbWUpXG4gICAgICAudG9nZ2xlQ2xhc3MoJ21pbmljb2xvcnMtd2l0aC1vcGFjaXR5Jywgc2V0dGluZ3Mub3BhY2l0eSk7XG5cbiAgICAvLyBDdXN0b20gcG9zaXRpb25pbmdcbiAgICBpZihzZXR0aW5ncy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAkLmVhY2goc2V0dGluZ3MucG9zaXRpb24uc3BsaXQoJyAnKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pbmljb2xvcnMuYWRkQ2xhc3MoJ21pbmljb2xvcnMtcG9zaXRpb24tJyArIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSW5wdXQgc2l6ZVxuICAgIGlmKHNldHRpbmdzLmZvcm1hdCA9PT0gJ3JnYicpIHtcbiAgICAgIHNpemUgPSBzZXR0aW5ncy5vcGFjaXR5ID8gJzI1JyA6ICcyMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBzZXR0aW5ncy5rZXl3b3JkcyA/ICcxMScgOiAnNyc7XG4gICAgfVxuXG4gICAgLy8gVGhlIGlucHV0XG4gICAgaW5wdXRcbiAgICAgIC5hZGRDbGFzcygnbWluaWNvbG9ycy1pbnB1dCcpXG4gICAgICAuZGF0YSgnbWluaWNvbG9ycy1pbml0aWFsaXplZCcsIGZhbHNlKVxuICAgICAgLmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnLCBzZXR0aW5ncylcbiAgICAgIC5wcm9wKCdzaXplJywgc2l6ZSlcbiAgICAgIC53cmFwKG1pbmljb2xvcnMpXG4gICAgICAuYWZ0ZXIoXG4gICAgICAgICc8ZGl2IGNsYXNzPVwibWluaWNvbG9ycy1wYW5lbCBtaW5pY29sb3JzLXNsaWRlci0nICsgc2V0dGluZ3MuY29udHJvbCArICdcIj4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwibWluaWNvbG9ycy1zbGlkZXIgbWluaWNvbG9ycy1zcHJpdGVcIj4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwibWluaWNvbG9ycy1waWNrZXJcIj48L2Rpdj4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwibWluaWNvbG9ycy1vcGFjaXR5LXNsaWRlciBtaW5pY29sb3JzLXNwcml0ZVwiPicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJtaW5pY29sb3JzLXBpY2tlclwiPjwvZGl2PicgK1xuICAgICAgJzwvZGl2PicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJtaW5pY29sb3JzLWdyaWQgbWluaWNvbG9ycy1zcHJpdGVcIj4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwibWluaWNvbG9ycy1ncmlkLWlubmVyXCI+PC9kaXY+JyArXG4gICAgICAnPGRpdiBjbGFzcz1cIm1pbmljb2xvcnMtcGlja2VyXCI+PGRpdj48L2Rpdj48L2Rpdj4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8L2Rpdj4nXG4gICAgICApO1xuXG4gICAgLy8gVGhlIHN3YXRjaFxuICAgIGlmKCFzZXR0aW5ncy5pbmxpbmUpIHtcbiAgICAgIGlucHV0LmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1pbmljb2xvcnMtc3dhdGNoIG1pbmljb2xvcnMtc3ByaXRlIG1pbmljb2xvcnMtaW5wdXQtc3dhdGNoXCI+PHNwYW4gY2xhc3M9XCJtaW5pY29sb3JzLXN3YXRjaC1jb2xvclwiPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICBpbnB1dC5uZXh0KCcubWluaWNvbG9ycy1pbnB1dC1zd2F0Y2gnKS5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiBpbiBJRVxuICAgIHBhbmVsID0gaW5wdXQucGFyZW50KCkuZmluZCgnLm1pbmljb2xvcnMtcGFuZWwnKTtcbiAgICBwYW5lbC5vbignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KS5lbmQoKTtcblxuICAgIC8vIFN3YXRjaGVzXG4gICAgaWYoc2V0dGluZ3Muc3dhdGNoZXMgJiYgc2V0dGluZ3Muc3dhdGNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBwYW5lbC5hZGRDbGFzcygnbWluaWNvbG9ycy13aXRoLXN3YXRjaGVzJyk7XG4gICAgICBzd2F0Y2hlcyA9ICQoJzx1bCBjbGFzcz1cIm1pbmljb2xvcnMtc3dhdGNoZXNcIj48L3VsPicpXG4gICAgICAgIC5hcHBlbmRUbyhwYW5lbCk7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBzZXR0aW5ncy5zd2F0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBhbGxvdyBmb3IgY3VzdG9tIG9iamVjdHMgYXMgc3dhdGNoZXNcbiAgICAgICAgaWYoJC50eXBlKHNldHRpbmdzLnN3YXRjaGVzW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBuYW1lID0gc2V0dGluZ3Muc3dhdGNoZXNbaV0ubmFtZTtcbiAgICAgICAgICBzd2F0Y2ggPSBzZXR0aW5ncy5zd2F0Y2hlc1tpXS5jb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gJyc7XG4gICAgICAgICAgc3dhdGNoID0gc2V0dGluZ3Muc3dhdGNoZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgc3dhdGNoU3RyaW5nID0gc3dhdGNoO1xuICAgICAgICBzd2F0Y2ggPSBpc1JnYihzd2F0Y2gpID8gcGFyc2VSZ2Ioc3dhdGNoLCB0cnVlKSA6IGhleDJyZ2IocGFyc2VIZXgoc3dhdGNoLCB0cnVlKSk7XG4gICAgICAgICQoJzxsaSBjbGFzcz1cIm1pbmljb2xvcnMtc3dhdGNoIG1pbmljb2xvcnMtc3ByaXRlXCI+PHNwYW4gY2xhc3M9XCJtaW5pY29sb3JzLXN3YXRjaC1jb2xvclwiIHRpdGxlPVwiJyArIG5hbWUgKyAnXCI+PC9zcGFuPjwvbGk+JylcbiAgICAgICAgICAuYXBwZW5kVG8oc3dhdGNoZXMpXG4gICAgICAgICAgLmRhdGEoJ3N3YXRjaC1jb2xvcicsIHN3YXRjaFN0cmluZylcbiAgICAgICAgICAuZmluZCgnLm1pbmljb2xvcnMtc3dhdGNoLWNvbG9yJylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmdiMmhleChzd2F0Y2gpLFxuICAgICAgICAgICAgb3BhY2l0eTogc3dhdGNoLmFcbiAgICAgICAgICB9KTtcbiAgICAgICAgc2V0dGluZ3Muc3dhdGNoZXNbaV0gPSBzd2F0Y2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5saW5lIGNvbnRyb2xzXG4gICAgaWYoc2V0dGluZ3MuaW5saW5lKSBpbnB1dC5wYXJlbnQoKS5hZGRDbGFzcygnbWluaWNvbG9ycy1pbmxpbmUnKTtcblxuICAgIHVwZGF0ZUZyb21JbnB1dChpbnB1dCwgZmFsc2UpO1xuXG4gICAgaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1pbml0aWFsaXplZCcsIHRydWUpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgaW5wdXQgYmFjayB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgZnVuY3Rpb24gZGVzdHJveShpbnB1dCkge1xuICAgIHZhciBtaW5pY29sb3JzID0gaW5wdXQucGFyZW50KCk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIGlucHV0IGVsZW1lbnRcbiAgICBpbnB1dFxuICAgICAgLnJlbW92ZURhdGEoJ21pbmljb2xvcnMtaW5pdGlhbGl6ZWQnKVxuICAgICAgLnJlbW92ZURhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKVxuICAgICAgLnJlbW92ZVByb3AoJ3NpemUnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdtaW5pY29sb3JzLWlucHV0Jyk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIHdyYXAgYW5kIGRlc3Ryb3kgd2hhdGV2ZXIgcmVtYWluc1xuICAgIG1pbmljb2xvcnMuYmVmb3JlKGlucHV0KS5yZW1vdmUoKTtcbiAgfVxuXG4gIC8vIFNob3dzIHRoZSBzcGVjaWZpZWQgZHJvcGRvd24gcGFuZWxcbiAgZnVuY3Rpb24gc2hvdyhpbnB1dCkge1xuICAgIHZhciBtaW5pY29sb3JzID0gaW5wdXQucGFyZW50KCk7XG4gICAgdmFyIHBhbmVsID0gbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1wYW5lbCcpO1xuICAgIHZhciBzZXR0aW5ncyA9IGlucHV0LmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKTtcblxuICAgIC8vIERvIG5vdGhpbmcgaWYgdW5pbml0aWFsaXplZCwgZGlzYWJsZWQsIGlubGluZSwgb3IgYWxyZWFkeSBvcGVuXG4gICAgaWYoXG4gICAgICAhaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1pbml0aWFsaXplZCcpIHx8XG4gICAgICBpbnB1dC5wcm9wKCdkaXNhYmxlZCcpIHx8XG4gICAgICBtaW5pY29sb3JzLmhhc0NsYXNzKCdtaW5pY29sb3JzLWlubGluZScpIHx8XG4gICAgICBtaW5pY29sb3JzLmhhc0NsYXNzKCdtaW5pY29sb3JzLWZvY3VzJylcbiAgICApIHJldHVybjtcblxuICAgIGhpZGUoKTtcblxuICAgIG1pbmljb2xvcnMuYWRkQ2xhc3MoJ21pbmljb2xvcnMtZm9jdXMnKTtcbiAgICBpZiAocGFuZWwuYW5pbWF0ZSkge1xuICAgICAgcGFuZWxcbiAgICAgICAgLnN0b3AodHJ1ZSwgdHJ1ZSlcbiAgICAgICAgLmZhZGVJbihzZXR0aW5ncy5zaG93U3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2V0dGluZ3Muc2hvdykgc2V0dGluZ3Muc2hvdy5jYWxsKGlucHV0LmdldCgwKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYW5lbC5zaG93KCk7XG4gICAgICBpZiAoc2V0dGluZ3Muc2hvdykgc2V0dGluZ3Muc2hvdy5jYWxsKGlucHV0LmdldCgwKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGlkZXMgYWxsIGRyb3Bkb3duIHBhbmVsc1xuICBmdW5jdGlvbiBoaWRlKCkge1xuICAgICQoJy5taW5pY29sb3JzLWZvY3VzJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaW5pY29sb3JzID0gJCh0aGlzKTtcbiAgICAgIHZhciBpbnB1dCA9IG1pbmljb2xvcnMuZmluZCgnLm1pbmljb2xvcnMtaW5wdXQnKTtcbiAgICAgIHZhciBwYW5lbCA9IG1pbmljb2xvcnMuZmluZCgnLm1pbmljb2xvcnMtcGFuZWwnKTtcbiAgICAgIHZhciBzZXR0aW5ncyA9IGlucHV0LmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKTtcblxuICAgICAgaWYgKHBhbmVsLmFuaW1hdGUpIHtcbiAgICAgICAgcGFuZWwuZmFkZU91dChzZXR0aW5ncy5oaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MuaGlkZSkgc2V0dGluZ3MuaGlkZS5jYWxsKGlucHV0LmdldCgwKSk7XG4gICAgICAgICAgbWluaWNvbG9ycy5yZW1vdmVDbGFzcygnbWluaWNvbG9ycy1mb2N1cycpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhbmVsLmhpZGUoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmhpZGUpIHNldHRpbmdzLmhpZGUuY2FsbChpbnB1dC5nZXQoMCkpO1xuICAgICAgICBtaW5pY29sb3JzLnJlbW92ZUNsYXNzKCdtaW5pY29sb3JzLWZvY3VzJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBNb3ZlcyB0aGUgc2VsZWN0ZWQgcGlja2VyXG4gIGZ1bmN0aW9uIG1vdmUodGFyZ2V0LCBldmVudCwgYW5pbWF0ZSkge1xuICAgIHZhciBpbnB1dCA9IHRhcmdldC5wYXJlbnRzKCcubWluaWNvbG9ycycpLmZpbmQoJy5taW5pY29sb3JzLWlucHV0Jyk7XG4gICAgdmFyIHNldHRpbmdzID0gaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1zZXR0aW5ncycpO1xuICAgIHZhciBwaWNrZXIgPSB0YXJnZXQuZmluZCgnW2NsYXNzJD0tcGlja2VyXScpO1xuICAgIHZhciBvZmZzZXRYID0gdGFyZ2V0Lm9mZnNldCgpLmxlZnQ7XG4gICAgdmFyIG9mZnNldFkgPSB0YXJnZXQub2Zmc2V0KCkudG9wO1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZChldmVudC5wYWdlWCAtIG9mZnNldFgpO1xuICAgIHZhciB5ID0gTWF0aC5yb3VuZChldmVudC5wYWdlWSAtIG9mZnNldFkpO1xuICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGUgPyBzZXR0aW5ncy5hbmltYXRpb25TcGVlZCA6IDA7XG4gICAgdmFyIHd4LCB3eSwgciwgcGhpLCBzdHlsZXM7XG5cbiAgICAvLyBUb3VjaCBzdXBwb3J0XG4gICAgaWYoZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgeCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSBvZmZzZXRYO1xuICAgICAgeSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBvZmZzZXRZO1xuICAgIH1cblxuICAgIC8vIENvbnN0cmFpbiBwaWNrZXIgdG8gaXRzIGNvbnRhaW5lclxuICAgIGlmKHggPCAwKSB4ID0gMDtcbiAgICBpZih5IDwgMCkgeSA9IDA7XG4gICAgaWYoeCA+IHRhcmdldC53aWR0aCgpKSB4ID0gdGFyZ2V0LndpZHRoKCk7XG4gICAgaWYoeSA+IHRhcmdldC5oZWlnaHQoKSkgeSA9IHRhcmdldC5oZWlnaHQoKTtcblxuICAgIC8vIENvbnN0cmFpbiBjb2xvciB3aGVlbCB2YWx1ZXMgdG8gdGhlIHdoZWVsXG4gICAgaWYodGFyZ2V0LnBhcmVudCgpLmlzKCcubWluaWNvbG9ycy1zbGlkZXItd2hlZWwnKSAmJiBwaWNrZXIucGFyZW50KCkuaXMoJy5taW5pY29sb3JzLWdyaWQnKSkge1xuICAgICAgd3ggPSA3NSAtIHg7XG4gICAgICB3eSA9IDc1IC0geTtcbiAgICAgIHIgPSBNYXRoLnNxcnQod3ggKiB3eCArIHd5ICogd3kpO1xuICAgICAgcGhpID0gTWF0aC5hdGFuMih3eSwgd3gpO1xuICAgICAgaWYocGhpIDwgMCkgcGhpICs9IE1hdGguUEkgKiAyO1xuICAgICAgaWYociA+IDc1KSB7XG4gICAgICAgIHIgPSA3NTtcbiAgICAgICAgeCA9IDc1IC0gKDc1ICogTWF0aC5jb3MocGhpKSk7XG4gICAgICAgIHkgPSA3NSAtICg3NSAqIE1hdGguc2luKHBoaSkpO1xuICAgICAgfVxuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBwaWNrZXJcbiAgICBzdHlsZXMgPSB7XG4gICAgICB0b3A6IHkgKyAncHgnXG4gICAgfTtcbiAgICBpZih0YXJnZXQuaXMoJy5taW5pY29sb3JzLWdyaWQnKSkge1xuICAgICAgc3R5bGVzLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB9XG4gICAgaWYgKHBpY2tlci5hbmltYXRlKSB7XG4gICAgICBwaWNrZXJcbiAgICAgICAgLnN0b3AodHJ1ZSlcbiAgICAgICAgLmFuaW1hdGUoc3R5bGVzLCBkdXJhdGlvbiwgc2V0dGluZ3MuYW5pbWF0aW9uRWFzaW5nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB1cGRhdGVGcm9tQ29udHJvbChpbnB1dCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlclxuICAgICAgICAuY3NzKHN0eWxlcyk7XG4gICAgICB1cGRhdGVGcm9tQ29udHJvbChpbnB1dCwgdGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXRzIHRoZSBpbnB1dCBiYXNlZCBvbiB0aGUgY29sb3IgcGlja2VyIHZhbHVlc1xuICBmdW5jdGlvbiB1cGRhdGVGcm9tQ29udHJvbChpbnB1dCwgdGFyZ2V0KSB7XG5cbiAgICBmdW5jdGlvbiBnZXRDb29yZHMocGlja2VyLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBsZWZ0LCB0b3A7XG4gICAgICBpZighcGlja2VyLmxlbmd0aCB8fCAhY29udGFpbmVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxlZnQgPSBwaWNrZXIub2Zmc2V0KCkubGVmdDtcbiAgICAgIHRvcCA9IHBpY2tlci5vZmZzZXQoKS50b3A7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxlZnQgLSBjb250YWluZXIub2Zmc2V0KCkubGVmdCArIChwaWNrZXIub3V0ZXJXaWR0aCgpIC8gMiksXG4gICAgICAgIHk6IHRvcCAtIGNvbnRhaW5lci5vZmZzZXQoKS50b3AgKyAocGlja2VyLm91dGVySGVpZ2h0KCkgLyAyKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaHVlLCBzYXR1cmF0aW9uLCBicmlnaHRuZXNzLCB4LCB5LCByLCBwaGk7XG4gICAgdmFyIGhleCA9IGlucHV0LnZhbCgpO1xuICAgIHZhciBvcGFjaXR5ID0gaW5wdXQuYXR0cignZGF0YS1vcGFjaXR5Jyk7XG5cbiAgICAvLyBIZWxwZnVsIHJlZmVyZW5jZXNcbiAgICB2YXIgbWluaWNvbG9ycyA9IGlucHV0LnBhcmVudCgpO1xuICAgIHZhciBzZXR0aW5ncyA9IGlucHV0LmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKTtcbiAgICB2YXIgc3dhdGNoID0gbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1pbnB1dC1zd2F0Y2gnKTtcblxuICAgIC8vIFBhbmVsIG9iamVjdHNcbiAgICB2YXIgZ3JpZCA9IG1pbmljb2xvcnMuZmluZCgnLm1pbmljb2xvcnMtZ3JpZCcpO1xuICAgIHZhciBzbGlkZXIgPSBtaW5pY29sb3JzLmZpbmQoJy5taW5pY29sb3JzLXNsaWRlcicpO1xuICAgIHZhciBvcGFjaXR5U2xpZGVyID0gbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1vcGFjaXR5LXNsaWRlcicpO1xuXG4gICAgLy8gUGlja2VyIG9iamVjdHNcbiAgICB2YXIgZ3JpZFBpY2tlciA9IGdyaWQuZmluZCgnW2NsYXNzJD0tcGlja2VyXScpO1xuICAgIHZhciBzbGlkZXJQaWNrZXIgPSBzbGlkZXIuZmluZCgnW2NsYXNzJD0tcGlja2VyXScpO1xuICAgIHZhciBvcGFjaXR5UGlja2VyID0gb3BhY2l0eVNsaWRlci5maW5kKCdbY2xhc3MkPS1waWNrZXJdJyk7XG5cbiAgICAvLyBQaWNrZXIgcG9zaXRpb25zXG4gICAgdmFyIGdyaWRQb3MgPSBnZXRDb29yZHMoZ3JpZFBpY2tlciwgZ3JpZCk7XG4gICAgdmFyIHNsaWRlclBvcyA9IGdldENvb3JkcyhzbGlkZXJQaWNrZXIsIHNsaWRlcik7XG4gICAgdmFyIG9wYWNpdHlQb3MgPSBnZXRDb29yZHMob3BhY2l0eVBpY2tlciwgb3BhY2l0eVNsaWRlcik7XG5cbiAgICAvLyBIYW5kbGUgY29sb3JzXG4gICAgaWYodGFyZ2V0LmlzKCcubWluaWNvbG9ycy1ncmlkLCAubWluaWNvbG9ycy1zbGlkZXIsIC5taW5pY29sb3JzLW9wYWNpdHktc2xpZGVyJykpIHtcblxuICAgICAgLy8gRGV0ZXJtaW5lIEhTQiB2YWx1ZXNcbiAgICAgIHN3aXRjaChzZXR0aW5ncy5jb250cm9sKSB7XG4gICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgIC8vIENhbGN1bGF0ZSBodWUsIHNhdHVyYXRpb24sIGFuZCBicmlnaHRuZXNzXG4gICAgICAgIHggPSAoZ3JpZC53aWR0aCgpIC8gMikgLSBncmlkUG9zLng7XG4gICAgICAgIHkgPSAoZ3JpZC5oZWlnaHQoKSAvIDIpIC0gZ3JpZFBvcy55O1xuICAgICAgICByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICBwaGkgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgICAgICBpZihwaGkgPCAwKSBwaGkgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIGlmKHIgPiA3NSkge1xuICAgICAgICAgIHIgPSA3NTtcbiAgICAgICAgICBncmlkUG9zLnggPSA2OSAtICg3NSAqIE1hdGguY29zKHBoaSkpO1xuICAgICAgICAgIGdyaWRQb3MueSA9IDY5IC0gKDc1ICogTWF0aC5zaW4ocGhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2F0dXJhdGlvbiA9IGtlZXBXaXRoaW4ociAvIDAuNzUsIDAsIDEwMCk7XG4gICAgICAgIGh1ZSA9IGtlZXBXaXRoaW4ocGhpICogMTgwIC8gTWF0aC5QSSwgMCwgMzYwKTtcbiAgICAgICAgYnJpZ2h0bmVzcyA9IGtlZXBXaXRoaW4oMTAwIC0gTWF0aC5mbG9vcihzbGlkZXJQb3MueSAqICgxMDAgLyBzbGlkZXIuaGVpZ2h0KCkpKSwgMCwgMTAwKTtcbiAgICAgICAgaGV4ID0gaHNiMmhleCh7XG4gICAgICAgICAgaDogaHVlLFxuICAgICAgICAgIHM6IHNhdHVyYXRpb24sXG4gICAgICAgICAgYjogYnJpZ2h0bmVzc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgc2xpZGVyLmNzcygnYmFja2dyb3VuZENvbG9yJywgaHNiMmhleCh7IGg6IGh1ZSwgczogc2F0dXJhdGlvbiwgYjogMTAwIH0pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NhdHVyYXRpb24nOlxuICAgICAgICAvLyBDYWxjdWxhdGUgaHVlLCBzYXR1cmF0aW9uLCBhbmQgYnJpZ2h0bmVzc1xuICAgICAgICBodWUgPSBrZWVwV2l0aGluKHBhcnNlSW50KGdyaWRQb3MueCAqICgzNjAgLyBncmlkLndpZHRoKCkpLCAxMCksIDAsIDM2MCk7XG4gICAgICAgIHNhdHVyYXRpb24gPSBrZWVwV2l0aGluKDEwMCAtIE1hdGguZmxvb3Ioc2xpZGVyUG9zLnkgKiAoMTAwIC8gc2xpZGVyLmhlaWdodCgpKSksIDAsIDEwMCk7XG4gICAgICAgIGJyaWdodG5lc3MgPSBrZWVwV2l0aGluKDEwMCAtIE1hdGguZmxvb3IoZ3JpZFBvcy55ICogKDEwMCAvIGdyaWQuaGVpZ2h0KCkpKSwgMCwgMTAwKTtcbiAgICAgICAgaGV4ID0gaHNiMmhleCh7XG4gICAgICAgICAgaDogaHVlLFxuICAgICAgICAgIHM6IHNhdHVyYXRpb24sXG4gICAgICAgICAgYjogYnJpZ2h0bmVzc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgc2xpZGVyLmNzcygnYmFja2dyb3VuZENvbG9yJywgaHNiMmhleCh7IGg6IGh1ZSwgczogMTAwLCBiOiBicmlnaHRuZXNzIH0pKTtcbiAgICAgICAgbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1ncmlkLWlubmVyJykuY3NzKCdvcGFjaXR5Jywgc2F0dXJhdGlvbiAvIDEwMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdicmlnaHRuZXNzJzpcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGh1ZSwgc2F0dXJhdGlvbiwgYW5kIGJyaWdodG5lc3NcbiAgICAgICAgaHVlID0ga2VlcFdpdGhpbihwYXJzZUludChncmlkUG9zLnggKiAoMzYwIC8gZ3JpZC53aWR0aCgpKSwgMTApLCAwLCAzNjApO1xuICAgICAgICBzYXR1cmF0aW9uID0ga2VlcFdpdGhpbigxMDAgLSBNYXRoLmZsb29yKGdyaWRQb3MueSAqICgxMDAgLyBncmlkLmhlaWdodCgpKSksIDAsIDEwMCk7XG4gICAgICAgIGJyaWdodG5lc3MgPSBrZWVwV2l0aGluKDEwMCAtIE1hdGguZmxvb3Ioc2xpZGVyUG9zLnkgKiAoMTAwIC8gc2xpZGVyLmhlaWdodCgpKSksIDAsIDEwMCk7XG4gICAgICAgIGhleCA9IGhzYjJoZXgoe1xuICAgICAgICAgIGg6IGh1ZSxcbiAgICAgICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgICAgIGI6IGJyaWdodG5lc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIFVJXG4gICAgICAgIHNsaWRlci5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGhzYjJoZXgoeyBoOiBodWUsIHM6IHNhdHVyYXRpb24sIGI6IDEwMCB9KSk7XG4gICAgICAgIG1pbmljb2xvcnMuZmluZCgnLm1pbmljb2xvcnMtZ3JpZC1pbm5lcicpLmNzcygnb3BhY2l0eScsIDEgLSAoYnJpZ2h0bmVzcyAvIDEwMCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGh1ZSwgc2F0dXJhdGlvbiwgYW5kIGJyaWdodG5lc3NcbiAgICAgICAgaHVlID0ga2VlcFdpdGhpbigzNjAgLSBwYXJzZUludChzbGlkZXJQb3MueSAqICgzNjAgLyBzbGlkZXIuaGVpZ2h0KCkpLCAxMCksIDAsIDM2MCk7XG4gICAgICAgIHNhdHVyYXRpb24gPSBrZWVwV2l0aGluKE1hdGguZmxvb3IoZ3JpZFBvcy54ICogKDEwMCAvIGdyaWQud2lkdGgoKSkpLCAwLCAxMDApO1xuICAgICAgICBicmlnaHRuZXNzID0ga2VlcFdpdGhpbigxMDAgLSBNYXRoLmZsb29yKGdyaWRQb3MueSAqICgxMDAgLyBncmlkLmhlaWdodCgpKSksIDAsIDEwMCk7XG4gICAgICAgIGhleCA9IGhzYjJoZXgoe1xuICAgICAgICAgIGg6IGh1ZSxcbiAgICAgICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgICAgIGI6IGJyaWdodG5lc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIFVJXG4gICAgICAgIGdyaWQuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCBoc2IyaGV4KHsgaDogaHVlLCBzOiAxMDAsIGI6IDEwMCB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgb3BhY2l0eVxuICAgICAgaWYoc2V0dGluZ3Mub3BhY2l0eSkge1xuICAgICAgICBvcGFjaXR5ID0gcGFyc2VGbG9hdCgxIC0gKG9wYWNpdHlQb3MueSAvIG9wYWNpdHlTbGlkZXIuaGVpZ2h0KCkpKS50b0ZpeGVkKDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUlucHV0KGlucHV0LCBoZXgsIG9wYWNpdHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFNldCBzd2F0Y2ggY29sb3JcbiAgICAgIHN3YXRjaC5maW5kKCdzcGFuJykuY3NzKHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoZXgsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgY2hhbmdlIGV2ZW50XG4gICAgICBkb0NoYW5nZShpbnB1dCwgaGV4LCBvcGFjaXR5KTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgYW5kIGRvZXMgdGhlIGFwcHJvcHJpYXRlIGNvbnZlcnNpb25zXG4gIC8vIHRvIHJlc3BlY3Qgc2V0dGluZ3MsIGFsc28gdXBkYXRlcyB0aGUgc3dhdGNoXG4gIGZ1bmN0aW9uIHVwZGF0ZUlucHV0KGlucHV0LCB2YWx1ZSwgb3BhY2l0eSkge1xuICAgIHZhciByZ2I7XG5cbiAgICAvLyBIZWxwZnVsIHJlZmVyZW5jZXNcbiAgICB2YXIgbWluaWNvbG9ycyA9IGlucHV0LnBhcmVudCgpO1xuICAgIHZhciBzZXR0aW5ncyA9IGlucHV0LmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKTtcbiAgICB2YXIgc3dhdGNoID0gbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1pbnB1dC1zd2F0Y2gnKTtcblxuICAgIGlmKHNldHRpbmdzLm9wYWNpdHkpIGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScsIG9wYWNpdHkpO1xuXG4gICAgLy8gU2V0IGNvbG9yIHN0cmluZ1xuICAgIGlmKHNldHRpbmdzLmZvcm1hdCA9PT0gJ3JnYicpIHtcbiAgICAgIC8vIFJldHVybnMgUkdCKEEpIHN0cmluZ1xuXG4gICAgICAvLyBDaGVja3MgZm9yIGlucHV0IGZvcm1hdCBhbmQgZG9lcyB0aGUgY29udmVyc2lvblxuICAgICAgaWYoaXNSZ2IodmFsdWUpKSB7XG4gICAgICAgIHJnYiA9IHBhcnNlUmdiKHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZ2IgPSBoZXgycmdiKHBhcnNlSGV4KHZhbHVlLCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIG9wYWNpdHkgPSBpbnB1dC5hdHRyKCdkYXRhLW9wYWNpdHknKSA9PT0gJycgPyAxIDoga2VlcFdpdGhpbihwYXJzZUZsb2F0KGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScpKS50b0ZpeGVkKDIpLCAwLCAxKTtcbiAgICAgIGlmKGlzTmFOKG9wYWNpdHkpIHx8ICFzZXR0aW5ncy5vcGFjaXR5KSBvcGFjaXR5ID0gMTtcblxuICAgICAgaWYoaW5wdXQubWluaWNvbG9ycygncmdiT2JqZWN0JykuYSA8PSAxICYmIHJnYiAmJiBzZXR0aW5ncy5vcGFjaXR5KSB7XG4gICAgICAgIC8vIFNldCBSR0JBIHN0cmluZyBpZiBhbHBoYVxuICAgICAgICB2YWx1ZSA9ICdyZ2JhKCcgKyByZ2IuciArICcsICcgKyByZ2IuZyArICcsICcgKyByZ2IuYiArICcsICcgKyBwYXJzZUZsb2F0KG9wYWNpdHkpICsgJyknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IFJHQiBzdHJpbmcgKGFscGhhID0gMSlcbiAgICAgICAgdmFsdWUgPSAncmdiKCcgKyByZ2IuciArICcsICcgKyByZ2IuZyArICcsICcgKyByZ2IuYiArICcpJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0dXJucyBoZXggY29sb3JcblxuICAgICAgLy8gQ2hlY2tzIGZvciBpbnB1dCBmb3JtYXQgYW5kIGRvZXMgdGhlIGNvbnZlcnNpb25cbiAgICAgIGlmKGlzUmdiKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHJnYlN0cmluZzJoZXgodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGNvbnZlcnRDYXNlKHZhbHVlLCBzZXR0aW5ncy5sZXR0ZXJDYXNlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmFsdWUgZnJvbSBwaWNrZXJcbiAgICBpbnB1dC52YWwodmFsdWUpO1xuXG4gICAgLy8gU2V0IHN3YXRjaCBjb2xvclxuICAgIHN3YXRjaC5maW5kKCdzcGFuJykuY3NzKHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdmFsdWUsXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhbmdlIGV2ZW50XG4gICAgZG9DaGFuZ2UoaW5wdXQsIHZhbHVlLCBvcGFjaXR5KTtcbiAgfVxuXG4gIC8vIFNldHMgdGhlIGNvbG9yIHBpY2tlciB2YWx1ZXMgZnJvbSB0aGUgaW5wdXRcbiAgZnVuY3Rpb24gdXBkYXRlRnJvbUlucHV0KGlucHV0LCBwcmVzZXJ2ZUlucHV0VmFsdWUpIHtcbiAgICB2YXIgaGV4LCBoc2IsIG9wYWNpdHksIGtleXdvcmRzLCBhbHBoYSwgdmFsdWUsIHgsIHksIHIsIHBoaTtcblxuICAgIC8vIEhlbHBmdWwgcmVmZXJlbmNlc1xuICAgIHZhciBtaW5pY29sb3JzID0gaW5wdXQucGFyZW50KCk7XG4gICAgdmFyIHNldHRpbmdzID0gaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1zZXR0aW5ncycpO1xuICAgIHZhciBzd2F0Y2ggPSBtaW5pY29sb3JzLmZpbmQoJy5taW5pY29sb3JzLWlucHV0LXN3YXRjaCcpO1xuXG4gICAgLy8gUGFuZWwgb2JqZWN0c1xuICAgIHZhciBncmlkID0gbWluaWNvbG9ycy5maW5kKCcubWluaWNvbG9ycy1ncmlkJyk7XG4gICAgdmFyIHNsaWRlciA9IG1pbmljb2xvcnMuZmluZCgnLm1pbmljb2xvcnMtc2xpZGVyJyk7XG4gICAgdmFyIG9wYWNpdHlTbGlkZXIgPSBtaW5pY29sb3JzLmZpbmQoJy5taW5pY29sb3JzLW9wYWNpdHktc2xpZGVyJyk7XG5cbiAgICAvLyBQaWNrZXIgb2JqZWN0c1xuICAgIHZhciBncmlkUGlja2VyID0gZ3JpZC5maW5kKCdbY2xhc3MkPS1waWNrZXJdJyk7XG4gICAgdmFyIHNsaWRlclBpY2tlciA9IHNsaWRlci5maW5kKCdbY2xhc3MkPS1waWNrZXJdJyk7XG4gICAgdmFyIG9wYWNpdHlQaWNrZXIgPSBvcGFjaXR5U2xpZGVyLmZpbmQoJ1tjbGFzcyQ9LXBpY2tlcl0nKTtcblxuICAgIC8vIERldGVybWluZSBoZXgvSFNCIHZhbHVlc1xuICAgIGlmKGlzUmdiKGlucHV0LnZhbCgpKSkge1xuICAgICAgLy8gSWYgaW5wdXQgdmFsdWUgaXMgYSByZ2IoYSkgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGhleCBjb2xvciBhbmQgdXBkYXRlIG9wYWNpdHlcbiAgICAgIGhleCA9IHJnYlN0cmluZzJoZXgoaW5wdXQudmFsKCkpO1xuICAgICAgYWxwaGEgPSBrZWVwV2l0aGluKHBhcnNlRmxvYXQoZ2V0QWxwaGEoaW5wdXQudmFsKCkpKS50b0ZpeGVkKDIpLCAwLCAxKTtcbiAgICAgIGlmKGFscGhhKSB7XG4gICAgICAgIGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScsIGFscGhhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGV4ID0gY29udmVydENhc2UocGFyc2VIZXgoaW5wdXQudmFsKCksIHRydWUpLCBzZXR0aW5ncy5sZXR0ZXJDYXNlKTtcbiAgICB9XG5cbiAgICBpZighaGV4KXtcbiAgICAgIGhleCA9IGNvbnZlcnRDYXNlKHBhcnNlSW5wdXQoc2V0dGluZ3MuZGVmYXVsdFZhbHVlLCB0cnVlKSwgc2V0dGluZ3MubGV0dGVyQ2FzZSk7XG4gICAgfVxuICAgIGhzYiA9IGhleDJoc2IoaGV4KTtcblxuICAgIC8vIEdldCBhcnJheSBvZiBsb3dlcmNhc2Uga2V5d29yZHNcbiAgICBrZXl3b3JkcyA9ICFzZXR0aW5ncy5rZXl3b3JkcyA/IFtdIDogJC5tYXAoc2V0dGluZ3Mua2V5d29yZHMuc3BsaXQoJywnKSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuICQudHJpbShhLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2V0IGNvbG9yIHN0cmluZ1xuICAgIGlmKGlucHV0LnZhbCgpICE9PSAnJyAmJiAkLmluQXJyYXkoaW5wdXQudmFsKCkudG9Mb3dlckNhc2UoKSwga2V5d29yZHMpID4gLTEpIHtcbiAgICAgIHZhbHVlID0gY29udmVydENhc2UoaW5wdXQudmFsKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGlzUmdiKGlucHV0LnZhbCgpKSA/IHBhcnNlUmdiKGlucHV0LnZhbCgpKSA6IGhleDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgaW5wdXQgdmFsdWVcbiAgICBpZighcHJlc2VydmVJbnB1dFZhbHVlKSBpbnB1dC52YWwodmFsdWUpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIG9wYWNpdHkgdmFsdWVcbiAgICBpZihzZXR0aW5ncy5vcGFjaXR5KSB7XG4gICAgICAvLyBHZXQgZnJvbSBkYXRhLW9wYWNpdHkgYXR0cmlidXRlIGFuZCBrZWVwIHdpdGhpbiAwLTEgcmFuZ2VcbiAgICAgIG9wYWNpdHkgPSBpbnB1dC5hdHRyKCdkYXRhLW9wYWNpdHknKSA9PT0gJycgPyAxIDoga2VlcFdpdGhpbihwYXJzZUZsb2F0KGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScpKS50b0ZpeGVkKDIpLCAwLCAxKTtcbiAgICAgIGlmKGlzTmFOKG9wYWNpdHkpKSBvcGFjaXR5ID0gMTtcbiAgICAgIGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgc3dhdGNoLmZpbmQoJ3NwYW4nKS5jc3MoJ29wYWNpdHknLCBvcGFjaXR5KTtcblxuICAgICAgLy8gU2V0IG9wYWNpdHkgcGlja2VyIHBvc2l0aW9uXG4gICAgICB5ID0ga2VlcFdpdGhpbihvcGFjaXR5U2xpZGVyLmhlaWdodCgpIC0gKG9wYWNpdHlTbGlkZXIuaGVpZ2h0KCkgKiBvcGFjaXR5KSwgMCwgb3BhY2l0eVNsaWRlci5oZWlnaHQoKSk7XG4gICAgICBvcGFjaXR5UGlja2VyLmNzcygndG9wJywgeSArICdweCcpO1xuICAgIH1cblxuICAgIC8vIFNldCBvcGFjaXR5IHRvIHplcm8gaWYgaW5wdXQgdmFsdWUgaXMgdHJhbnNwYXJlbnRcbiAgICBpZihpbnB1dC52YWwoKS50b0xvd2VyQ2FzZSgpID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICBzd2F0Y2guZmluZCgnc3BhbicpLmNzcygnb3BhY2l0eScsIDApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzd2F0Y2hcbiAgICBzd2F0Y2guZmluZCgnc3BhbicpLmNzcygnYmFja2dyb3VuZENvbG9yJywgaGV4KTtcblxuICAgIC8vIERldGVybWluZSBwaWNrZXIgbG9jYXRpb25zXG4gICAgc3dpdGNoKHNldHRpbmdzLmNvbnRyb2wpIHtcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICAvLyBTZXQgZ3JpZCBwb3NpdGlvblxuICAgICAgciA9IGtlZXBXaXRoaW4oTWF0aC5jZWlsKGhzYi5zICogMC43NSksIDAsIGdyaWQuaGVpZ2h0KCkgLyAyKTtcbiAgICAgIHBoaSA9IGhzYi5oICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIHggPSBrZWVwV2l0aGluKDc1IC0gTWF0aC5jb3MocGhpKSAqIHIsIDAsIGdyaWQud2lkdGgoKSk7XG4gICAgICB5ID0ga2VlcFdpdGhpbig3NSAtIE1hdGguc2luKHBoaSkgKiByLCAwLCBncmlkLmhlaWdodCgpKTtcbiAgICAgIGdyaWRQaWNrZXIuY3NzKHtcbiAgICAgICAgdG9wOiB5ICsgJ3B4JyxcbiAgICAgICAgbGVmdDogeCArICdweCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgc2xpZGVyIHBvc2l0aW9uXG4gICAgICB5ID0gMTUwIC0gKGhzYi5iIC8gKDEwMCAvIGdyaWQuaGVpZ2h0KCkpKTtcbiAgICAgIGlmKGhleCA9PT0gJycpIHkgPSAwO1xuICAgICAgc2xpZGVyUGlja2VyLmNzcygndG9wJywgeSArICdweCcpO1xuXG4gICAgICAvLyBVcGRhdGUgcGFuZWwgY29sb3JcbiAgICAgIHNsaWRlci5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGhzYjJoZXgoeyBoOiBoc2IuaCwgczogaHNiLnMsIGI6IDEwMCB9KSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NhdHVyYXRpb24nOlxuICAgICAgLy8gU2V0IGdyaWQgcG9zaXRpb25cbiAgICAgIHggPSBrZWVwV2l0aGluKCg1ICogaHNiLmgpIC8gMTIsIDAsIDE1MCk7XG4gICAgICB5ID0ga2VlcFdpdGhpbihncmlkLmhlaWdodCgpIC0gTWF0aC5jZWlsKGhzYi5iIC8gKDEwMCAvIGdyaWQuaGVpZ2h0KCkpKSwgMCwgZ3JpZC5oZWlnaHQoKSk7XG4gICAgICBncmlkUGlja2VyLmNzcyh7XG4gICAgICAgIHRvcDogeSArICdweCcsXG4gICAgICAgIGxlZnQ6IHggKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHNsaWRlciBwb3NpdGlvblxuICAgICAgeSA9IGtlZXBXaXRoaW4oc2xpZGVyLmhlaWdodCgpIC0gKGhzYi5zICogKHNsaWRlci5oZWlnaHQoKSAvIDEwMCkpLCAwLCBzbGlkZXIuaGVpZ2h0KCkpO1xuICAgICAgc2xpZGVyUGlja2VyLmNzcygndG9wJywgeSArICdweCcpO1xuXG4gICAgICAvLyBVcGRhdGUgVUlcbiAgICAgIHNsaWRlci5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGhzYjJoZXgoeyBoOiBoc2IuaCwgczogMTAwLCBiOiBoc2IuYiB9KSk7XG4gICAgICBtaW5pY29sb3JzLmZpbmQoJy5taW5pY29sb3JzLWdyaWQtaW5uZXInKS5jc3MoJ29wYWNpdHknLCBoc2IucyAvIDEwMCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JyaWdodG5lc3MnOlxuICAgICAgLy8gU2V0IGdyaWQgcG9zaXRpb25cbiAgICAgIHggPSBrZWVwV2l0aGluKCg1ICogaHNiLmgpIC8gMTIsIDAsIDE1MCk7XG4gICAgICB5ID0ga2VlcFdpdGhpbihncmlkLmhlaWdodCgpIC0gTWF0aC5jZWlsKGhzYi5zIC8gKDEwMCAvIGdyaWQuaGVpZ2h0KCkpKSwgMCwgZ3JpZC5oZWlnaHQoKSk7XG4gICAgICBncmlkUGlja2VyLmNzcyh7XG4gICAgICAgIHRvcDogeSArICdweCcsXG4gICAgICAgIGxlZnQ6IHggKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHNsaWRlciBwb3NpdGlvblxuICAgICAgeSA9IGtlZXBXaXRoaW4oc2xpZGVyLmhlaWdodCgpIC0gKGhzYi5iICogKHNsaWRlci5oZWlnaHQoKSAvIDEwMCkpLCAwLCBzbGlkZXIuaGVpZ2h0KCkpO1xuICAgICAgc2xpZGVyUGlja2VyLmNzcygndG9wJywgeSArICdweCcpO1xuXG4gICAgICAvLyBVcGRhdGUgVUlcbiAgICAgIHNsaWRlci5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGhzYjJoZXgoeyBoOiBoc2IuaCwgczogaHNiLnMsIGI6IDEwMCB9KSk7XG4gICAgICBtaW5pY29sb3JzLmZpbmQoJy5taW5pY29sb3JzLWdyaWQtaW5uZXInKS5jc3MoJ29wYWNpdHknLCAxIC0gKGhzYi5iIC8gMTAwKSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBTZXQgZ3JpZCBwb3NpdGlvblxuICAgICAgeCA9IGtlZXBXaXRoaW4oTWF0aC5jZWlsKGhzYi5zIC8gKDEwMCAvIGdyaWQud2lkdGgoKSkpLCAwLCBncmlkLndpZHRoKCkpO1xuICAgICAgeSA9IGtlZXBXaXRoaW4oZ3JpZC5oZWlnaHQoKSAtIE1hdGguY2VpbChoc2IuYiAvICgxMDAgLyBncmlkLmhlaWdodCgpKSksIDAsIGdyaWQuaGVpZ2h0KCkpO1xuICAgICAgZ3JpZFBpY2tlci5jc3Moe1xuICAgICAgICB0b3A6IHkgKyAncHgnLFxuICAgICAgICBsZWZ0OiB4ICsgJ3B4J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCBzbGlkZXIgcG9zaXRpb25cbiAgICAgIHkgPSBrZWVwV2l0aGluKHNsaWRlci5oZWlnaHQoKSAtIChoc2IuaCAvICgzNjAgLyBzbGlkZXIuaGVpZ2h0KCkpKSwgMCwgc2xpZGVyLmhlaWdodCgpKTtcbiAgICAgIHNsaWRlclBpY2tlci5jc3MoJ3RvcCcsIHkgKyAncHgnKTtcblxuICAgICAgLy8gVXBkYXRlIHBhbmVsIGNvbG9yXG4gICAgICBncmlkLmNzcygnYmFja2dyb3VuZENvbG9yJywgaHNiMmhleCh7IGg6IGhzYi5oLCBzOiAxMDAsIGI6IDEwMCB9KSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGaXJlIGNoYW5nZSBldmVudCwgYnV0IG9ubHkgaWYgbWluaWNvbG9ycyBpcyBmdWxseSBpbml0aWFsaXplZFxuICAgIGlmKGlucHV0LmRhdGEoJ21pbmljb2xvcnMtaW5pdGlhbGl6ZWQnKSkge1xuICAgICAgZG9DaGFuZ2UoaW5wdXQsIHZhbHVlLCBvcGFjaXR5KTtcbiAgICB9XG4gIH1cblxuICAvLyBSdW5zIHRoZSBjaGFuZ2UgYW5kIGNoYW5nZURlbGF5IGNhbGxiYWNrc1xuICBmdW5jdGlvbiBkb0NoYW5nZShpbnB1dCwgdmFsdWUsIG9wYWNpdHkpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBpbnB1dC5kYXRhKCdtaW5pY29sb3JzLXNldHRpbmdzJyk7XG4gICAgdmFyIGxhc3RDaGFuZ2UgPSBpbnB1dC5kYXRhKCdtaW5pY29sb3JzLWxhc3RDaGFuZ2UnKTtcbiAgICB2YXIgb2JqLCBzZWwsIGk7XG5cbiAgICAvLyBPbmx5IHJ1biBpZiBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgaWYoIWxhc3RDaGFuZ2UgfHwgbGFzdENoYW5nZS52YWx1ZSAhPT0gdmFsdWUgfHwgbGFzdENoYW5nZS5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG5cbiAgICAgIC8vIFJlbWVtYmVyIGxhc3QtY2hhbmdlZCB2YWx1ZVxuICAgICAgaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1sYXN0Q2hhbmdlJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDaGVjayBhbmQgc2VsZWN0IGFwcGxpY2FibGUgc3dhdGNoXG4gICAgICBpZihzZXR0aW5ncy5zd2F0Y2hlcyAmJiBzZXR0aW5ncy5zd2F0Y2hlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaWYoIWlzUmdiKHZhbHVlKSkge1xuICAgICAgICAgIG9iaiA9IGhleDJyZ2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9iaiA9IHBhcnNlUmdiKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWwgPSAtMTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgc2V0dGluZ3Muc3dhdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZihvYmouciA9PT0gc2V0dGluZ3Muc3dhdGNoZXNbaV0uciAmJiBvYmouZyA9PT0gc2V0dGluZ3Muc3dhdGNoZXNbaV0uZyAmJiBvYmouYiA9PT0gc2V0dGluZ3Muc3dhdGNoZXNbaV0uYiAmJiBvYmouYSA9PT0gc2V0dGluZ3Muc3dhdGNoZXNbaV0uYSkge1xuICAgICAgICAgICAgc2VsID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0LnBhcmVudCgpLmZpbmQoJy5taW5pY29sb3JzLXN3YXRjaGVzIC5taW5pY29sb3JzLXN3YXRjaCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICBpZihzZWwgIT09IC0xKSB7XG4gICAgICAgICAgaW5wdXQucGFyZW50KCkuZmluZCgnLm1pbmljb2xvcnMtc3dhdGNoZXMgLm1pbmljb2xvcnMtc3dhdGNoJykuZXEoaSkuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRcbiAgICAgIGlmKHNldHRpbmdzLmNoYW5nZSkge1xuICAgICAgICBpZihzZXR0aW5ncy5jaGFuZ2VEZWxheSkge1xuICAgICAgICAgIC8vIENhbGwgYWZ0ZXIgYSBkZWxheVxuICAgICAgICAgIGNsZWFyVGltZW91dChpbnB1dC5kYXRhKCdtaW5pY29sb3JzLWNoYW5nZVRpbWVvdXQnKSk7XG4gICAgICAgICAgaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1jaGFuZ2VUaW1lb3V0Jywgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmNoYW5nZS5jYWxsKGlucHV0LmdldCgwKSwgdmFsdWUsIG9wYWNpdHkpO1xuICAgICAgICAgIH0sIHNldHRpbmdzLmNoYW5nZURlbGF5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FsbCBpbW1lZGlhdGVseVxuICAgICAgICAgIHNldHRpbmdzLmNoYW5nZS5jYWxsKGlucHV0LmdldCgwKSwgdmFsdWUsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKS50cmlnZ2VyKCdpbnB1dCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhbiBSR0IoQSkgb2JqZWN0IGJhc2VkIG9uIHRoZSBpbnB1dCdzIHZhbHVlXG4gIGZ1bmN0aW9uIHJnYk9iamVjdChpbnB1dCkge1xuICAgIHZhciByZ2IsXG4gICAgICBvcGFjaXR5ID0gJChpbnB1dCkuYXR0cignZGF0YS1vcGFjaXR5Jyk7XG4gICAgaWYoIGlzUmdiKCQoaW5wdXQpLnZhbCgpKSApIHtcbiAgICAgIHJnYiA9IHBhcnNlUmdiKCQoaW5wdXQpLnZhbCgpLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhleCA9IHBhcnNlSGV4KCQoaW5wdXQpLnZhbCgpLCB0cnVlKTtcbiAgICAgIHJnYiA9IGhleDJyZ2IoaGV4KTtcbiAgICB9XG4gICAgaWYoICFyZ2IgKSByZXR1cm4gbnVsbDtcbiAgICBpZiggb3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgJC5leHRlbmQocmdiLCB7IGE6IHBhcnNlRmxvYXQob3BhY2l0eSkgfSk7XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhbiBSR0IoQSkgc3RyaW5nIGJhc2VkIG9uIHRoZSBpbnB1dCdzIHZhbHVlXG4gIGZ1bmN0aW9uIHJnYlN0cmluZyhpbnB1dCwgYWxwaGEpIHtcbiAgICB2YXIgcmdiLFxuICAgICAgb3BhY2l0eSA9ICQoaW5wdXQpLmF0dHIoJ2RhdGEtb3BhY2l0eScpO1xuICAgIGlmKCBpc1JnYigkKGlucHV0KS52YWwoKSkgKSB7XG4gICAgICByZ2IgPSBwYXJzZVJnYigkKGlucHV0KS52YWwoKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZXggPSBwYXJzZUhleCgkKGlucHV0KS52YWwoKSwgdHJ1ZSk7XG4gICAgICByZ2IgPSBoZXgycmdiKGhleCk7XG4gICAgfVxuICAgIGlmKCAhcmdiICkgcmV0dXJuIG51bGw7XG4gICAgaWYoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xuICAgIGlmKCBhbHBoYSApIHtcbiAgICAgIHJldHVybiAncmdiYSgnICsgcmdiLnIgKyAnLCAnICsgcmdiLmcgKyAnLCAnICsgcmdiLmIgKyAnLCAnICsgcGFyc2VGbG9hdChvcGFjaXR5KSArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHJnYi5yICsgJywgJyArIHJnYi5nICsgJywgJyArIHJnYi5iICsgJyknO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnRzIHRvIHRoZSBsZXR0ZXIgY2FzZSBzcGVjaWZpZWQgaW4gc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29udmVydENhc2Uoc3RyaW5nLCBsZXR0ZXJDYXNlKSB7XG4gICAgcmV0dXJuIGxldHRlckNhc2UgPT09ICd1cHBlcmNhc2UnID8gc3RyaW5nLnRvVXBwZXJDYXNlKCkgOiBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vIFBhcnNlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBhIHZhbGlkIGhleCBzdHJpbmcgd2hlbiBwb3NzaWJsZVxuICBmdW5jdGlvbiBwYXJzZUhleChzdHJpbmcsIGV4cGFuZCkge1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eIy9nLCAnJyk7XG4gICAgaWYoIXN0cmluZy5tYXRjaCgvXltBLUYwLTldezMsNn0vaWcpKSByZXR1cm4gJyc7XG4gICAgaWYoc3RyaW5nLmxlbmd0aCAhPT0gMyAmJiBzdHJpbmcubGVuZ3RoICE9PSA2KSByZXR1cm4gJyc7XG4gICAgaWYoc3RyaW5nLmxlbmd0aCA9PT0gMyAmJiBleHBhbmQpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZ1swXSArIHN0cmluZ1swXSArIHN0cmluZ1sxXSArIHN0cmluZ1sxXSArIHN0cmluZ1syXSArIHN0cmluZ1syXTtcbiAgICB9XG4gICAgcmV0dXJuICcjJyArIHN0cmluZztcbiAgfVxuXG4gIC8vIFBhcnNlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBhIHZhbGlkIFJHQihBKSBzdHJpbmcgd2hlbiBwb3NzaWJsZVxuICBmdW5jdGlvbiBwYXJzZVJnYihzdHJpbmcsIG9iaikge1xuICAgIHZhciB2YWx1ZXMgPSBzdHJpbmcucmVwbGFjZSgvW15cXGQsLl0vZywgJycpO1xuICAgIHZhciByZ2JhID0gdmFsdWVzLnNwbGl0KCcsJyk7XG5cbiAgICByZ2JhWzBdID0ga2VlcFdpdGhpbihwYXJzZUludChyZ2JhWzBdLCAxMCksIDAsIDI1NSk7XG4gICAgcmdiYVsxXSA9IGtlZXBXaXRoaW4ocGFyc2VJbnQocmdiYVsxXSwgMTApLCAwLCAyNTUpO1xuICAgIHJnYmFbMl0gPSBrZWVwV2l0aGluKHBhcnNlSW50KHJnYmFbMl0sIDEwKSwgMCwgMjU1KTtcbiAgICBpZihyZ2JhWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJnYmFbM10gPSBrZWVwV2l0aGluKHBhcnNlRmxvYXQocmdiYVszXSwgMTApLCAwLCAxKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gUkdCQSBvYmplY3RcbiAgICBpZiggb2JqICkge1xuICAgICAgaWYgKHJnYmFbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHJnYmFbMF0sXG4gICAgICAgICAgZzogcmdiYVsxXSxcbiAgICAgICAgICBiOiByZ2JhWzJdLFxuICAgICAgICAgIGE6IHJnYmFbM11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcmdiYVswXSxcbiAgICAgICAgICBnOiByZ2JhWzFdLFxuICAgICAgICAgIGI6IHJnYmFbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gUkdCQSBzdHJpbmdcbiAgICBpZih0eXBlb2YocmdiYVszXSkgIT09ICd1bmRlZmluZWQnICYmIHJnYmFbM10gPD0gMSkge1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhWzBdICsgJywgJyArIHJnYmFbMV0gKyAnLCAnICsgcmdiYVsyXSArICcsICcgKyByZ2JhWzNdICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgcmdiYVswXSArICcsICcgKyByZ2JhWzFdICsgJywgJyArIHJnYmFbMl0gKyAnKSc7XG4gICAgfVxuXG4gIH1cblxuICAvLyBQYXJzZXMgYSBzdHJpbmcgYW5kIHJldHVybnMgYSB2YWxpZCBjb2xvciBzdHJpbmcgd2hlbiBwb3NzaWJsZVxuICBmdW5jdGlvbiBwYXJzZUlucHV0KHN0cmluZywgZXhwYW5kKSB7XG4gICAgaWYoaXNSZ2Ioc3RyaW5nKSkge1xuICAgICAgLy8gUmV0dXJucyBhIHZhbGlkIHJnYihhKSBzdHJpbmdcbiAgICAgIHJldHVybiBwYXJzZVJnYihzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VIZXgoc3RyaW5nLCBleHBhbmQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEtlZXBzIHZhbHVlIHdpdGhpbiBtaW4gYW5kIG1heFxuICBmdW5jdGlvbiBrZWVwV2l0aGluKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmKHZhbHVlIDwgbWluKSB2YWx1ZSA9IG1pbjtcbiAgICBpZih2YWx1ZSA+IG1heCkgdmFsdWUgPSBtYXg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgUkdCKEEpIHN0cmluZ1xuICBmdW5jdGlvbiBpc1JnYihzdHJpbmcpIHtcbiAgICB2YXIgcmdiID0gc3RyaW5nLm1hdGNoKC9ecmdiYT9bXFxzK10/XFwoW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8vaSk7XG4gICAgcmV0dXJuIChyZ2IgJiYgcmdiLmxlbmd0aCA9PT0gNCkgPyB0cnVlIDogZmFsc2U7XG4gIH1cblxuICAvLyBGdW5jdGlvbiB0byBnZXQgYWxwaGEgZnJvbSBhIFJHQihBKSBzdHJpbmdcbiAgZnVuY3Rpb24gZ2V0QWxwaGEocmdiYSkge1xuICAgIHJnYmEgPSByZ2JhLm1hdGNoKC9ecmdiYT9bXFxzK10/XFwoW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKFxcLlxcZHsxLDJ9KT98XFwuXFxkezEsMn0pW1xccytdPy9pKTtcbiAgICByZXR1cm4gKHJnYmEgJiYgcmdiYS5sZW5ndGggPT09IDYpID8gcmdiYVs0XSA6ICcxJztcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGFuIEhTQiBvYmplY3QgdG8gYW4gUkdCIG9iamVjdFxuICBmdW5jdGlvbiBoc2IycmdiKGhzYikge1xuICAgIHZhciByZ2IgPSB7fTtcbiAgICB2YXIgaCA9IE1hdGgucm91bmQoaHNiLmgpO1xuICAgIHZhciBzID0gTWF0aC5yb3VuZChoc2IucyAqIDI1NSAvIDEwMCk7XG4gICAgdmFyIHYgPSBNYXRoLnJvdW5kKGhzYi5iICogMjU1IC8gMTAwKTtcbiAgICBpZihzID09PSAwKSB7XG4gICAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSB2O1xuICAgICAgdmFyIHQyID0gKDI1NSAtIHMpICogdiAvIDI1NTtcbiAgICAgIHZhciB0MyA9ICh0MSAtIHQyKSAqIChoICUgNjApIC8gNjA7XG4gICAgICBpZihoID09PSAzNjApIGggPSAwO1xuICAgICAgaWYoaCA8IDYwKSB7IHJnYi5yID0gdDE7IHJnYi5iID0gdDI7IHJnYi5nID0gdDIgKyB0MzsgfVxuICAgICAgZWxzZSBpZihoIDwgMTIwKSB7cmdiLmcgPSB0MTsgcmdiLmIgPSB0MjsgcmdiLnIgPSB0MSAtIHQzOyB9XG4gICAgICBlbHNlIGlmKGggPCAxODApIHtyZ2IuZyA9IHQxOyByZ2IuciA9IHQyOyByZ2IuYiA9IHQyICsgdDM7IH1cbiAgICAgIGVsc2UgaWYoaCA8IDI0MCkge3JnYi5iID0gdDE7IHJnYi5yID0gdDI7IHJnYi5nID0gdDEgLSB0MzsgfVxuICAgICAgZWxzZSBpZihoIDwgMzAwKSB7cmdiLmIgPSB0MTsgcmdiLmcgPSB0MjsgcmdiLnIgPSB0MiArIHQzOyB9XG4gICAgICBlbHNlIGlmKGggPCAzNjApIHtyZ2IuciA9IHQxOyByZ2IuZyA9IHQyOyByZ2IuYiA9IHQxIC0gdDM7IH1cbiAgICAgIGVsc2UgeyByZ2IuciA9IDA7IHJnYi5nID0gMDsgcmdiLmIgPSAwOyB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByOiBNYXRoLnJvdW5kKHJnYi5yKSxcbiAgICAgIGc6IE1hdGgucm91bmQocmdiLmcpLFxuICAgICAgYjogTWF0aC5yb3VuZChyZ2IuYilcbiAgICB9O1xuICB9XG5cbiAgLy8gQ29udmVydHMgYW4gUkdCIHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAgZnVuY3Rpb24gcmdiU3RyaW5nMmhleChyZ2Ipe1xuICAgIHJnYiA9IHJnYi5tYXRjaCgvXnJnYmE/W1xccytdP1xcKFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/L2kpO1xuICAgIHJldHVybiAocmdiICYmIHJnYi5sZW5ndGggPT09IDQpID8gJyMnICtcbiAgICAoJzAnICsgcGFyc2VJbnQocmdiWzFdLDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArXG4gICAgKCcwJyArIHBhcnNlSW50KHJnYlsyXSwxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgK1xuICAgICgnMCcgKyBwYXJzZUludChyZ2JbM10sMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpIDogJyc7XG4gIH1cblxuICAvLyBDb252ZXJ0cyBhbiBSR0Igb2JqZWN0IHRvIGEgaGV4IHN0cmluZ1xuICBmdW5jdGlvbiByZ2IyaGV4KHJnYikge1xuICAgIHZhciBoZXggPSBbXG4gICAgICByZ2Iuci50b1N0cmluZygxNiksXG4gICAgICByZ2IuZy50b1N0cmluZygxNiksXG4gICAgICByZ2IuYi50b1N0cmluZygxNilcbiAgICBdO1xuICAgICQuZWFjaChoZXgsIGZ1bmN0aW9uKG5yLCB2YWwpIHtcbiAgICAgIGlmKHZhbC5sZW5ndGggPT09IDEpIGhleFtucl0gPSAnMCcgKyB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuICcjJyArIGhleC5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGFuIEhTQiBvYmplY3QgdG8gYSBoZXggc3RyaW5nXG4gIGZ1bmN0aW9uIGhzYjJoZXgoaHNiKSB7XG4gICAgcmV0dXJuIHJnYjJoZXgoaHNiMnJnYihoc2IpKTtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhbiBIU0Igb2JqZWN0XG4gIGZ1bmN0aW9uIGhleDJoc2IoaGV4KSB7XG4gICAgdmFyIGhzYiA9IHJnYjJoc2IoaGV4MnJnYihoZXgpKTtcbiAgICBpZihoc2IucyA9PT0gMCkgaHNiLmggPSAzNjA7XG4gICAgcmV0dXJuIGhzYjtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGFuIFJHQiBvYmplY3QgdG8gYW4gSFNCIG9iamVjdFxuICBmdW5jdGlvbiByZ2IyaHNiKHJnYikge1xuICAgIHZhciBoc2IgPSB7IGg6IDAsIHM6IDAsIGI6IDAgfTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocmdiLnIsIHJnYi5nLCByZ2IuYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICBoc2IuYiA9IG1heDtcbiAgICBoc2IucyA9IG1heCAhPT0gMCA/IDI1NSAqIGRlbHRhIC8gbWF4IDogMDtcbiAgICBpZihoc2IucyAhPT0gMCkge1xuICAgICAgaWYocmdiLnIgPT09IG1heCkge1xuICAgICAgICBoc2IuaCA9IChyZ2IuZyAtIHJnYi5iKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmKHJnYi5nID09PSBtYXgpIHtcbiAgICAgICAgaHNiLmggPSAyICsgKHJnYi5iIC0gcmdiLnIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoc2IuaCA9IDQgKyAocmdiLnIgLSByZ2IuZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaHNiLmggPSAtMTtcbiAgICB9XG4gICAgaHNiLmggKj0gNjA7XG4gICAgaWYoaHNiLmggPCAwKSB7XG4gICAgICBoc2IuaCArPSAzNjA7XG4gICAgfVxuICAgIGhzYi5zICo9IDEwMC8yNTU7XG4gICAgaHNiLmIgKj0gMTAwLzI1NTtcbiAgICByZXR1cm4gaHNiO1xuICB9XG5cbiAgLy8gQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGFuIFJHQiBvYmplY3RcbiAgZnVuY3Rpb24gaGV4MnJnYihoZXgpIHtcbiAgICBoZXggPSBwYXJzZUludCgoKGhleC5pbmRleE9mKCcjJykgPiAtMSkgPyBoZXguc3Vic3RyaW5nKDEpIDogaGV4KSwgMTYpO1xuICAgIHJldHVybiB7XG4gICAgICByOiBoZXggPj4gMTYsXG4gICAgICBnOiAoaGV4ICYgMHgwMEZGMDApID4+IDgsXG4gICAgICBiOiAoaGV4ICYgMHgwMDAwRkYpXG4gICAgfTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBldmVudHNcbiAgJChbZG9jdW1lbnRdKVxuICAgIC8vIEhpZGUgb24gY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNvbnRyb2xcbiAgICAub24oJ21vdXNlZG93bi5taW5pY29sb3JzIHRvdWNoc3RhcnQubWluaWNvbG9ycycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZighJChldmVudC50YXJnZXQpLnBhcmVudHMoKS5hZGQoZXZlbnQudGFyZ2V0KS5oYXNDbGFzcygnbWluaWNvbG9ycycpKSB7XG4gICAgICAgIGhpZGUoKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIFN0YXJ0IG1vdmluZ1xuICAgIC5vbignbW91c2Vkb3duLm1pbmljb2xvcnMgdG91Y2hzdGFydC5taW5pY29sb3JzJywgJy5taW5pY29sb3JzLWdyaWQsIC5taW5pY29sb3JzLXNsaWRlciwgLm1pbmljb2xvcnMtb3BhY2l0eS1zbGlkZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9ICQodGhpcyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJChldmVudC5kZWxlZ2F0ZVRhcmdldCkuZGF0YSgnbWluaWNvbG9ycy10YXJnZXQnLCB0YXJnZXQpO1xuICAgICAgbW92ZSh0YXJnZXQsIGV2ZW50LCB0cnVlKTtcbiAgICB9KVxuICAgIC8vIE1vdmUgcGlja2Vyc1xuICAgIC5vbignbW91c2Vtb3ZlLm1pbmljb2xvcnMgdG91Y2htb3ZlLm1pbmljb2xvcnMnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9ICQoZXZlbnQuZGVsZWdhdGVUYXJnZXQpLmRhdGEoJ21pbmljb2xvcnMtdGFyZ2V0Jyk7XG4gICAgICBpZih0YXJnZXQpIG1vdmUodGFyZ2V0LCBldmVudCk7XG4gICAgfSlcbiAgICAvLyBTdG9wIG1vdmluZ1xuICAgIC5vbignbW91c2V1cC5taW5pY29sb3JzIHRvdWNoZW5kLm1pbmljb2xvcnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykucmVtb3ZlRGF0YSgnbWluaWNvbG9ycy10YXJnZXQnKTtcbiAgICB9KVxuICAgIC8vIFNlbGVjdGVkIGEgc3dhdGNoXG4gICAgLm9uKCdjbGljay5taW5pY29sb3JzJywgJy5taW5pY29sb3JzLXN3YXRjaGVzIGxpJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzKSwgaW5wdXQgPSB0YXJnZXQucGFyZW50cygnLm1pbmljb2xvcnMnKS5maW5kKCcubWluaWNvbG9ycy1pbnB1dCcpLCBjb2xvciA9IHRhcmdldC5kYXRhKCdzd2F0Y2gtY29sb3InKTtcbiAgICAgIHVwZGF0ZUlucHV0KGlucHV0LCBjb2xvciwgZ2V0QWxwaGEoY29sb3IpKTtcbiAgICAgIHVwZGF0ZUZyb21JbnB1dChpbnB1dCk7XG4gICAgfSlcbiAgICAvLyBTaG93IHBhbmVsIHdoZW4gc3dhdGNoIGlzIGNsaWNrZWRcbiAgICAub24oJ21vdXNlZG93bi5taW5pY29sb3JzIHRvdWNoc3RhcnQubWluaWNvbG9ycycsICcubWluaWNvbG9ycy1pbnB1dC1zd2F0Y2gnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKS5wYXJlbnQoKS5maW5kKCcubWluaWNvbG9ycy1pbnB1dCcpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNob3coaW5wdXQpO1xuICAgIH0pXG4gICAgLy8gU2hvdyBvbiBmb2N1c1xuICAgIC5vbignZm9jdXMubWluaWNvbG9ycycsICcubWluaWNvbG9ycy1pbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKTtcbiAgICAgIGlmKCFpbnB1dC5kYXRhKCdtaW5pY29sb3JzLWluaXRpYWxpemVkJykpIHJldHVybjtcbiAgICAgIHNob3coaW5wdXQpO1xuICAgIH0pXG4gICAgLy8gVXBkYXRlIHZhbHVlIG9uIGJsdXJcbiAgICAub24oJ2JsdXIubWluaWNvbG9ycycsICcubWluaWNvbG9ycy1pbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKTtcbiAgICAgIHZhciBzZXR0aW5ncyA9IGlucHV0LmRhdGEoJ21pbmljb2xvcnMtc2V0dGluZ3MnKTtcbiAgICAgIHZhciBrZXl3b3JkcztcbiAgICAgIHZhciBoZXg7XG4gICAgICB2YXIgcmdiYTtcbiAgICAgIHZhciBzd2F0Y2hPcGFjaXR5O1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZighaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1pbml0aWFsaXplZCcpKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCBhcnJheSBvZiBsb3dlcmNhc2Uga2V5d29yZHNcbiAgICAgIGtleXdvcmRzID0gIXNldHRpbmdzLmtleXdvcmRzID8gW10gOiAkLm1hcChzZXR0aW5ncy5rZXl3b3Jkcy5zcGxpdCgnLCcpLCBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiAkLnRyaW0oYS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgY29sb3Igc3RyaW5nXG4gICAgICBpZihpbnB1dC52YWwoKSAhPT0gJycgJiYgJC5pbkFycmF5KGlucHV0LnZhbCgpLnRvTG93ZXJDYXNlKCksIGtleXdvcmRzKSA+IC0xKSB7XG4gICAgICAgIHZhbHVlID0gaW5wdXQudmFsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgUkdCQSB2YWx1ZXMgZm9yIGVhc3kgY29udmVyc2lvblxuICAgICAgICBpZihpc1JnYihpbnB1dC52YWwoKSkpIHtcbiAgICAgICAgICByZ2JhID0gcGFyc2VSZ2IoaW5wdXQudmFsKCksIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhleCA9IHBhcnNlSGV4KGlucHV0LnZhbCgpLCB0cnVlKTtcbiAgICAgICAgICByZ2JhID0gaGV4ID8gaGV4MnJnYihoZXgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZm9ybWF0XG4gICAgICAgIGlmKHJnYmEgPT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmKHNldHRpbmdzLmZvcm1hdCA9PT0gJ3JnYicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLm9wYWNpdHkgP1xuICAgICAgICAgICAgcGFyc2VSZ2IoJ3JnYmEoJyArIHJnYmEuciArICcsJyArIHJnYmEuZyArICcsJyArIHJnYmEuYiArICcsJyArIGlucHV0LmF0dHIoJ2RhdGEtb3BhY2l0eScpICsgJyknKSA6XG4gICAgICAgICAgICBwYXJzZVJnYigncmdiKCcgKyByZ2JhLnIgKyAnLCcgKyByZ2JhLmcgKyAnLCcgKyByZ2JhLmIgKyAnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcmdiMmhleChyZ2JhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgc3dhdGNoIG9wYWNpdHlcbiAgICAgIHN3YXRjaE9wYWNpdHkgPSBzZXR0aW5ncy5vcGFjaXR5ID8gaW5wdXQuYXR0cignZGF0YS1vcGFjaXR5JykgOiAxO1xuICAgICAgaWYodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyYW5zcGFyZW50Jykgc3dhdGNoT3BhY2l0eSA9IDA7XG4gICAgICBpbnB1dFxuICAgICAgICAuY2xvc2VzdCgnLm1pbmljb2xvcnMnKVxuICAgICAgICAuZmluZCgnLm1pbmljb2xvcnMtaW5wdXQtc3dhdGNoID4gc3BhbicpXG4gICAgICAgIC5jc3MoJ29wYWNpdHknLCBzd2F0Y2hPcGFjaXR5KTtcblxuICAgICAgLy8gU2V0IGlucHV0IHZhbHVlXG4gICAgICBpbnB1dC52YWwodmFsdWUpO1xuXG4gICAgICAvLyBJcyBpdCBibGFuaz9cbiAgICAgIGlmKGlucHV0LnZhbCgpID09PSAnJykgaW5wdXQudmFsKHBhcnNlSW5wdXQoc2V0dGluZ3MuZGVmYXVsdFZhbHVlLCB0cnVlKSk7XG5cbiAgICAgIC8vIEFkanVzdCBjYXNlXG4gICAgICBpbnB1dC52YWwoY29udmVydENhc2UoaW5wdXQudmFsKCksIHNldHRpbmdzLmxldHRlckNhc2UpKTtcblxuICAgIH0pXG4gICAgLy8gSGFuZGxlIGtleXByZXNzZXNcbiAgICAub24oJ2tleWRvd24ubWluaWNvbG9ycycsICcubWluaWNvbG9ycy1pbnB1dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgaW5wdXQgPSAkKHRoaXMpO1xuICAgICAgaWYoIWlucHV0LmRhdGEoJ21pbmljb2xvcnMtaW5pdGlhbGl6ZWQnKSkgcmV0dXJuO1xuICAgICAgc3dpdGNoKGV2ZW50LndoaWNoKSB7XG4gICAgICBjYXNlIDk6IC8vIHRhYlxuICAgICAgICBoaWRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMzogLy8gZW50ZXJcbiAgICAgIGNhc2UgMjc6IC8vIGVzY1xuICAgICAgICBoaWRlKCk7XG4gICAgICAgIGlucHV0LmJsdXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSlcbiAgICAvLyBVcGRhdGUgb24ga2V5dXBcbiAgICAub24oJ2tleXVwLm1pbmljb2xvcnMnLCAnLm1pbmljb2xvcnMtaW5wdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dCA9ICQodGhpcyk7XG4gICAgICBpZighaW5wdXQuZGF0YSgnbWluaWNvbG9ycy1pbml0aWFsaXplZCcpKSByZXR1cm47XG4gICAgICB1cGRhdGVGcm9tSW5wdXQoaW5wdXQsIHRydWUpO1xuICAgIH0pXG4gICAgLy8gVXBkYXRlIG9uIHBhc3RlXG4gICAgLm9uKCdwYXN0ZS5taW5pY29sb3JzJywgJy5taW5pY29sb3JzLWlucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXQgPSAkKHRoaXMpO1xuICAgICAgaWYoIWlucHV0LmRhdGEoJ21pbmljb2xvcnMtaW5pdGlhbGl6ZWQnKSkgcmV0dXJuO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlRnJvbUlucHV0KGlucHV0LCB0cnVlKTtcbiAgICAgIH0sIDEpO1xuICAgIH0pO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/resources/write/minicolors.js\n");

/***/ }),

/***/ "./src/resources/write/squire.js":
/*!***************************************!*\
  !*** ./src/resources/write/squire.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Copyright © 2011-2015 by Neil Jenkins. MIT Licensed. */\nconst sq = function (doc, undefined) {\n  \"use strict\";\n\n  var DOCUMENT_POSITION_PRECEDING = 2; // Node.DOCUMENT_POSITION_PRECEDING\n\n  var ELEMENT_NODE = 1; // Node.ELEMENT_NODE;\n\n  var TEXT_NODE = 3; // Node.TEXT_NODE;\n\n  var DOCUMENT_NODE = 9; // Node.DOCUMENT_NODE;\n\n  var DOCUMENT_FRAGMENT_NODE = 11; // Node.DOCUMENT_FRAGMENT_NODE;\n\n  var SHOW_ELEMENT = 1; // NodeFilter.SHOW_ELEMENT;\n\n  var SHOW_TEXT = 4; // NodeFilter.SHOW_TEXT;\n\n  var START_TO_START = 0; // Range.START_TO_START\n\n  var START_TO_END = 1; // Range.START_TO_END\n\n  var END_TO_END = 2; // Range.END_TO_END\n\n  var END_TO_START = 3; // Range.END_TO_START\n\n  var ZWS = '\\u200B';\n  var win = doc.defaultView;\n  var ua = navigator.userAgent;\n  var isAndroid = /Android/.test(ua);\n  var isIOS = /iP(?:ad|hone|od)/.test(ua);\n  var isMac = /Mac OS X/.test(ua);\n  var isWin = /Windows NT/.test(ua);\n  var isGecko = /Gecko\\//.test(ua);\n  var isIElt11 = /Trident\\/[456]\\./.test(ua);\n  var isPresto = !!win.opera;\n  var isEdge = /Edge\\//.test(ua);\n  var isWebKit = !isEdge && /WebKit\\//.test(ua);\n  var isIE = /Trident\\/[4567]\\./.test(ua);\n  var ctrlKey = isMac ? 'meta-' : 'ctrl-';\n  var useTextFixer = isIElt11 || isPresto;\n  var cantFocusEmptyTextNodes = isIElt11 || isWebKit;\n  var losesSelectionOnBlur = isIElt11;\n  var canObserveMutations = typeof MutationObserver !== 'undefined';\n  var canWeakMap = typeof WeakMap !== 'undefined'; // Use [^ \\t\\r\\n] instead of \\S so that nbsp does not count as white-space\n\n  var notWS = /[^ \\t\\r\\n]/;\n  var indexOf = Array.prototype.indexOf; // Polyfill for FF3.5\n\n  if (!Object.create) {\n    Object.create = function (proto) {\n      var F = function () {};\n\n      F.prototype = proto;\n      return new F();\n    };\n  }\n  /*\n      Native TreeWalker is buggy in IE and Opera:\n      * IE9/10 sometimes throw errors when calling TreeWalker#nextNode or\n        TreeWalker#previousNode. No way to feature detect this.\n      * Some versions of Opera have a bug in TreeWalker#previousNode which makes\n        it skip to the wrong node.\n  \n      Rather than risk further bugs, it's easiest just to implement our own\n      (subset) of the spec in all browsers.\n  */\n\n\n  var typeToBitArray = {\n    // ELEMENT_NODE\n    1: 1,\n    // ATTRIBUTE_NODE\n    2: 2,\n    // TEXT_NODE\n    3: 4,\n    // COMMENT_NODE\n    8: 128,\n    // DOCUMENT_NODE\n    9: 256,\n    // DOCUMENT_FRAGMENT_NODE\n    11: 1024\n  };\n\n  var always = function () {\n    return true;\n  };\n\n  function TreeWalker(root, nodeType, filter) {\n    this.root = this.currentNode = root;\n    this.nodeType = nodeType;\n    this.filter = filter || always;\n  }\n\n  TreeWalker.prototype.nextNode = function () {\n    var current = this.currentNode,\n        root = this.root,\n        nodeType = this.nodeType,\n        filter = this.filter,\n        node;\n\n    while (true) {\n      node = current.firstChild;\n\n      while (!node && current) {\n        if (current === root) {\n          break;\n        }\n\n        node = current.nextSibling;\n\n        if (!node) {\n          current = current.parentNode;\n        }\n      }\n\n      if (!node) {\n        return null;\n      }\n\n      if (typeToBitArray[node.nodeType] & nodeType && filter(node)) {\n        this.currentNode = node;\n        return node;\n      }\n\n      current = node;\n    }\n  };\n\n  TreeWalker.prototype.previousNode = function () {\n    var current = this.currentNode,\n        root = this.root,\n        nodeType = this.nodeType,\n        filter = this.filter,\n        node;\n\n    while (true) {\n      if (current === root) {\n        return null;\n      }\n\n      node = current.previousSibling;\n\n      if (node) {\n        while (current = node.lastChild) {\n          node = current;\n        }\n      } else {\n        node = current.parentNode;\n      }\n\n      if (!node) {\n        return null;\n      }\n\n      if (typeToBitArray[node.nodeType] & nodeType && filter(node)) {\n        this.currentNode = node;\n        return node;\n      }\n\n      current = node;\n    }\n  }; // Previous node in post-order.\n\n\n  TreeWalker.prototype.previousPONode = function () {\n    var current = this.currentNode,\n        root = this.root,\n        nodeType = this.nodeType,\n        filter = this.filter,\n        node;\n\n    while (true) {\n      node = current.lastChild;\n\n      while (!node && current) {\n        if (current === root) {\n          break;\n        }\n\n        node = current.previousSibling;\n\n        if (!node) {\n          current = current.parentNode;\n        }\n      }\n\n      if (!node) {\n        return null;\n      }\n\n      if (typeToBitArray[node.nodeType] & nodeType && filter(node)) {\n        this.currentNode = node;\n        return node;\n      }\n\n      current = node;\n    }\n  };\n\n  var inlineNodeNames = /^(?:#text|A(?:BBR|CRONYM)?|B(?:R|D[IO])?|C(?:ITE|ODE)|D(?:ATA|EL|FN)|EM|FONT|HR|I(?:FRAME|MG|NPUT|NS)?|KBD|Q|R(?:P|T|UBY)|S(?:AMP|MALL|PAN|TR(?:IKE|ONG)|U[BP])?|TIME|U|VAR|WBR)$/;\n  var leafNodeNames = {\n    BR: 1,\n    HR: 1,\n    IFRAME: 1,\n    IMG: 1,\n    INPUT: 1\n  };\n\n  function every(nodeList, fn) {\n    var l = nodeList.length;\n\n    while (l--) {\n      if (!fn(nodeList[l])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // ---\n\n\n  var UNKNOWN = 0;\n  var INLINE = 1;\n  var BLOCK = 2;\n  var CONTAINER = 3;\n  var nodeCategoryCache = canWeakMap ? new WeakMap() : null;\n\n  function isLeaf(node) {\n    return node.nodeType === ELEMENT_NODE && !!leafNodeNames[node.nodeName];\n  }\n\n  function getNodeCategory(node) {\n    switch (node.nodeType) {\n      case TEXT_NODE:\n        return INLINE;\n\n      case ELEMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        if (canWeakMap && nodeCategoryCache.has(node)) {\n          return nodeCategoryCache.get(node);\n        }\n\n        break;\n\n      default:\n        return UNKNOWN;\n    }\n\n    var nodeCategory;\n\n    if (!every(node.childNodes, isInline)) {\n      // Malformed HTML can have block tags inside inline tags. Need to treat\n      // these as containers rather than inline. See #239.\n      nodeCategory = CONTAINER;\n    } else if (inlineNodeNames.test(node.nodeName)) {\n      nodeCategory = INLINE;\n    } else {\n      nodeCategory = BLOCK;\n    }\n\n    if (canWeakMap) {\n      nodeCategoryCache.set(node, nodeCategory);\n    }\n\n    return nodeCategory;\n  }\n\n  function isInline(node) {\n    return getNodeCategory(node) === INLINE;\n  }\n\n  function isBlock(node) {\n    return getNodeCategory(node) === BLOCK;\n  }\n\n  function isContainer(node) {\n    return getNodeCategory(node) === CONTAINER;\n  }\n\n  function getBlockWalker(node, root) {\n    var walker = new TreeWalker(root, SHOW_ELEMENT, isBlock);\n    walker.currentNode = node;\n    return walker;\n  }\n\n  function getPreviousBlock(node, root) {\n    node = getBlockWalker(node, root).previousNode();\n    return node !== root ? node : null;\n  }\n\n  function getNextBlock(node, root) {\n    node = getBlockWalker(node, root).nextNode();\n    return node !== root ? node : null;\n  }\n\n  function isEmptyBlock(block) {\n    return !block.textContent && !block.querySelector('IMG');\n  }\n\n  function areAlike(node, node2) {\n    return !isLeaf(node) && node.nodeType === node2.nodeType && node.nodeName === node2.nodeName && node.nodeName !== 'A' && node.className === node2.className && (!node.style && !node2.style || node.style.cssText === node2.style.cssText);\n  }\n\n  function hasTagAttributes(node, tag, attributes) {\n    if (node.nodeName !== tag) {\n      return false;\n    }\n\n    for (var attr in attributes) {\n      if (node.getAttribute(attr) !== attributes[attr]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getNearest(node, root, tag, attributes) {\n    while (node && node !== root) {\n      if (hasTagAttributes(node, tag, attributes)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  }\n\n  function isOrContains(parent, node) {\n    while (node) {\n      if (node === parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n\n  function getPath(node, root, config) {\n    var path = '';\n    var id, className, classNames, dir, styleNames;\n\n    if (node && node !== root) {\n      path = getPath(node.parentNode, root, config);\n\n      if (node.nodeType === ELEMENT_NODE) {\n        path += (path ? '>' : '') + node.nodeName;\n\n        if (id = node.id) {\n          path += '#' + id;\n        }\n\n        if (className = node.className.trim()) {\n          classNames = className.split(/\\s\\s*/);\n          classNames.sort();\n          path += '.';\n          path += classNames.join('.');\n        }\n\n        if (dir = node.dir) {\n          path += '[dir=' + dir + ']';\n        }\n\n        if (classNames) {\n          styleNames = config.classNames;\n\n          if (indexOf.call(classNames, styleNames.highlight) > -1) {\n            path += '[backgroundColor=' + node.style.backgroundColor.replace(/ /g, '') + ']';\n          }\n\n          if (indexOf.call(classNames, styleNames.colour) > -1) {\n            path += '[color=' + node.style.color.replace(/ /g, '') + ']';\n          }\n\n          if (indexOf.call(classNames, styleNames.fontFamily) > -1) {\n            path += '[fontFamily=' + node.style.fontFamily.replace(/ /g, '') + ']';\n          }\n\n          if (indexOf.call(classNames, styleNames.fontSize) > -1) {\n            path += '[fontSize=' + node.style.fontSize + ']';\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  function getLength(node) {\n    var nodeType = node.nodeType;\n    return nodeType === ELEMENT_NODE || nodeType === DOCUMENT_FRAGMENT_NODE ? node.childNodes.length : node.length || 0;\n  }\n\n  function detach(node) {\n    var parent = node.parentNode;\n\n    if (parent) {\n      parent.removeChild(node);\n    }\n\n    return node;\n  }\n\n  function replaceWith(node, node2) {\n    var parent = node.parentNode;\n\n    if (parent) {\n      parent.replaceChild(node2, node);\n    }\n  }\n\n  function empty(node) {\n    var frag = node.ownerDocument.createDocumentFragment(),\n        childNodes = node.childNodes,\n        l = childNodes ? childNodes.length : 0;\n\n    while (l--) {\n      frag.appendChild(node.firstChild);\n    }\n\n    return frag;\n  }\n\n  function createElement(doc, tag, props, children) {\n    var el = doc.createElement(tag),\n        attr,\n        value,\n        i,\n        l;\n\n    if (props instanceof Array) {\n      children = props;\n      props = null;\n    }\n\n    if (props) {\n      for (attr in props) {\n        value = props[attr];\n\n        if (value !== undefined) {\n          el.setAttribute(attr, props[attr]);\n        }\n      }\n    }\n\n    if (children) {\n      for (i = 0, l = children.length; i < l; i += 1) {\n        el.appendChild(children[i]);\n      }\n    }\n\n    return el;\n  }\n\n  function fixCursor(node, root) {\n    // In Webkit and Gecko, block level elements are collapsed and\n    // unfocussable if they have no content. To remedy this, a <BR> must be\n    // inserted. In Opera and IE, we just need a textnode in order for the\n    // cursor to appear.\n    var self = root.__squire__;\n    var doc = node.ownerDocument;\n    var originalNode = node;\n    var fixer, child;\n\n    if (node === root) {\n      if (!(child = node.firstChild) || child.nodeName === 'BR') {\n        fixer = self.createDefaultBlock();\n\n        if (child) {\n          node.replaceChild(fixer, child);\n        } else {\n          node.appendChild(fixer);\n        }\n\n        node = fixer;\n        fixer = null;\n      }\n    }\n\n    if (node.nodeType === TEXT_NODE) {\n      return originalNode;\n    }\n\n    if (isInline(node)) {\n      child = node.firstChild;\n\n      while (cantFocusEmptyTextNodes && child && child.nodeType === TEXT_NODE && !child.data) {\n        node.removeChild(child);\n        child = node.firstChild;\n      }\n\n      if (!child) {\n        if (cantFocusEmptyTextNodes) {\n          fixer = doc.createTextNode(ZWS);\n\n          self._didAddZWS();\n        } else {\n          fixer = doc.createTextNode('');\n        }\n      }\n    } else {\n      if (useTextFixer) {\n        while (node.nodeType !== TEXT_NODE && !isLeaf(node)) {\n          child = node.firstChild;\n\n          if (!child) {\n            fixer = doc.createTextNode('');\n            break;\n          }\n\n          node = child;\n        }\n\n        if (node.nodeType === TEXT_NODE) {\n          // Opera will collapse the block element if it contains\n          // just spaces (but not if it contains no data at all).\n          if (/^ +$/.test(node.data)) {\n            node.data = '';\n          }\n        } else if (isLeaf(node)) {\n          node.parentNode.insertBefore(doc.createTextNode(''), node);\n        }\n      } else if (!node.querySelector('BR')) {\n        fixer = createElement(doc, 'BR');\n\n        while ((child = node.lastElementChild) && !isInline(child)) {\n          node = child;\n        }\n      }\n    }\n\n    if (fixer) {\n      try {\n        node.appendChild(fixer);\n      } catch (error) {\n        self.didError({\n          name: 'Squire: fixCursor – ' + error,\n          message: 'Parent: ' + node.nodeName + '/' + node.innerHTML + ' appendChild: ' + fixer.nodeName\n        });\n      }\n    }\n\n    return originalNode;\n  } // Recursively examine container nodes and wrap any inline children.\n\n\n  function fixContainer(container, root) {\n    var children = container.childNodes;\n    var doc = container.ownerDocument;\n    var wrapper = null;\n    var i, l, child, isBR;\n    var config = root.__squire__._config;\n\n    for (i = 0, l = children.length; i < l; i += 1) {\n      child = children[i];\n      isBR = child.nodeName === 'BR';\n\n      if (!isBR && isInline(child)) {\n        if (!wrapper) {\n          wrapper = createElement(doc, config.blockTag, config.blockAttributes);\n        }\n\n        wrapper.appendChild(child);\n        i -= 1;\n        l -= 1;\n      } else if (isBR || wrapper) {\n        if (!wrapper) {\n          wrapper = createElement(doc, config.blockTag, config.blockAttributes);\n        }\n\n        fixCursor(wrapper, root);\n\n        if (isBR) {\n          container.replaceChild(wrapper, child);\n        } else {\n          container.insertBefore(wrapper, child);\n          i += 1;\n          l += 1;\n        }\n\n        wrapper = null;\n      }\n\n      if (isContainer(child)) {\n        fixContainer(child, root);\n      }\n    }\n\n    if (wrapper) {\n      container.appendChild(fixCursor(wrapper, root));\n    }\n\n    return container;\n  }\n\n  function split(node, offset, stopNode, root) {\n    var nodeType = node.nodeType,\n        parent,\n        clone,\n        next;\n\n    if (nodeType === TEXT_NODE && node !== stopNode) {\n      return split(node.parentNode, node.splitText(offset), stopNode, root);\n    }\n\n    if (nodeType === ELEMENT_NODE) {\n      if (typeof offset === 'number') {\n        offset = offset < node.childNodes.length ? node.childNodes[offset] : null;\n      }\n\n      if (node === stopNode) {\n        return offset;\n      } // Clone node without children\n\n\n      parent = node.parentNode;\n      clone = node.cloneNode(false); // Add right-hand siblings to the clone\n\n      while (offset) {\n        next = offset.nextSibling;\n        clone.appendChild(offset);\n        offset = next;\n      } // Maintain li numbering if inside a quote.\n\n\n      if (node.nodeName === 'OL' && getNearest(node, root, 'BLOCKQUOTE')) {\n        clone.start = (+node.start || 1) + node.childNodes.length - 1;\n      } // DO NOT NORMALISE. This may undo the fixCursor() call\n      // of a node lower down the tree!\n      // We need something in the element in order for the cursor to appear.\n\n\n      fixCursor(node, root);\n      fixCursor(clone, root); // Inject clone after original node\n\n      if (next = node.nextSibling) {\n        parent.insertBefore(clone, next);\n      } else {\n        parent.appendChild(clone);\n      } // Keep on splitting up the tree\n\n\n      return split(parent, clone, stopNode, root);\n    }\n\n    return offset;\n  }\n\n  function _mergeInlines(node, fakeRange) {\n    var children = node.childNodes,\n        l = children.length,\n        frags = [],\n        child,\n        prev,\n        len;\n\n    while (l--) {\n      child = children[l];\n      prev = l && children[l - 1];\n\n      if (l && isInline(child) && areAlike(child, prev) && !leafNodeNames[child.nodeName]) {\n        if (fakeRange.startContainer === child) {\n          fakeRange.startContainer = prev;\n          fakeRange.startOffset += getLength(prev);\n        }\n\n        if (fakeRange.endContainer === child) {\n          fakeRange.endContainer = prev;\n          fakeRange.endOffset += getLength(prev);\n        }\n\n        if (fakeRange.startContainer === node) {\n          if (fakeRange.startOffset > l) {\n            fakeRange.startOffset -= 1;\n          } else if (fakeRange.startOffset === l) {\n            fakeRange.startContainer = prev;\n            fakeRange.startOffset = getLength(prev);\n          }\n        }\n\n        if (fakeRange.endContainer === node) {\n          if (fakeRange.endOffset > l) {\n            fakeRange.endOffset -= 1;\n          } else if (fakeRange.endOffset === l) {\n            fakeRange.endContainer = prev;\n            fakeRange.endOffset = getLength(prev);\n          }\n        }\n\n        detach(child);\n\n        if (child.nodeType === TEXT_NODE) {\n          prev.appendData(child.data);\n        } else {\n          frags.push(empty(child));\n        }\n      } else if (child.nodeType === ELEMENT_NODE) {\n        len = frags.length;\n\n        while (len--) {\n          child.appendChild(frags.pop());\n        }\n\n        _mergeInlines(child, fakeRange);\n      }\n    }\n  }\n\n  function mergeInlines(node, range) {\n    if (node.nodeType === TEXT_NODE) {\n      node = node.parentNode;\n    }\n\n    if (node.nodeType === ELEMENT_NODE) {\n      var fakeRange = {\n        startContainer: range.startContainer,\n        startOffset: range.startOffset,\n        endContainer: range.endContainer,\n        endOffset: range.endOffset\n      };\n\n      _mergeInlines(node, fakeRange);\n\n      range.setStart(fakeRange.startContainer, fakeRange.startOffset);\n      range.setEnd(fakeRange.endContainer, fakeRange.endOffset);\n    }\n  }\n\n  function mergeWithBlock(block, next, range, root) {\n    var container = next;\n    var parent, last, offset;\n\n    while ((parent = container.parentNode) && parent !== root && parent.nodeType === ELEMENT_NODE && parent.childNodes.length === 1) {\n      container = parent;\n    }\n\n    detach(container);\n    offset = block.childNodes.length; // Remove extra <BR> fixer if present.\n\n    last = block.lastChild;\n\n    if (last && last.nodeName === 'BR') {\n      block.removeChild(last);\n      offset -= 1;\n    }\n\n    block.appendChild(empty(next));\n    range.setStart(block, offset);\n    range.collapse(true);\n    mergeInlines(block, range); // Opera inserts a BR if you delete the last piece of text\n    // in a block-level element. Unfortunately, it then gets\n    // confused when setting the selection subsequently and\n    // refuses to accept the range that finishes just before the\n    // BR. Removing the BR fixes the bug.\n    // Steps to reproduce bug: Type \"a-b-c\" (where - is return)\n    // then backspace twice. The cursor goes to the top instead\n    // of after \"b\".\n\n    if (isPresto && (last = block.lastChild) && last.nodeName === 'BR') {\n      block.removeChild(last);\n    }\n  }\n\n  function mergeContainers(node, root) {\n    var prev = node.previousSibling,\n        first = node.firstChild,\n        doc = node.ownerDocument,\n        isListItem = node.nodeName === 'LI',\n        needsFix,\n        block; // Do not merge LIs, unless it only contains a UL\n\n    if (isListItem && (!first || !/^[OU]L$/.test(first.nodeName))) {\n      return;\n    }\n\n    if (prev && areAlike(prev, node)) {\n      if (!isContainer(prev)) {\n        if (isListItem) {\n          block = createElement(doc, 'DIV');\n          block.appendChild(empty(prev));\n          prev.appendChild(block);\n        } else {\n          return;\n        }\n      }\n\n      detach(node);\n      needsFix = !isContainer(node);\n      prev.appendChild(empty(node));\n\n      if (needsFix) {\n        fixContainer(prev, root);\n      }\n\n      if (first) {\n        mergeContainers(first, root);\n      }\n    } else if (isListItem) {\n      prev = createElement(doc, 'DIV');\n      node.insertBefore(prev, first);\n      fixCursor(prev, root);\n    }\n  }\n\n  var getNodeBefore = function (node, offset) {\n    var children = node.childNodes;\n\n    while (offset && node.nodeType === ELEMENT_NODE) {\n      node = children[offset - 1];\n      children = node.childNodes;\n      offset = children.length;\n    }\n\n    return node;\n  };\n\n  var getNodeAfter = function (node, offset) {\n    if (node.nodeType === ELEMENT_NODE) {\n      var children = node.childNodes;\n\n      if (offset < children.length) {\n        node = children[offset];\n      } else {\n        while (node && !node.nextSibling) {\n          node = node.parentNode;\n        }\n\n        if (node) {\n          node = node.nextSibling;\n        }\n      }\n    }\n\n    return node;\n  }; // ---\n\n\n  var insertNodeInRange = function (range, node) {\n    // Insert at start.\n    var startContainer = range.startContainer,\n        startOffset = range.startOffset,\n        endContainer = range.endContainer,\n        endOffset = range.endOffset,\n        parent,\n        children,\n        childCount,\n        afterSplit; // If part way through a text node, split it.\n\n    if (startContainer.nodeType === TEXT_NODE) {\n      parent = startContainer.parentNode;\n      children = parent.childNodes;\n\n      if (startOffset === startContainer.length) {\n        startOffset = indexOf.call(children, startContainer) + 1;\n\n        if (range.collapsed) {\n          endContainer = parent;\n          endOffset = startOffset;\n        }\n      } else {\n        if (startOffset) {\n          afterSplit = startContainer.splitText(startOffset);\n\n          if (endContainer === startContainer) {\n            endOffset -= startOffset;\n            endContainer = afterSplit;\n          } else if (endContainer === parent) {\n            endOffset += 1;\n          }\n\n          startContainer = afterSplit;\n        }\n\n        startOffset = indexOf.call(children, startContainer);\n      }\n\n      startContainer = parent;\n    } else {\n      children = startContainer.childNodes;\n    }\n\n    childCount = children.length;\n\n    if (startOffset === childCount) {\n      startContainer.appendChild(node);\n    } else {\n      startContainer.insertBefore(node, children[startOffset]);\n    }\n\n    if (startContainer === endContainer) {\n      endOffset += children.length - childCount;\n    }\n\n    range.setStart(startContainer, startOffset);\n    range.setEnd(endContainer, endOffset);\n  };\n\n  var extractContentsOfRange = function (range, common, root) {\n    var startContainer = range.startContainer,\n        startOffset = range.startOffset,\n        endContainer = range.endContainer,\n        endOffset = range.endOffset;\n\n    if (!common) {\n      common = range.commonAncestorContainer;\n    }\n\n    if (common.nodeType === TEXT_NODE) {\n      common = common.parentNode;\n    }\n\n    var endNode = split(endContainer, endOffset, common, root),\n        startNode = split(startContainer, startOffset, common, root),\n        frag = common.ownerDocument.createDocumentFragment(),\n        next,\n        before,\n        after,\n        beforeText,\n        afterText; // End node will be null if at end of child nodes list.\n\n    while (startNode !== endNode) {\n      next = startNode.nextSibling;\n      frag.appendChild(startNode);\n      startNode = next;\n    }\n\n    startContainer = common;\n    startOffset = endNode ? indexOf.call(common.childNodes, endNode) : common.childNodes.length; // Merge text nodes if adjacent. IE10 in particular will not focus\n    // between two text nodes\n\n    after = common.childNodes[startOffset];\n    before = after && after.previousSibling;\n\n    if (before && before.nodeType === TEXT_NODE && after.nodeType === TEXT_NODE) {\n      startContainer = before;\n      startOffset = before.length;\n      beforeText = before.data;\n      afterText = after.data; // If we now have two adjacent spaces, the second one needs to become\n      // a nbsp, otherwise the browser will swallow it due to HTML whitespace\n      // collapsing.\n\n      if (beforeText.charAt(beforeText.length - 1) === ' ' && afterText.charAt(0) === ' ') {\n        afterText = ' ' + afterText.slice(1); // nbsp\n      }\n\n      before.appendData(afterText);\n      detach(after);\n    }\n\n    range.setStart(startContainer, startOffset);\n    range.collapse(true);\n    fixCursor(common, root);\n    return frag;\n  };\n\n  var deleteContentsOfRange = function (range, root) {\n    var startBlock = getStartBlockOfRange(range, root);\n    var endBlock = getEndBlockOfRange(range, root);\n    var needsMerge = startBlock !== endBlock;\n    var frag, child; // Move boundaries up as much as possible without exiting block,\n    // to reduce need to split.\n\n    moveRangeBoundariesDownTree(range);\n    moveRangeBoundariesUpTree(range, startBlock, endBlock, root); // Remove selected range\n\n    frag = extractContentsOfRange(range, null, root); // Move boundaries back down tree as far as possible.\n\n    moveRangeBoundariesDownTree(range); // If we split into two different blocks, merge the blocks.\n\n    if (needsMerge) {\n      // endBlock will have been split, so need to refetch\n      endBlock = getEndBlockOfRange(range, root);\n\n      if (startBlock && endBlock && startBlock !== endBlock) {\n        mergeWithBlock(startBlock, endBlock, range, root);\n      }\n    } // Ensure block has necessary children\n\n\n    if (startBlock) {\n      fixCursor(startBlock, root);\n    } // Ensure root has a block-level element in it.\n\n\n    child = root.firstChild;\n\n    if (!child || child.nodeName === 'BR') {\n      fixCursor(root, root);\n      range.selectNodeContents(root.firstChild);\n    } else {\n      range.collapse(true);\n    }\n\n    return frag;\n  }; // ---\n  // Contents of range will be deleted.\n  // After method, range will be around inserted content\n\n\n  var insertTreeFragmentIntoRange = function (range, frag, root) {\n    var node, block, blockContentsAfterSplit, stopPoint, container, offset;\n    var replaceBlock, firstBlockInFrag, nodeAfterSplit, nodeBeforeSplit;\n    var tempRange; // Fixup content: ensure no top-level inline, and add cursor fix elements.\n\n    fixContainer(frag, root);\n    node = frag;\n\n    while (node = getNextBlock(node, root)) {\n      fixCursor(node, root);\n    } // Delete any selected content.\n\n\n    if (!range.collapsed) {\n      deleteContentsOfRange(range, root);\n    } // Move range down into text nodes.\n\n\n    moveRangeBoundariesDownTree(range);\n    range.collapse(false); // collapse to end\n    // Where will we split up to? First blockquote parent, otherwise root.\n\n    stopPoint = getNearest(range.endContainer, root, 'BLOCKQUOTE') || root; // Merge the contents of the first block in the frag with the focused block.\n    // If there are contents in the block after the focus point, collect this\n    // up to insert in the last block later. If the block is empty, replace\n    // it instead of merging.\n\n    block = getStartBlockOfRange(range, root);\n    firstBlockInFrag = getNextBlock(frag, frag);\n    replaceBlock = !!block && isEmptyBlock(block);\n\n    if (block && firstBlockInFrag && !replaceBlock && // Don't merge table cells or PRE elements into block\n    !getNearest(firstBlockInFrag, frag, 'PRE') && !getNearest(firstBlockInFrag, frag, 'TABLE')) {\n      moveRangeBoundariesUpTree(range, block, block, root);\n      range.collapse(true); // collapse to start\n\n      container = range.endContainer;\n      offset = range.endOffset; // Remove trailing <br> – we don't want this considered content to be\n      // inserted again later\n\n      cleanupBRs(block, root, false);\n\n      if (isInline(container)) {\n        // Split up to block parent.\n        nodeAfterSplit = split(container, offset, getPreviousBlock(container, root), root);\n        container = nodeAfterSplit.parentNode;\n        offset = indexOf.call(container.childNodes, nodeAfterSplit);\n      }\n\n      if (\n      /*isBlock( container ) && */\n      offset !== getLength(container)) {\n        // Collect any inline contents of the block after the range point\n        blockContentsAfterSplit = root.ownerDocument.createDocumentFragment();\n\n        while (node = container.childNodes[offset]) {\n          blockContentsAfterSplit.appendChild(node);\n        }\n      } // And merge the first block in.\n\n\n      mergeWithBlock(container, firstBlockInFrag, range, root); // And where we will insert\n\n      offset = indexOf.call(container.parentNode.childNodes, container) + 1;\n      container = container.parentNode;\n      range.setEnd(container, offset);\n    } // Is there still any content in the fragment?\n\n\n    if (getLength(frag)) {\n      if (replaceBlock) {\n        range.setEndBefore(block);\n        range.collapse(false);\n        detach(block);\n      }\n\n      moveRangeBoundariesUpTree(range, stopPoint, stopPoint, root); // Now split after block up to blockquote (if a parent) or root\n\n      nodeAfterSplit = split(range.endContainer, range.endOffset, stopPoint, root);\n      nodeBeforeSplit = nodeAfterSplit ? nodeAfterSplit.previousSibling : stopPoint.lastChild;\n      stopPoint.insertBefore(frag, nodeAfterSplit);\n\n      if (nodeAfterSplit) {\n        range.setEndBefore(nodeAfterSplit);\n      } else {\n        range.setEnd(stopPoint, getLength(stopPoint));\n      }\n\n      block = getEndBlockOfRange(range, root); // Get a reference that won't be invalidated if we merge containers.\n\n      moveRangeBoundariesDownTree(range);\n      container = range.endContainer;\n      offset = range.endOffset; // Merge inserted containers with edges of split\n\n      if (nodeAfterSplit && isContainer(nodeAfterSplit)) {\n        mergeContainers(nodeAfterSplit, root);\n      }\n\n      nodeAfterSplit = nodeBeforeSplit && nodeBeforeSplit.nextSibling;\n\n      if (nodeAfterSplit && isContainer(nodeAfterSplit)) {\n        mergeContainers(nodeAfterSplit, root);\n      }\n\n      range.setEnd(container, offset);\n    } // Insert inline content saved from before.\n\n\n    if (blockContentsAfterSplit) {\n      tempRange = range.cloneRange();\n      mergeWithBlock(block, blockContentsAfterSplit, tempRange, root);\n      range.setEnd(tempRange.endContainer, tempRange.endOffset);\n    }\n\n    moveRangeBoundariesDownTree(range);\n  }; // ---\n\n\n  var isNodeContainedInRange = function (range, node, partial) {\n    var nodeRange = node.ownerDocument.createRange();\n    nodeRange.selectNode(node);\n\n    if (partial) {\n      // Node must not finish before range starts or start after range\n      // finishes.\n      var nodeEndBeforeStart = range.compareBoundaryPoints(END_TO_START, nodeRange) > -1,\n          nodeStartAfterEnd = range.compareBoundaryPoints(START_TO_END, nodeRange) < 1;\n      return !nodeEndBeforeStart && !nodeStartAfterEnd;\n    } else {\n      // Node must start after range starts and finish before range\n      // finishes\n      var nodeStartAfterStart = range.compareBoundaryPoints(START_TO_START, nodeRange) < 1,\n          nodeEndBeforeEnd = range.compareBoundaryPoints(END_TO_END, nodeRange) > -1;\n      return nodeStartAfterStart && nodeEndBeforeEnd;\n    }\n  };\n\n  var moveRangeBoundariesDownTree = function (range) {\n    var startContainer = range.startContainer,\n        startOffset = range.startOffset,\n        endContainer = range.endContainer,\n        endOffset = range.endOffset,\n        maySkipBR = true,\n        child;\n\n    while (startContainer.nodeType !== TEXT_NODE) {\n      child = startContainer.childNodes[startOffset];\n\n      if (!child || isLeaf(child)) {\n        break;\n      }\n\n      startContainer = child;\n      startOffset = 0;\n    }\n\n    if (endOffset) {\n      while (endContainer.nodeType !== TEXT_NODE) {\n        child = endContainer.childNodes[endOffset - 1];\n\n        if (!child || isLeaf(child)) {\n          if (maySkipBR && child && child.nodeName === 'BR') {\n            endOffset -= 1;\n            maySkipBR = false;\n            continue;\n          }\n\n          break;\n        }\n\n        endContainer = child;\n        endOffset = getLength(endContainer);\n      }\n    } else {\n      while (endContainer.nodeType !== TEXT_NODE) {\n        child = endContainer.firstChild;\n\n        if (!child || isLeaf(child)) {\n          break;\n        }\n\n        endContainer = child;\n      }\n    } // If collapsed, this algorithm finds the nearest text node positions\n    // *outside* the range rather than inside, but also it flips which is\n    // assigned to which.\n\n\n    if (range.collapsed) {\n      range.setStart(endContainer, endOffset);\n      range.setEnd(startContainer, startOffset);\n    } else {\n      range.setStart(startContainer, startOffset);\n      range.setEnd(endContainer, endOffset);\n    }\n  };\n\n  var moveRangeBoundariesUpTree = function (range, startMax, endMax, root) {\n    var startContainer = range.startContainer;\n    var startOffset = range.startOffset;\n    var endContainer = range.endContainer;\n    var endOffset = range.endOffset;\n    var maySkipBR = true;\n    var parent;\n\n    if (!startMax) {\n      startMax = range.commonAncestorContainer;\n    }\n\n    if (!endMax) {\n      endMax = startMax;\n    }\n\n    while (!startOffset && startContainer !== startMax && startContainer !== root) {\n      parent = startContainer.parentNode;\n      startOffset = indexOf.call(parent.childNodes, startContainer);\n      startContainer = parent;\n    }\n\n    while (true) {\n      if (maySkipBR && endContainer.nodeType !== TEXT_NODE && endContainer.childNodes[endOffset] && endContainer.childNodes[endOffset].nodeName === 'BR') {\n        endOffset += 1;\n        maySkipBR = false;\n      }\n\n      if (endContainer === endMax || endContainer === root || endOffset !== getLength(endContainer)) {\n        break;\n      }\n\n      parent = endContainer.parentNode;\n      endOffset = indexOf.call(parent.childNodes, endContainer) + 1;\n      endContainer = parent;\n    }\n\n    range.setStart(startContainer, startOffset);\n    range.setEnd(endContainer, endOffset);\n  }; // Returns the first block at least partially contained by the range,\n  // or null if no block is contained by the range.\n\n\n  var getStartBlockOfRange = function (range, root) {\n    var container = range.startContainer,\n        block; // If inline, get the containing block.\n\n    if (isInline(container)) {\n      block = getPreviousBlock(container, root);\n    } else if (container !== root && isBlock(container)) {\n      block = container;\n    } else {\n      block = getNodeBefore(container, range.startOffset);\n      block = getNextBlock(block, root);\n    } // Check the block actually intersects the range\n\n\n    return block && isNodeContainedInRange(range, block, true) ? block : null;\n  }; // Returns the last block at least partially contained by the range,\n  // or null if no block is contained by the range.\n\n\n  var getEndBlockOfRange = function (range, root) {\n    var container = range.endContainer,\n        block,\n        child; // If inline, get the containing block.\n\n    if (isInline(container)) {\n      block = getPreviousBlock(container, root);\n    } else if (container !== root && isBlock(container)) {\n      block = container;\n    } else {\n      block = getNodeAfter(container, range.endOffset);\n\n      if (!block || !isOrContains(root, block)) {\n        block = root;\n\n        while (child = block.lastChild) {\n          block = child;\n        }\n      }\n\n      block = getPreviousBlock(block, root);\n    } // Check the block actually intersects the range\n\n\n    return block && isNodeContainedInRange(range, block, true) ? block : null;\n  };\n\n  var contentWalker = new TreeWalker(null, SHOW_TEXT | SHOW_ELEMENT, function (node) {\n    return node.nodeType === TEXT_NODE ? notWS.test(node.data) : node.nodeName === 'IMG';\n  });\n\n  var rangeDoesStartAtBlockBoundary = function (range, root) {\n    var startContainer = range.startContainer;\n    var startOffset = range.startOffset;\n    var nodeAfterCursor; // If in the middle or end of a text node, we're not at the boundary.\n\n    contentWalker.root = null;\n\n    if (startContainer.nodeType === TEXT_NODE) {\n      if (startOffset) {\n        return false;\n      }\n\n      nodeAfterCursor = startContainer;\n    } else {\n      nodeAfterCursor = getNodeAfter(startContainer, startOffset);\n\n      if (nodeAfterCursor && !isOrContains(root, nodeAfterCursor)) {\n        nodeAfterCursor = null;\n      } // The cursor was right at the end of the document\n\n\n      if (!nodeAfterCursor) {\n        nodeAfterCursor = getNodeBefore(startContainer, startOffset);\n\n        if (nodeAfterCursor.nodeType === TEXT_NODE && nodeAfterCursor.length) {\n          return false;\n        }\n      }\n    } // Otherwise, look for any previous content in the same block.\n\n\n    contentWalker.currentNode = nodeAfterCursor;\n    contentWalker.root = getStartBlockOfRange(range, root);\n    return !contentWalker.previousNode();\n  };\n\n  var rangeDoesEndAtBlockBoundary = function (range, root) {\n    var endContainer = range.endContainer,\n        endOffset = range.endOffset,\n        length; // If in a text node with content, and not at the end, we're not\n    // at the boundary\n\n    contentWalker.root = null;\n\n    if (endContainer.nodeType === TEXT_NODE) {\n      length = endContainer.data.length;\n\n      if (length && endOffset < length) {\n        return false;\n      }\n\n      contentWalker.currentNode = endContainer;\n    } else {\n      contentWalker.currentNode = getNodeBefore(endContainer, endOffset);\n    } // Otherwise, look for any further content in the same block.\n\n\n    contentWalker.root = getEndBlockOfRange(range, root);\n    return !contentWalker.nextNode();\n  };\n\n  var expandRangeToBlockBoundaries = function (range, root) {\n    var start = getStartBlockOfRange(range, root),\n        end = getEndBlockOfRange(range, root),\n        parent;\n\n    if (start && end) {\n      parent = start.parentNode;\n      range.setStart(parent, indexOf.call(parent.childNodes, start));\n      parent = end.parentNode;\n      range.setEnd(parent, indexOf.call(parent.childNodes, end) + 1);\n    }\n  };\n\n  var keys = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    37: 'left',\n    39: 'right',\n    46: 'delete',\n    219: '[',\n    221: ']'\n  }; // Ref: http://unixpapa.com/js/key.html\n\n  var onKey = function (event) {\n    var code = event.keyCode,\n        key = keys[code],\n        modifiers = '',\n        range = this.getSelection();\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    if (!key) {\n      key = String.fromCharCode(code).toLowerCase(); // Only reliable for letters and numbers\n\n      if (!/^[A-Za-z0-9]$/.test(key)) {\n        key = '';\n      }\n    } // On keypress, delete and '.' both have event.keyCode 46\n    // Must check event.which to differentiate.\n\n\n    if (isPresto && event.which === 46) {\n      key = '.';\n    } // Function keys\n\n\n    if (111 < code && code < 124) {\n      key = 'f' + (code - 111);\n    } // We need to apply the backspace/delete handlers regardless of\n    // control key modifiers.\n\n\n    if (key !== 'backspace' && key !== 'delete') {\n      if (event.altKey) {\n        modifiers += 'alt-';\n      }\n\n      if (event.ctrlKey) {\n        modifiers += 'ctrl-';\n      }\n\n      if (event.metaKey) {\n        modifiers += 'meta-';\n      }\n    } // However, on Windows, shift-delete is apparently \"cut\" (WTF right?), so\n    // we want to let the browser handle shift-delete.\n\n\n    if (event.shiftKey) {\n      modifiers += 'shift-';\n    }\n\n    key = modifiers + key;\n\n    if (this._keyHandlers[key]) {\n      this._keyHandlers[key](this, event, range); // !event.isComposing stops us from blatting Kana-Kanji conversion in Safari\n\n    } else if (!range.collapsed && !event.isComposing && !event.ctrlKey && !event.metaKey && (event.key || key).length === 1) {\n      // Record undo checkpoint.\n      this.saveUndoState(range); // Delete the selection\n\n      deleteContentsOfRange(range, this._root);\n\n      this._ensureBottomLine();\n\n      this.setSelection(range);\n\n      this._updatePath(range, true);\n    }\n  };\n\n  var mapKeyTo = function (method) {\n    return function (self, event) {\n      event.preventDefault();\n      self[method]();\n    };\n  };\n\n  var mapKeyToFormat = function (tag, remove) {\n    remove = remove || null;\n    return function (self, event) {\n      event.preventDefault();\n      var range = self.getSelection();\n\n      if (self.hasFormat(tag, null, range)) {\n        self.changeFormat(null, {\n          tag: tag\n        }, range);\n      } else {\n        self.changeFormat({\n          tag: tag\n        }, remove, range);\n      }\n    };\n  }; // If you delete the content inside a span with a font styling, Webkit will\n  // replace it with a <font> tag (!). If you delete all the text inside a\n  // link in Opera, it won't delete the link. Let's make things consistent. If\n  // you delete all text inside an inline tag, remove the inline tag.\n\n\n  var afterDelete = function (self, range) {\n    try {\n      if (!range) {\n        range = self.getSelection();\n      }\n\n      var node = range.startContainer,\n          parent; // Climb the tree from the focus point while we are inside an empty\n      // inline element\n\n      if (node.nodeType === TEXT_NODE) {\n        node = node.parentNode;\n      }\n\n      parent = node;\n\n      while (isInline(parent) && (!parent.textContent || parent.textContent === ZWS)) {\n        node = parent;\n        parent = node.parentNode;\n      } // If focused in empty inline element\n\n\n      if (node !== parent) {\n        // Move focus to just before empty inline(s)\n        range.setStart(parent, indexOf.call(parent.childNodes, node));\n        range.collapse(true); // Remove empty inline(s)\n\n        parent.removeChild(node); // Fix cursor in block\n\n        if (!isBlock(parent)) {\n          parent = getPreviousBlock(parent, self._root);\n        }\n\n        fixCursor(parent, self._root); // Move cursor into text node\n\n        moveRangeBoundariesDownTree(range);\n      } // If you delete the last character in the sole <div> in Chrome,\n      // it removes the div and replaces it with just a <br> inside the\n      // root. Detach the <br>; the _ensureBottomLine call will insert a new\n      // block.\n\n\n      if (node === self._root && (node = node.firstChild) && node.nodeName === 'BR') {\n        detach(node);\n      }\n\n      self._ensureBottomLine();\n\n      self.setSelection(range);\n\n      self._updatePath(range, true);\n    } catch (error) {\n      self.didError(error);\n    }\n  };\n\n  var keyHandlers = {\n    enter: function (self, event, range) {\n      var root = self._root;\n      var block, parent, node, offset, nodeAfterSplit; // We handle this ourselves\n\n      event.preventDefault(); // Save undo checkpoint and add any links in the preceding section.\n      // Remove any zws so we don't think there's content in an empty\n      // block.\n\n      self._recordUndoState(range);\n\n      addLinks(range.startContainer, root, self);\n\n      self._removeZWS();\n\n      self._getRangeAndRemoveBookmark(range); // Selected text is overwritten, therefore delete the contents\n      // to collapse selection.\n\n\n      if (!range.collapsed) {\n        deleteContentsOfRange(range, root);\n      }\n\n      block = getStartBlockOfRange(range, root); // Inside a PRE, insert literal newline, unless on blank line.\n\n      if (block && (parent = getNearest(block, root, 'PRE'))) {\n        moveRangeBoundariesDownTree(range);\n        node = range.startContainer;\n        offset = range.startOffset;\n\n        if (node.nodeType !== TEXT_NODE) {\n          node = self._doc.createTextNode('');\n          parent.insertBefore(node, parent.firstChild);\n        } // If blank line: split and insert default block\n\n\n        if (!event.shiftKey && (node.data.charAt(offset - 1) === '\\n' || rangeDoesStartAtBlockBoundary(range, root)) && (node.data.charAt(offset) === '\\n' || rangeDoesEndAtBlockBoundary(range, root))) {\n          node.deleteData(offset && offset - 1, offset ? 2 : 1);\n          nodeAfterSplit = split(node, offset && offset - 1, root, root);\n          node = nodeAfterSplit.previousSibling;\n\n          if (!node.textContent) {\n            detach(node);\n          }\n\n          node = self.createDefaultBlock();\n          nodeAfterSplit.parentNode.insertBefore(node, nodeAfterSplit);\n\n          if (!nodeAfterSplit.textContent) {\n            detach(nodeAfterSplit);\n          }\n\n          range.setStart(node, 0);\n        } else {\n          node.insertData(offset, '\\n');\n          fixCursor(parent, root); // Firefox bug: if you set the selection in the text node after\n          // the new line, it draws the cursor before the line break still\n          // but if you set the selection to the equivalent position\n          // in the parent, it works.\n\n          if (node.length === offset + 1) {\n            range.setStartAfter(node);\n          } else {\n            range.setStart(node, offset + 1);\n          }\n        }\n\n        range.collapse(true);\n        self.setSelection(range);\n\n        self._updatePath(range, true);\n\n        self._docWasChanged();\n\n        return;\n      } // If this is a malformed bit of document or in a table;\n      // just play it safe and insert a <br>.\n\n\n      if (!block || event.shiftKey || /^T[HD]$/.test(block.nodeName)) {\n        // If inside an <a>, move focus out\n        parent = getNearest(range.endContainer, root, 'A');\n\n        if (parent) {\n          parent = parent.parentNode;\n          moveRangeBoundariesUpTree(range, parent, parent, root);\n          range.collapse(false);\n        }\n\n        insertNodeInRange(range, self.createElement('BR'));\n        range.collapse(false);\n        self.setSelection(range);\n\n        self._updatePath(range, true);\n\n        return;\n      } // If in a list, we'll split the LI instead.\n\n\n      if (parent = getNearest(block, root, 'LI')) {\n        block = parent;\n      }\n\n      if (isEmptyBlock(block)) {\n        // Break list\n        if (getNearest(block, root, 'UL') || getNearest(block, root, 'OL')) {\n          return self.decreaseListLevel(range);\n        } // Break blockquote\n        else if (getNearest(block, root, 'BLOCKQUOTE')) {\n            return self.modifyBlocks(removeBlockQuote, range);\n          }\n      } // Otherwise, split at cursor point.\n\n\n      nodeAfterSplit = splitBlock(self, block, range.startContainer, range.startOffset); // Clean up any empty inlines if we hit enter at the beginning of the\n      // block\n\n      removeZWS(block);\n      removeEmptyInlines(block);\n      fixCursor(block, root); // Focus cursor\n      // If there's a <b>/<i> etc. at the beginning of the split\n      // make sure we focus inside it.\n\n      while (nodeAfterSplit.nodeType === ELEMENT_NODE) {\n        var child = nodeAfterSplit.firstChild,\n            next; // Don't continue links over a block break; unlikely to be the\n        // desired outcome.\n\n        if (nodeAfterSplit.nodeName === 'A' && (!nodeAfterSplit.textContent || nodeAfterSplit.textContent === ZWS)) {\n          child = self._doc.createTextNode('');\n          replaceWith(nodeAfterSplit, child);\n          nodeAfterSplit = child;\n          break;\n        }\n\n        while (child && child.nodeType === TEXT_NODE && !child.data) {\n          next = child.nextSibling;\n\n          if (!next || next.nodeName === 'BR') {\n            break;\n          }\n\n          detach(child);\n          child = next;\n        } // 'BR's essentially don't count; they're a browser hack.\n        // If you try to select the contents of a 'BR', FF will not let\n        // you type anything!\n\n\n        if (!child || child.nodeName === 'BR' || child.nodeType === TEXT_NODE && !isPresto) {\n          break;\n        }\n\n        nodeAfterSplit = child;\n      }\n\n      range = self.createRange(nodeAfterSplit, 0);\n      self.setSelection(range);\n\n      self._updatePath(range, true);\n    },\n    'shift-enter': function (self, event, range) {\n      return self._keyHandlers.enter(self, event, range);\n    },\n    backspace: function (self, event, range) {\n      var root = self._root;\n\n      self._removeZWS(); // Record undo checkpoint.\n\n\n      self.saveUndoState(range); // If not collapsed, delete contents\n\n      if (!range.collapsed) {\n        event.preventDefault();\n        deleteContentsOfRange(range, root);\n        afterDelete(self, range);\n      } // If at beginning of block, merge with previous\n      else if (rangeDoesStartAtBlockBoundary(range, root)) {\n          event.preventDefault();\n          var current = getStartBlockOfRange(range, root);\n          var previous;\n\n          if (!current) {\n            return;\n          } // In case inline data has somehow got between blocks.\n\n\n          fixContainer(current.parentNode, root); // Now get previous block\n\n          previous = getPreviousBlock(current, root); // Must not be at the very beginning of the text area.\n\n          if (previous) {\n            // If not editable, just delete whole block.\n            if (!previous.isContentEditable) {\n              detach(previous);\n              return;\n            } // Otherwise merge.\n\n\n            mergeWithBlock(previous, current, range, root); // If deleted line between containers, merge newly adjacent\n            // containers.\n\n            current = previous.parentNode;\n\n            while (current !== root && !current.nextSibling) {\n              current = current.parentNode;\n            }\n\n            if (current !== root && (current = current.nextSibling)) {\n              mergeContainers(current, root);\n            }\n\n            self.setSelection(range);\n          } // If at very beginning of text area, allow backspace\n          // to break lists/blockquote.\n          else if (current) {\n              // Break list\n              if (getNearest(current, root, 'UL') || getNearest(current, root, 'OL')) {\n                return self.decreaseListLevel(range);\n              } // Break blockquote\n              else if (getNearest(current, root, 'BLOCKQUOTE')) {\n                  return self.modifyBlocks(decreaseBlockQuoteLevel, range);\n                }\n\n              self.setSelection(range);\n\n              self._updatePath(range, true);\n            }\n        } // Otherwise, leave to browser but check afterwards whether it has\n        // left behind an empty inline tag.\n        else {\n            self.setSelection(range);\n            setTimeout(function () {\n              afterDelete(self);\n            }, 0);\n          }\n    },\n    'delete': function (self, event, range) {\n      var root = self._root;\n      var current, next, originalRange, cursorContainer, cursorOffset, nodeAfterCursor;\n\n      self._removeZWS(); // Record undo checkpoint.\n\n\n      self.saveUndoState(range); // If not collapsed, delete contents\n\n      if (!range.collapsed) {\n        event.preventDefault();\n        deleteContentsOfRange(range, root);\n        afterDelete(self, range);\n      } // If at end of block, merge next into this block\n      else if (rangeDoesEndAtBlockBoundary(range, root)) {\n          event.preventDefault();\n          current = getStartBlockOfRange(range, root);\n\n          if (!current) {\n            return;\n          } // In case inline data has somehow got between blocks.\n\n\n          fixContainer(current.parentNode, root); // Now get next block\n\n          next = getNextBlock(current, root); // Must not be at the very end of the text area.\n\n          if (next) {\n            // If not editable, just delete whole block.\n            if (!next.isContentEditable) {\n              detach(next);\n              return;\n            } // Otherwise merge.\n\n\n            mergeWithBlock(current, next, range, root); // If deleted line between containers, merge newly adjacent\n            // containers.\n\n            next = current.parentNode;\n\n            while (next !== root && !next.nextSibling) {\n              next = next.parentNode;\n            }\n\n            if (next !== root && (next = next.nextSibling)) {\n              mergeContainers(next, root);\n            }\n\n            self.setSelection(range);\n\n            self._updatePath(range, true);\n          }\n        } // Otherwise, leave to browser but check afterwards whether it has\n        // left behind an empty inline tag.\n        else {\n            // But first check if the cursor is just before an IMG tag. If so,\n            // delete it ourselves, because the browser won't if it is not\n            // inline.\n            originalRange = range.cloneRange();\n            moveRangeBoundariesUpTree(range, root, root, root);\n            cursorContainer = range.endContainer;\n            cursorOffset = range.endOffset;\n\n            if (cursorContainer.nodeType === ELEMENT_NODE) {\n              nodeAfterCursor = cursorContainer.childNodes[cursorOffset];\n\n              if (nodeAfterCursor && nodeAfterCursor.nodeName === 'IMG') {\n                event.preventDefault();\n                detach(nodeAfterCursor);\n                moveRangeBoundariesDownTree(range);\n                afterDelete(self, range);\n                return;\n              }\n            }\n\n            self.setSelection(originalRange);\n            setTimeout(function () {\n              afterDelete(self);\n            }, 0);\n          }\n    },\n    tab: function (self, event, range) {\n      var root = self._root;\n      var node, parent;\n\n      self._removeZWS(); // If no selection and at start of block\n\n\n      if (range.collapsed && rangeDoesStartAtBlockBoundary(range, root)) {\n        node = getStartBlockOfRange(range, root); // Iterate through the block's parents\n\n        while (parent = node.parentNode) {\n          // If we find a UL or OL (so are in a list, node must be an LI)\n          if (parent.nodeName === 'UL' || parent.nodeName === 'OL') {\n            // Then increase the list level\n            event.preventDefault();\n            self.increaseListLevel(range);\n            break;\n          }\n\n          node = parent;\n        }\n      }\n    },\n    'shift-tab': function (self, event, range) {\n      var root = self._root;\n      var node;\n\n      self._removeZWS(); // If no selection and at start of block\n\n\n      if (range.collapsed && rangeDoesStartAtBlockBoundary(range, root)) {\n        // Break list\n        node = range.startContainer;\n\n        if (getNearest(node, root, 'UL') || getNearest(node, root, 'OL')) {\n          event.preventDefault();\n          self.decreaseListLevel(range);\n        }\n      }\n    },\n    space: function (self, _, range) {\n      var node, parent;\n      var root = self._root;\n\n      self._recordUndoState(range);\n\n      addLinks(range.startContainer, root, self);\n\n      self._getRangeAndRemoveBookmark(range); // If the cursor is at the end of a link (<a>foo|</a>) then move it\n      // outside of the link (<a>foo</a>|) so that the space is not part of\n      // the link text.\n\n\n      node = range.endContainer;\n\n      if (range.collapsed && range.endOffset === getLength(node)) {\n        do {\n          if (node.nodeName === 'A') {\n            range.setStartAfter(node);\n            break;\n          }\n        } while (!node.nextSibling && (node = node.parentNode) && node !== root);\n      } // Delete the selection if not collapsed\n\n\n      if (!range.collapsed) {\n        deleteContentsOfRange(range, root);\n\n        self._ensureBottomLine();\n\n        self.setSelection(range);\n\n        self._updatePath(range, true);\n      }\n\n      self.setSelection(range);\n    },\n    left: function (self) {\n      self._removeZWS();\n    },\n    right: function (self) {\n      self._removeZWS();\n    }\n  }; // Firefox pre v29 incorrectly handles Cmd-left/Cmd-right on Mac:\n  // it goes back/forward in history! Override to do the right\n  // thing.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=289384\n\n  if (isMac && isGecko) {\n    keyHandlers['meta-left'] = function (self, event) {\n      event.preventDefault();\n      var sel = getWindowSelection(self);\n\n      if (sel && sel.modify) {\n        sel.modify('move', 'backward', 'lineboundary');\n      }\n    };\n\n    keyHandlers['meta-right'] = function (self, event) {\n      event.preventDefault();\n      var sel = getWindowSelection(self);\n\n      if (sel && sel.modify) {\n        sel.modify('move', 'forward', 'lineboundary');\n      }\n    };\n  } // System standard for page up/down on Mac is to just scroll, not move the\n  // cursor. On Linux/Windows, it should move the cursor, but some browsers don't\n  // implement this natively. Override to support it.\n\n\n  if (!isMac) {\n    keyHandlers.pageup = function (self) {\n      self.moveCursorToStart();\n    };\n\n    keyHandlers.pagedown = function (self) {\n      self.moveCursorToEnd();\n    };\n  }\n\n  keyHandlers[ctrlKey + 'b'] = mapKeyToFormat('B');\n  keyHandlers[ctrlKey + 'i'] = mapKeyToFormat('I');\n  keyHandlers[ctrlKey + 'u'] = mapKeyToFormat('U');\n  keyHandlers[ctrlKey + 'shift-7'] = mapKeyToFormat('S');\n  keyHandlers[ctrlKey + 'shift-5'] = mapKeyToFormat('SUB', {\n    tag: 'SUP'\n  });\n  keyHandlers[ctrlKey + 'shift-6'] = mapKeyToFormat('SUP', {\n    tag: 'SUB'\n  });\n  keyHandlers[ctrlKey + 'shift-8'] = mapKeyTo('makeUnorderedList');\n  keyHandlers[ctrlKey + 'shift-9'] = mapKeyTo('makeOrderedList');\n  keyHandlers[ctrlKey + '['] = mapKeyTo('decreaseQuoteLevel');\n  keyHandlers[ctrlKey + ']'] = mapKeyTo('increaseQuoteLevel');\n  keyHandlers[ctrlKey + 'd'] = mapKeyTo('toggleCode');\n  keyHandlers[ctrlKey + 'y'] = mapKeyTo('redo');\n  keyHandlers[ctrlKey + 'z'] = mapKeyTo('undo');\n  keyHandlers[ctrlKey + 'shift-z'] = mapKeyTo('redo');\n  var fontSizes = {\n    1: 10,\n    2: 13,\n    3: 16,\n    4: 18,\n    5: 24,\n    6: 32,\n    7: 48\n  };\n  var styleToSemantic = {\n    backgroundColor: {\n      regexp: notWS,\n      replace: function (doc, classNames, colour) {\n        return createElement(doc, 'SPAN', {\n          'class': classNames.highlight,\n          style: 'background-color:' + colour\n        });\n      }\n    },\n    color: {\n      regexp: notWS,\n      replace: function (doc, classNames, colour) {\n        return createElement(doc, 'SPAN', {\n          'class': classNames.colour,\n          style: 'color:' + colour\n        });\n      }\n    },\n    fontWeight: {\n      regexp: /^bold|^700/i,\n      replace: function (doc) {\n        return createElement(doc, 'B');\n      }\n    },\n    fontStyle: {\n      regexp: /^italic/i,\n      replace: function (doc) {\n        return createElement(doc, 'I');\n      }\n    },\n    fontFamily: {\n      regexp: notWS,\n      replace: function (doc, classNames, family) {\n        return createElement(doc, 'SPAN', {\n          'class': classNames.fontFamily,\n          style: 'font-family:' + family\n        });\n      }\n    },\n    fontSize: {\n      regexp: notWS,\n      replace: function (doc, classNames, size) {\n        return createElement(doc, 'SPAN', {\n          'class': classNames.fontSize,\n          style: 'font-size:' + size\n        });\n      }\n    },\n    textDecoration: {\n      regexp: /^underline/i,\n      replace: function (doc) {\n        return createElement(doc, 'U');\n      }\n    }\n  };\n\n  var replaceWithTag = function (tag) {\n    return function (node, parent) {\n      var el = createElement(node.ownerDocument, tag);\n      parent.replaceChild(el, node);\n      el.appendChild(empty(node));\n      return el;\n    };\n  };\n\n  var replaceStyles = function (node, parent, config) {\n    var style = node.style;\n    var doc = node.ownerDocument;\n    var attr, converter, css, newTreeBottom, newTreeTop, el;\n\n    for (attr in styleToSemantic) {\n      converter = styleToSemantic[attr];\n      css = style[attr];\n\n      if (css && converter.regexp.test(css)) {\n        el = converter.replace(doc, config.classNames, css);\n\n        if (!newTreeTop) {\n          newTreeTop = el;\n        }\n\n        if (newTreeBottom) {\n          newTreeBottom.appendChild(el);\n        }\n\n        newTreeBottom = el;\n        node.style[attr] = '';\n      }\n    }\n\n    if (newTreeTop) {\n      newTreeBottom.appendChild(empty(node));\n\n      if (node.nodeName === 'SPAN') {\n        parent.replaceChild(newTreeTop, node);\n      } else {\n        node.appendChild(newTreeTop);\n      }\n    }\n\n    return newTreeBottom || node;\n  };\n\n  var stylesRewriters = {\n    P: replaceStyles,\n    SPAN: replaceStyles,\n    STRONG: replaceWithTag('B'),\n    EM: replaceWithTag('I'),\n    INS: replaceWithTag('U'),\n    STRIKE: replaceWithTag('S'),\n    FONT: function (node, parent, config) {\n      var face = node.face;\n      var size = node.size;\n      var colour = node.color;\n      var doc = node.ownerDocument;\n      var classNames = config.classNames;\n      var fontSpan, sizeSpan, colourSpan;\n      var newTreeBottom, newTreeTop;\n\n      if (face) {\n        fontSpan = createElement(doc, 'SPAN', {\n          'class': classNames.fontFamily,\n          style: 'font-family:' + face\n        });\n        newTreeTop = fontSpan;\n        newTreeBottom = fontSpan;\n      }\n\n      if (size) {\n        sizeSpan = createElement(doc, 'SPAN', {\n          'class': classNames.fontSize,\n          style: 'font-size:' + fontSizes[size] + 'px'\n        });\n\n        if (!newTreeTop) {\n          newTreeTop = sizeSpan;\n        }\n\n        if (newTreeBottom) {\n          newTreeBottom.appendChild(sizeSpan);\n        }\n\n        newTreeBottom = sizeSpan;\n      }\n\n      if (colour && /^#?([\\dA-F]{3}){1,2}$/i.test(colour)) {\n        if (colour.charAt(0) !== '#') {\n          colour = '#' + colour;\n        }\n\n        colourSpan = createElement(doc, 'SPAN', {\n          'class': classNames.colour,\n          style: 'color:' + colour\n        });\n\n        if (!newTreeTop) {\n          newTreeTop = colourSpan;\n        }\n\n        if (newTreeBottom) {\n          newTreeBottom.appendChild(colourSpan);\n        }\n\n        newTreeBottom = colourSpan;\n      }\n\n      if (!newTreeTop) {\n        newTreeTop = newTreeBottom = createElement(doc, 'SPAN');\n      }\n\n      parent.replaceChild(newTreeTop, node);\n      newTreeBottom.appendChild(empty(node));\n      return newTreeBottom;\n    },\n    TT: function (node, parent, config) {\n      var el = createElement(node.ownerDocument, 'SPAN', {\n        'class': config.classNames.fontFamily,\n        style: 'font-family:menlo,consolas,\"courier new\",monospace'\n      });\n      parent.replaceChild(el, node);\n      el.appendChild(empty(node));\n      return el;\n    }\n  };\n  var allowedBlock = /^(?:A(?:DDRESS|RTICLE|SIDE|UDIO)|BLOCKQUOTE|CAPTION|D(?:[DLT]|IV)|F(?:IGURE|IGCAPTION|OOTER)|H[1-6]|HEADER|L(?:ABEL|EGEND|I)|O(?:L|UTPUT)|P(?:RE)?|SECTION|T(?:ABLE|BODY|D|FOOT|H|HEAD|R)|COL(?:GROUP)?|UL)$/;\n  var blacklist = /^(?:HEAD|META|STYLE)/;\n  var walker = new TreeWalker(null, SHOW_TEXT | SHOW_ELEMENT);\n  /*\n      Two purposes:\n  \n      1. Remove nodes we don't want, such as weird <o:p> tags, comment nodes\n         and whitespace nodes.\n      2. Convert inline tags into our preferred format.\n  */\n\n  var cleanTree = function cleanTree(node, config, preserveWS) {\n    var children = node.childNodes,\n        nonInlineParent,\n        i,\n        l,\n        child,\n        nodeName,\n        nodeType,\n        rewriter,\n        childLength,\n        startsWithWS,\n        endsWithWS,\n        data,\n        sibling;\n    nonInlineParent = node;\n\n    while (isInline(nonInlineParent)) {\n      nonInlineParent = nonInlineParent.parentNode;\n    }\n\n    walker.root = nonInlineParent;\n\n    for (i = 0, l = children.length; i < l; i += 1) {\n      child = children[i];\n      nodeName = child.nodeName;\n      nodeType = child.nodeType;\n      rewriter = stylesRewriters[nodeName];\n\n      if (nodeType === ELEMENT_NODE) {\n        childLength = child.childNodes.length;\n\n        if (rewriter) {\n          child = rewriter(child, node, config);\n        } else if (blacklist.test(nodeName)) {\n          node.removeChild(child);\n          i -= 1;\n          l -= 1;\n          continue;\n        } else if (!allowedBlock.test(nodeName) && !isInline(child)) {\n          i -= 1;\n          l += childLength - 1;\n          node.replaceChild(empty(child), child);\n          continue;\n        }\n\n        if (childLength) {\n          cleanTree(child, config, preserveWS || nodeName === 'PRE');\n        }\n      } else {\n        if (nodeType === TEXT_NODE) {\n          data = child.data;\n          startsWithWS = !notWS.test(data.charAt(0));\n          endsWithWS = !notWS.test(data.charAt(data.length - 1));\n\n          if (preserveWS || !startsWithWS && !endsWithWS) {\n            continue;\n          } // Iterate through the nodes; if we hit some other content\n          // before the start of a new block we don't trim\n\n\n          if (startsWithWS) {\n            walker.currentNode = child;\n\n            while (sibling = walker.previousPONode()) {\n              nodeName = sibling.nodeName;\n\n              if (nodeName === 'IMG' || nodeName === '#text' && notWS.test(sibling.data)) {\n                break;\n              }\n\n              if (!isInline(sibling)) {\n                sibling = null;\n                break;\n              }\n            }\n\n            data = data.replace(/^[ \\t\\r\\n]+/g, sibling ? ' ' : '');\n          }\n\n          if (endsWithWS) {\n            walker.currentNode = child;\n\n            while (sibling = walker.nextNode()) {\n              if (nodeName === 'IMG' || nodeName === '#text' && notWS.test(sibling.data)) {\n                break;\n              }\n\n              if (!isInline(sibling)) {\n                sibling = null;\n                break;\n              }\n            }\n\n            data = data.replace(/[ \\t\\r\\n]+$/g, sibling ? ' ' : '');\n          }\n\n          if (data) {\n            child.data = data;\n            continue;\n          }\n        }\n\n        node.removeChild(child);\n        i -= 1;\n        l -= 1;\n      }\n    }\n\n    return node;\n  }; // ---\n\n\n  var removeEmptyInlines = function removeEmptyInlines(node) {\n    var children = node.childNodes,\n        l = children.length,\n        child;\n\n    while (l--) {\n      child = children[l];\n\n      if (child.nodeType === ELEMENT_NODE && !isLeaf(child)) {\n        removeEmptyInlines(child);\n\n        if (isInline(child) && !child.firstChild) {\n          node.removeChild(child);\n        }\n      } else if (child.nodeType === TEXT_NODE && !child.data) {\n        node.removeChild(child);\n      }\n    }\n  }; // ---\n\n\n  var notWSTextNode = function (node) {\n    return node.nodeType === ELEMENT_NODE ? node.nodeName === 'BR' : notWS.test(node.data);\n  };\n\n  var isLineBreak = function (br, isLBIfEmptyBlock) {\n    var block = br.parentNode;\n    var walker;\n\n    while (isInline(block)) {\n      block = block.parentNode;\n    }\n\n    walker = new TreeWalker(block, SHOW_ELEMENT | SHOW_TEXT, notWSTextNode);\n    walker.currentNode = br;\n    return !!walker.nextNode() || isLBIfEmptyBlock && !walker.previousNode();\n  }; // <br> elements are treated specially, and differently depending on the\n  // browser, when in rich text editor mode. When adding HTML from external\n  // sources, we must remove them, replacing the ones that actually affect\n  // line breaks by wrapping the inline text in a <div>. Browsers that want <br>\n  // elements at the end of each block will then have them added back in a later\n  // fixCursor method call.\n\n\n  var cleanupBRs = function (node, root, keepForBlankLine) {\n    var brs = node.querySelectorAll('BR');\n    var brBreaksLine = [];\n    var l = brs.length;\n    var i, br, parent; // Must calculate whether the <br> breaks a line first, because if we\n    // have two <br>s next to each other, after the first one is converted\n    // to a block split, the second will be at the end of a block and\n    // therefore seem to not be a line break. But in its original context it\n    // was, so we should also convert it to a block split.\n\n    for (i = 0; i < l; i += 1) {\n      brBreaksLine[i] = isLineBreak(brs[i], keepForBlankLine);\n    }\n\n    while (l--) {\n      br = brs[l]; // Cleanup may have removed it\n\n      parent = br.parentNode;\n\n      if (!parent) {\n        continue;\n      } // If it doesn't break a line, just remove it; it's not doing\n      // anything useful. We'll add it back later if required by the\n      // browser. If it breaks a line, wrap the content in div tags\n      // and replace the brs.\n\n\n      if (!brBreaksLine[l]) {\n        detach(br);\n      } else if (!isInline(parent)) {\n        fixContainer(parent, root);\n      }\n    }\n  }; // The (non-standard but supported enough) innerText property is based on the\n  // render tree in Firefox and possibly other browsers, so we must insert the\n  // DOM node into the document to ensure the text part is correct.\n\n\n  var setClipboardData = function (clipboardData, node, root, config) {\n    var body = node.ownerDocument.body;\n    var willCutCopy = config.willCutCopy;\n    var html, text; // Firefox will add an extra new line for BRs at the end of block when\n    // calculating innerText, even though they don't actually affect display.\n    // So we need to remove them first.\n\n    cleanupBRs(node, root, true);\n    node.setAttribute('style', 'position:fixed;overflow:hidden;bottom:100%;right:100%;');\n    body.appendChild(node);\n    html = node.innerHTML;\n    text = node.innerText || node.textContent;\n\n    if (willCutCopy) {\n      html = willCutCopy(html);\n    } // Firefox (and others?) returns unix line endings (\\n) even on Windows.\n    // If on Windows, normalise to \\r\\n, since Notepad and some other crappy\n    // apps do not understand just \\n.\n\n\n    if (isWin) {\n      text = text.replace(/\\r?\\n/g, '\\r\\n');\n    }\n\n    clipboardData.setData('text/html', html);\n    clipboardData.setData('text/plain', text);\n    body.removeChild(node);\n  };\n\n  var onCut = function (event) {\n    var clipboardData = event.clipboardData;\n    var range = this.getSelection();\n    var root = this._root;\n    var self = this;\n    var startBlock, endBlock, copyRoot, contents, parent, newContents, node; // Nothing to do\n\n    if (range.collapsed) {\n      event.preventDefault();\n      return;\n    } // Save undo checkpoint\n\n\n    this.saveUndoState(range); // Edge only seems to support setting plain text as of 2016-03-11.\n    // Mobile Safari flat out doesn't work:\n    // https://bugs.webkit.org/show_bug.cgi?id=143776\n\n    if (!isEdge && !isIOS && clipboardData) {\n      // Clipboard content should include all parents within block, or all\n      // parents up to root if selection across blocks\n      startBlock = getStartBlockOfRange(range, root);\n      endBlock = getEndBlockOfRange(range, root);\n      copyRoot = startBlock === endBlock && startBlock || root; // Extract the contents\n\n      contents = deleteContentsOfRange(range, root); // Add any other parents not in extracted content, up to copy root\n\n      parent = range.commonAncestorContainer;\n\n      if (parent.nodeType === TEXT_NODE) {\n        parent = parent.parentNode;\n      }\n\n      while (parent && parent !== copyRoot) {\n        newContents = parent.cloneNode(false);\n        newContents.appendChild(contents);\n        contents = newContents;\n        parent = parent.parentNode;\n      } // Set clipboard data\n\n\n      node = this.createElement('div');\n      node.appendChild(contents);\n      setClipboardData(clipboardData, node, root, this._config);\n      event.preventDefault();\n    } else {\n      setTimeout(function () {\n        try {\n          // If all content removed, ensure div at start of root.\n          self._ensureBottomLine();\n        } catch (error) {\n          self.didError(error);\n        }\n      }, 0);\n    }\n\n    this.setSelection(range);\n  };\n\n  var onCopy = function (event) {\n    var clipboardData = event.clipboardData;\n    var range = this.getSelection();\n    var root = this._root;\n    var startBlock, endBlock, copyRoot, contents, parent, newContents, node; // Edge only seems to support setting plain text as of 2016-03-11.\n    // Mobile Safari flat out doesn't work:\n    // https://bugs.webkit.org/show_bug.cgi?id=143776\n\n    if (!isEdge && !isIOS && clipboardData) {\n      // Clipboard content should include all parents within block, or all\n      // parents up to root if selection across blocks\n      startBlock = getStartBlockOfRange(range, root);\n      endBlock = getEndBlockOfRange(range, root);\n      copyRoot = startBlock === endBlock && startBlock || root; // Clone range to mutate, then move up as high as possible without\n      // passing the copy root node.\n\n      range = range.cloneRange();\n      moveRangeBoundariesDownTree(range);\n      moveRangeBoundariesUpTree(range, copyRoot, copyRoot, root); // Extract the contents\n\n      contents = range.cloneContents(); // Add any other parents not in extracted content, up to copy root\n\n      parent = range.commonAncestorContainer;\n\n      if (parent.nodeType === TEXT_NODE) {\n        parent = parent.parentNode;\n      }\n\n      while (parent && parent !== copyRoot) {\n        newContents = parent.cloneNode(false);\n        newContents.appendChild(contents);\n        contents = newContents;\n        parent = parent.parentNode;\n      } // Set clipboard data\n\n\n      node = this.createElement('div');\n      node.appendChild(contents);\n      setClipboardData(clipboardData, node, root, this._config);\n      event.preventDefault();\n    }\n  }; // Need to monitor for shift key like this, as event.shiftKey is not available\n  // in paste event.\n\n\n  function monitorShiftKey(event) {\n    this.isShiftDown = event.shiftKey;\n  }\n\n  var onPaste = function (event) {\n    var clipboardData = event.clipboardData;\n    var items = clipboardData && clipboardData.items;\n    var choosePlain = this.isShiftDown;\n    var fireDrop = false;\n    var hasRTF = false;\n    var hasImage = false;\n    var plainItem = null;\n    var htmlItem = null;\n    var self = this;\n    var l, item, type, types, data; // Current HTML5 Clipboard interface\n    // ---------------------------------\n    // https://html.spec.whatwg.org/multipage/interaction.html\n\n    if (items) {\n      l = items.length;\n\n      while (l--) {\n        item = items[l];\n        type = item.type;\n\n        if (type === 'text/html') {\n          htmlItem = item; // iOS copy URL gives you type text/uri-list which is just a list\n          // of 1 or more URLs separated by new lines. Can just treat as\n          // plain text.\n        } else if (type === 'text/plain' || type === 'text/uri-list') {\n          plainItem = item;\n        } else if (type === 'text/rtf') {\n          hasRTF = true;\n        } else if (/^image\\/.*/.test(type)) {\n          hasImage = true;\n        }\n      } // Treat image paste as a drop of an image file. When you copy\n      // an image in Chrome/Firefox (at least), it copies the image data\n      // but also an HTML version (referencing the original URL of the image)\n      // and a plain text version.\n      //\n      // However, when you copy in Excel, you get html, rtf, text, image;\n      // in this instance you want the html version! So let's try using\n      // the presence of text/rtf as an indicator to choose the html version\n      // over the image.\n\n\n      if (hasImage && !(hasRTF && htmlItem)) {\n        event.preventDefault();\n        this.fireEvent('dragover', {\n          dataTransfer: clipboardData,\n\n          /*jshint loopfunc: true */\n          preventDefault: function () {\n            fireDrop = true;\n          }\n          /*jshint loopfunc: false */\n\n        });\n\n        if (fireDrop) {\n          this.fireEvent('drop', {\n            dataTransfer: clipboardData\n          });\n        }\n\n        return;\n      } // Edge only provides access to plain text as of 2016-03-11 and gives no\n      // indication there should be an HTML part. However, it does support\n      // access to image data, so we check for that first. Otherwise though,\n      // fall through to fallback clipboard handling methods\n\n\n      if (!isEdge) {\n        event.preventDefault();\n\n        if (htmlItem && (!choosePlain || !plainItem)) {\n          htmlItem.getAsString(function (html) {\n            self.insertHTML(html, true);\n          });\n        } else if (plainItem) {\n          plainItem.getAsString(function (text) {\n            self.insertPlainText(text, true);\n          });\n        }\n\n        return;\n      }\n    } // Old interface\n    // -------------\n    // Safari (and indeed many other OS X apps) copies stuff as text/rtf\n    // rather than text/html; even from a webpage in Safari. The only way\n    // to get an HTML version is to fallback to letting the browser insert\n    // the content. Same for getting image data. *Sigh*.\n    //\n    // Firefox is even worse: it doesn't even let you know that there might be\n    // an RTF version on the clipboard, but it will also convert to HTML if you\n    // let the browser insert the content. I've filed\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1254028\n\n\n    types = clipboardData && clipboardData.types;\n\n    if (!isEdge && types && (indexOf.call(types, 'text/html') > -1 || !isGecko && indexOf.call(types, 'text/plain') > -1 && indexOf.call(types, 'text/rtf') < 0)) {\n      event.preventDefault(); // Abiword on Linux copies a plain text and html version, but the HTML\n      // version is the empty string! So always try to get HTML, but if none,\n      // insert plain text instead. On iOS, Facebook (and possibly other\n      // apps?) copy links as type text/uri-list, but also insert a **blank**\n      // text/plain item onto the clipboard. Why? Who knows.\n\n      if (!choosePlain && (data = clipboardData.getData('text/html'))) {\n        this.insertHTML(data, true);\n      } else if ((data = clipboardData.getData('text/plain')) || (data = clipboardData.getData('text/uri-list'))) {\n        this.insertPlainText(data, true);\n      }\n\n      return;\n    } // No interface. Includes all versions of IE :(\n    // --------------------------------------------\n\n\n    this._awaitingPaste = true;\n    var body = this._doc.body,\n        range = this.getSelection(),\n        startContainer = range.startContainer,\n        startOffset = range.startOffset,\n        endContainer = range.endContainer,\n        endOffset = range.endOffset; // We need to position the pasteArea in the visible portion of the screen\n    // to stop the browser auto-scrolling.\n\n    var pasteArea = this.createElement('DIV', {\n      contenteditable: 'true',\n      style: 'position:fixed; overflow:hidden; top:0; right:100%; width:1px; height:1px;'\n    });\n    body.appendChild(pasteArea);\n    range.selectNodeContents(pasteArea);\n    this.setSelection(range); // A setTimeout of 0 means this is added to the back of the\n    // single javascript thread, so it will be executed after the\n    // paste event.\n\n    setTimeout(function () {\n      try {\n        // IE sometimes fires the beforepaste event twice; make sure it is\n        // not run again before our after paste function is called.\n        self._awaitingPaste = false; // Get the pasted content and clean\n\n        var html = '',\n            next = pasteArea,\n            first,\n            range; // #88: Chrome can apparently split the paste area if certain\n        // content is inserted; gather them all up.\n\n        while (pasteArea = next) {\n          next = pasteArea.nextSibling;\n          detach(pasteArea); // Safari and IE like putting extra divs around things.\n\n          first = pasteArea.firstChild;\n\n          if (first && first === pasteArea.lastChild && first.nodeName === 'DIV') {\n            pasteArea = first;\n          }\n\n          html += pasteArea.innerHTML;\n        }\n\n        range = self.createRange(startContainer, startOffset, endContainer, endOffset);\n        self.setSelection(range);\n\n        if (html) {\n          self.insertHTML(html, true);\n        }\n      } catch (error) {\n        self.didError(error);\n      }\n    }, 0);\n  }; // On Windows you can drag an drop text. We can't handle this ourselves, because\n  // as far as I can see, there's no way to get the drop insertion point. So just\n  // save an undo state and hope for the best.\n\n\n  var onDrop = function (event) {\n    var types = event.dataTransfer.types;\n    var l = types.length;\n    var hasPlain = false;\n    var hasHTML = false;\n\n    while (l--) {\n      switch (types[l]) {\n        case 'text/plain':\n          hasPlain = true;\n          break;\n\n        case 'text/html':\n          hasHTML = true;\n          break;\n\n        default:\n          return;\n      }\n    }\n\n    if (hasHTML || hasPlain) {\n      this.saveUndoState();\n    }\n  };\n\n  function mergeObjects(base, extras, mayOverride) {\n    var prop, value;\n\n    if (!base) {\n      base = {};\n    }\n\n    if (extras) {\n      for (prop in extras) {\n        if (mayOverride || !(prop in base)) {\n          value = extras[prop];\n          base[prop] = value && value.constructor === Object ? mergeObjects(base[prop], value, mayOverride) : value;\n        }\n      }\n    }\n\n    return base;\n  }\n\n  function Squire(root, config) {\n    if (root.nodeType === DOCUMENT_NODE) {\n      root = root.body;\n    }\n\n    var doc = root.ownerDocument;\n    var win = doc.defaultView;\n    var mutation;\n    this._win = win;\n    this._doc = doc;\n    this._root = root;\n    this._events = {};\n    this._isFocused = false;\n    this._lastSelection = null; // IE loses selection state of iframe on blur, so make sure we\n    // cache it just before it loses focus.\n\n    if (losesSelectionOnBlur) {\n      this.addEventListener('beforedeactivate', this.getSelection);\n    }\n\n    this._hasZWS = false;\n    this._lastAnchorNode = null;\n    this._lastFocusNode = null;\n    this._path = '';\n    this._willUpdatePath = false;\n\n    if ('onselectionchange' in doc) {\n      this.addEventListener('selectionchange', this._updatePathOnEvent);\n    } else {\n      this.addEventListener('keyup', this._updatePathOnEvent);\n      this.addEventListener('mouseup', this._updatePathOnEvent);\n    }\n\n    this._undoIndex = -1;\n    this._undoStack = [];\n    this._undoStackLength = 0;\n    this._isInUndoState = false;\n    this._ignoreChange = false;\n    this._ignoreAllChanges = false;\n\n    if (canObserveMutations) {\n      mutation = new MutationObserver(this._docWasChanged.bind(this));\n      mutation.observe(root, {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n      });\n      this._mutation = mutation;\n    } else {\n      this.addEventListener('keyup', this._keyUpDetectChange);\n    } // On blur, restore focus except if the user taps or clicks to focus a\n    // specific point. Can't actually use click event because focus happens\n    // before click, so use mousedown/touchstart\n\n\n    this._restoreSelection = false;\n    this.addEventListener('blur', enableRestoreSelection);\n    this.addEventListener('mousedown', disableRestoreSelection);\n    this.addEventListener('touchstart', disableRestoreSelection);\n    this.addEventListener('focus', restoreSelection); // IE sometimes fires the beforepaste event twice; make sure it is not run\n    // again before our after paste function is called.\n\n    this._awaitingPaste = false;\n    this.addEventListener(isIElt11 ? 'beforecut' : 'cut', onCut);\n    this.addEventListener('copy', onCopy);\n    this.addEventListener('keydown', monitorShiftKey);\n    this.addEventListener('keyup', monitorShiftKey);\n    this.addEventListener(isIElt11 ? 'beforepaste' : 'paste', onPaste);\n    this.addEventListener('drop', onDrop); // Opera does not fire keydown repeatedly.\n\n    this.addEventListener(isPresto ? 'keypress' : 'keydown', onKey); // Add key handlers\n\n    this._keyHandlers = Object.create(keyHandlers); // Override default properties\n\n    this.setConfig(config); // Fix IE<10's buggy implementation of Text#splitText.\n    // If the split is at the end of the node, it doesn't insert the newly split\n    // node into the document, and sets its value to undefined rather than ''.\n    // And even if the split is not at the end, the original node is removed\n    // from the document and replaced by another, rather than just having its\n    // data shortened.\n    // We used to feature test for this, but then found the feature test would\n    // sometimes pass, but later on the buggy behaviour would still appear.\n    // I think IE10 does not have the same bug, but it doesn't hurt to replace\n    // its native fn too and then we don't need yet another UA category.\n\n    if (isIElt11) {\n      win.Text.prototype.splitText = function (offset) {\n        var afterSplit = this.ownerDocument.createTextNode(this.data.slice(offset)),\n            next = this.nextSibling,\n            parent = this.parentNode,\n            toDelete = this.length - offset;\n\n        if (next) {\n          parent.insertBefore(afterSplit, next);\n        } else {\n          parent.appendChild(afterSplit);\n        }\n\n        if (toDelete) {\n          this.deleteData(offset, toDelete);\n        }\n\n        return afterSplit;\n      };\n    }\n\n    root.setAttribute('contenteditable', 'true'); // Remove Firefox's built-in controls\n\n    try {\n      doc.execCommand('enableObjectResizing', false, 'false');\n      doc.execCommand('enableInlineTableEditing', false, 'false');\n    } catch (error) {}\n\n    root.__squire__ = this; // Need to register instance before calling setHTML, so that the fixCursor\n    // function can lookup any default block tag options set.\n\n    this.setHTML('');\n  }\n\n  var proto = Squire.prototype;\n\n  var sanitizeToDOMFragment = function (html, isPaste, self) {\n    var doc = self._doc;\n    var frag = html ? DOMPurify.sanitize(html, {\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n      WHOLE_DOCUMENT: false,\n      RETURN_DOM: true,\n      RETURN_DOM_FRAGMENT: true\n    }) : null;\n    return frag ? doc.importNode(frag, true) : doc.createDocumentFragment();\n  };\n\n  proto.setConfig = function (config) {\n    config = mergeObjects({\n      blockTag: 'DIV',\n      blockAttributes: null,\n      tagAttributes: {\n        blockquote: null,\n        ul: null,\n        ol: null,\n        li: null,\n        a: null\n      },\n      classNames: {\n        colour: 'colour',\n        fontFamily: 'font',\n        fontSize: 'size',\n        highlight: 'highlight'\n      },\n      leafNodeNames: leafNodeNames,\n      undo: {\n        documentSizeThreshold: -1,\n        // -1 means no threshold\n        undoLimit: -1 // -1 means no limit\n\n      },\n      isInsertedHTMLSanitized: true,\n      isSetHTMLSanitized: true,\n      sanitizeToDOMFragment: typeof DOMPurify !== 'undefined' && DOMPurify.isSupported ? sanitizeToDOMFragment : null,\n      willCutCopy: null\n    }, config, true); // Users may specify block tag in lower case\n\n    config.blockTag = config.blockTag.toUpperCase();\n    this._config = config;\n    return this;\n  };\n\n  proto.createElement = function (tag, props, children) {\n    return createElement(this._doc, tag, props, children);\n  };\n\n  proto.createDefaultBlock = function (children) {\n    var config = this._config;\n    return fixCursor(this.createElement(config.blockTag, config.blockAttributes, children), this._root);\n  };\n\n  proto.didError = function (error) {\n    console.log(error);\n  };\n\n  proto.getDocument = function () {\n    return this._doc;\n  };\n\n  proto.getRoot = function () {\n    return this._root;\n  };\n\n  proto.modifyDocument = function (modificationCallback) {\n    var mutation = this._mutation;\n\n    if (mutation) {\n      if (mutation.takeRecords().length) {\n        this._docWasChanged();\n      }\n\n      mutation.disconnect();\n    }\n\n    this._ignoreAllChanges = true;\n    modificationCallback();\n    this._ignoreAllChanges = false;\n\n    if (mutation) {\n      mutation.observe(this._root, {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n      });\n      this._ignoreChange = false;\n    }\n  }; // --- Events ---\n  // Subscribing to these events won't automatically add a listener to the\n  // document node, since these events are fired in a custom manner by the\n  // editor code.\n\n\n  var customEvents = {\n    pathChange: 1,\n    select: 1,\n    input: 1,\n    undoStateChange: 1\n  };\n\n  proto.fireEvent = function (type, event) {\n    var handlers = this._events[type];\n    var isFocused, l, obj; // UI code, especially modal views, may be monitoring for focus events and\n    // immediately removing focus. In certain conditions, this can cause the\n    // focus event to fire after the blur event, which can cause an infinite\n    // loop. So we detect whether we're actually focused/blurred before firing.\n\n    if (/^(?:focus|blur)/.test(type)) {\n      isFocused = this._root === this._doc.activeElement;\n\n      if (type === 'focus') {\n        if (!isFocused || this._isFocused) {\n          return this;\n        }\n\n        this._isFocused = true;\n      } else {\n        if (isFocused || !this._isFocused) {\n          return this;\n        }\n\n        this._isFocused = false;\n      }\n    }\n\n    if (handlers) {\n      if (!event) {\n        event = {};\n      }\n\n      if (event.type !== type) {\n        event.type = type;\n      } // Clone handlers array, so any handlers added/removed do not affect it.\n\n\n      handlers = handlers.slice();\n      l = handlers.length;\n\n      while (l--) {\n        obj = handlers[l];\n\n        try {\n          if (obj.handleEvent) {\n            obj.handleEvent(event);\n          } else {\n            obj.call(this, event);\n          }\n        } catch (error) {\n          error.details = 'Squire: fireEvent error. Event type: ' + type;\n          this.didError(error);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  proto.destroy = function () {\n    var events = this._events;\n    var type;\n\n    for (type in events) {\n      this.removeEventListener(type);\n    }\n\n    if (this._mutation) {\n      this._mutation.disconnect();\n    }\n\n    delete this._root.__squire__; // Destroy undo stack\n\n    this._undoIndex = -1;\n    this._undoStack = [];\n    this._undoStackLength = 0;\n  };\n\n  proto.handleEvent = function (event) {\n    this.fireEvent(event.type, event);\n  };\n\n  proto.addEventListener = function (type, fn) {\n    var handlers = this._events[type];\n    var target = this._root;\n\n    if (!fn) {\n      this.didError({\n        name: 'Squire: addEventListener with null or undefined fn',\n        message: 'Event type: ' + type\n      });\n      return this;\n    }\n\n    if (!handlers) {\n      handlers = this._events[type] = [];\n\n      if (!customEvents[type]) {\n        if (type === 'selectionchange') {\n          target = this._doc;\n        }\n\n        target.addEventListener(type, this, true);\n      }\n    }\n\n    handlers.push(fn);\n    return this;\n  };\n\n  proto.removeEventListener = function (type, fn) {\n    var handlers = this._events[type];\n    var target = this._root;\n    var l;\n\n    if (handlers) {\n      if (fn) {\n        l = handlers.length;\n\n        while (l--) {\n          if (handlers[l] === fn) {\n            handlers.splice(l, 1);\n          }\n        }\n      } else {\n        handlers.length = 0;\n      }\n\n      if (!handlers.length) {\n        delete this._events[type];\n\n        if (!customEvents[type]) {\n          if (type === 'selectionchange') {\n            target = this._doc;\n          }\n\n          target.removeEventListener(type, this, true);\n        }\n      }\n    }\n\n    return this;\n  }; // --- Selection and Path ---\n\n\n  proto.createRange = function (range, startOffset, endContainer, endOffset) {\n    if (range instanceof this._win.Range) {\n      return range.cloneRange();\n    }\n\n    var domRange = this._doc.createRange();\n\n    domRange.setStart(range, startOffset);\n\n    if (endContainer) {\n      domRange.setEnd(endContainer, endOffset);\n    } else {\n      domRange.setEnd(range, startOffset);\n    }\n\n    return domRange;\n  };\n\n  proto.getCursorPosition = function (range) {\n    if (!range && !(range = this.getSelection()) || !range.getBoundingClientRect) {\n      return null;\n    } // Get the bounding rect\n\n\n    var rect = range.getBoundingClientRect();\n    var node, parent;\n\n    if (rect && !rect.top) {\n      this._ignoreChange = true;\n      node = this._doc.createElement('SPAN');\n      node.textContent = ZWS;\n      insertNodeInRange(range, node);\n      rect = node.getBoundingClientRect();\n      parent = node.parentNode;\n      parent.removeChild(node);\n      mergeInlines(parent, range);\n    }\n\n    return rect;\n  };\n\n  proto._moveCursorTo = function (toStart) {\n    var root = this._root,\n        range = this.createRange(root, toStart ? 0 : root.childNodes.length);\n    moveRangeBoundariesDownTree(range);\n    this.setSelection(range);\n    return this;\n  };\n\n  proto.moveCursorToStart = function () {\n    return this._moveCursorTo(true);\n  };\n\n  proto.moveCursorToEnd = function () {\n    return this._moveCursorTo(false);\n  };\n\n  var getWindowSelection = function (self) {\n    return self._win.getSelection() || null;\n  };\n\n  proto.setSelection = function (range) {\n    if (range) {\n      this._lastSelection = range; // If we're setting selection, that automatically, and synchronously, // triggers a focus event. So just store the selection and mark it as\n      // needing restore on focus.\n\n      if (!this._isFocused) {\n        enableRestoreSelection.call(this);\n      } else if (isAndroid && !this._restoreSelection) {\n        // Android closes the keyboard on removeAllRanges() and doesn't\n        // open it again when addRange() is called, sigh.\n        // Since Android doesn't trigger a focus event in setSelection(),\n        // use a blur/focus dance to work around this by letting the\n        // selection be restored on focus.\n        // Need to check for !this._restoreSelection to avoid infinite loop\n        enableRestoreSelection.call(this);\n        this.blur();\n        this.focus();\n      } else {\n        // iOS bug: if you don't focus the iframe before setting the\n        // selection, you can end up in a state where you type but the input\n        // doesn't get directed into the contenteditable area but is instead\n        // lost in a black hole. Very strange.\n        if (isIOS) {\n          this._win.focus();\n        }\n\n        var sel = getWindowSelection(this);\n\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(range);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  proto.getSelection = function () {\n    var sel = getWindowSelection(this);\n    var root = this._root;\n    var selection, startContainer, endContainer, node; // If not focused, always rely on cached selection; another function may\n    // have set it but the DOM is not modified until focus again\n\n    if (this._isFocused && sel && sel.rangeCount) {\n      selection = sel.getRangeAt(0).cloneRange();\n      startContainer = selection.startContainer;\n      endContainer = selection.endContainer; // FF can return the selection as being inside an <img>. WTF?\n\n      if (startContainer && isLeaf(startContainer)) {\n        selection.setStartBefore(startContainer);\n      }\n\n      if (endContainer && isLeaf(endContainer)) {\n        selection.setEndBefore(endContainer);\n      }\n    }\n\n    if (selection && isOrContains(root, selection.commonAncestorContainer)) {\n      this._lastSelection = selection;\n    } else {\n      selection = this._lastSelection;\n      node = selection.commonAncestorContainer; // Check the editor is in the live document; if not, the range has\n      // probably been rewritten by the browser and is bogus\n\n      if (!isOrContains(node.ownerDocument, node)) {\n        selection = null;\n      }\n    }\n\n    if (!selection) {\n      selection = this.createRange(root.firstChild, 0);\n    }\n\n    return selection;\n  };\n\n  function enableRestoreSelection() {\n    this._restoreSelection = true;\n  }\n\n  function disableRestoreSelection() {\n    this._restoreSelection = false;\n  }\n\n  function restoreSelection() {\n    if (this._restoreSelection) {\n      this.setSelection(this._lastSelection);\n    }\n  }\n\n  proto.getSelectedText = function () {\n    var range = this.getSelection();\n\n    if (!range || range.collapsed) {\n      return '';\n    }\n\n    var walker = new TreeWalker(range.commonAncestorContainer, SHOW_TEXT | SHOW_ELEMENT, function (node) {\n      return isNodeContainedInRange(range, node, true);\n    });\n    var startContainer = range.startContainer;\n    var endContainer = range.endContainer;\n    var node = walker.currentNode = startContainer;\n    var textContent = '';\n    var addedTextInBlock = false;\n    var value;\n\n    if (!walker.filter(node)) {\n      node = walker.nextNode();\n    }\n\n    while (node) {\n      if (node.nodeType === TEXT_NODE) {\n        value = node.data;\n\n        if (value && /\\S/.test(value)) {\n          if (node === endContainer) {\n            value = value.slice(0, range.endOffset);\n          }\n\n          if (node === startContainer) {\n            value = value.slice(range.startOffset);\n          }\n\n          textContent += value;\n          addedTextInBlock = true;\n        }\n      } else if (node.nodeName === 'BR' || addedTextInBlock && !isInline(node)) {\n        textContent += '\\n';\n        addedTextInBlock = false;\n      }\n\n      node = walker.nextNode();\n    }\n\n    return textContent;\n  };\n\n  proto.getPath = function () {\n    return this._path;\n  }; // --- Workaround for browsers that can't focus empty text nodes ---\n  // WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=15256\n  // Walk down the tree starting at the root and remove any ZWS. If the node only\n  // contained ZWS space then remove it too. We may want to keep one ZWS node at\n  // the bottom of the tree so the block can be selected. Define that node as the\n  // keepNode.\n\n\n  var removeZWS = function (root, keepNode) {\n    var walker = new TreeWalker(root, SHOW_TEXT);\n    var parent, node, index;\n\n    while (node = walker.nextNode()) {\n      while ((index = node.data.indexOf(ZWS)) > -1 && (!keepNode || node.parentNode !== keepNode)) {\n        if (node.length === 1) {\n          do {\n            parent = node.parentNode;\n            parent.removeChild(node);\n            node = parent;\n            walker.currentNode = parent;\n          } while (isInline(node) && !getLength(node));\n\n          break;\n        } else {\n          node.deleteData(index, 1);\n        }\n      }\n    }\n  };\n\n  proto._didAddZWS = function () {\n    this._hasZWS = true;\n  };\n\n  proto._removeZWS = function () {\n    if (!this._hasZWS) {\n      return;\n    }\n\n    removeZWS(this._root);\n    this._hasZWS = false;\n  }; // --- Path change events ---\n\n\n  proto._updatePath = function (range, force) {\n    if (!range) {\n      return;\n    }\n\n    var anchor = range.startContainer,\n        focus = range.endContainer,\n        newPath;\n\n    if (force || anchor !== this._lastAnchorNode || focus !== this._lastFocusNode) {\n      this._lastAnchorNode = anchor;\n      this._lastFocusNode = focus;\n      newPath = anchor && focus ? anchor === focus ? getPath(focus, this._root, this._config) : '(selection)' : '';\n\n      if (this._path !== newPath) {\n        this._path = newPath;\n        this.fireEvent('pathChange', {\n          path: newPath\n        });\n      }\n    }\n\n    this.fireEvent(range.collapsed ? 'cursor' : 'select', {\n      range: range\n    });\n  }; // selectionchange is fired synchronously in IE when removing current selection\n  // and when setting new selection; keyup/mouseup may have processing we want\n  // to do first. Either way, send to next event loop.\n\n\n  proto._updatePathOnEvent = function (event) {\n    var self = this;\n\n    if (self._isFocused && !self._willUpdatePath) {\n      self._willUpdatePath = true;\n      setTimeout(function () {\n        self._willUpdatePath = false;\n\n        self._updatePath(self.getSelection());\n      }, 0);\n    }\n  }; // --- Focus ---\n\n\n  proto.focus = function () {\n    this._root.focus({\n      preventScroll: true\n    });\n\n    if (isIE) {\n      this.fireEvent('focus');\n    }\n\n    return this;\n  };\n\n  proto.blur = function () {\n    this._root.blur();\n\n    if (isIE) {\n      this.fireEvent('blur');\n    }\n\n    return this;\n  }; // --- Bookmarking ---\n\n\n  var startSelectionId = 'squire-selection-start';\n  var endSelectionId = 'squire-selection-end';\n\n  proto._saveRangeToBookmark = function (range) {\n    var startNode = this.createElement('INPUT', {\n      id: startSelectionId,\n      type: 'hidden'\n    }),\n        endNode = this.createElement('INPUT', {\n      id: endSelectionId,\n      type: 'hidden'\n    }),\n        temp;\n    insertNodeInRange(range, startNode);\n    range.collapse(false);\n    insertNodeInRange(range, endNode); // In a collapsed range, the start is sometimes inserted after the end!\n\n    if (startNode.compareDocumentPosition(endNode) & DOCUMENT_POSITION_PRECEDING) {\n      startNode.id = endSelectionId;\n      endNode.id = startSelectionId;\n      temp = startNode;\n      startNode = endNode;\n      endNode = temp;\n    }\n\n    range.setStartAfter(startNode);\n    range.setEndBefore(endNode);\n  };\n\n  proto._getRangeAndRemoveBookmark = function (range) {\n    var root = this._root,\n        start = root.querySelector('#' + startSelectionId),\n        end = root.querySelector('#' + endSelectionId);\n\n    if (start && end) {\n      var startContainer = start.parentNode,\n          endContainer = end.parentNode,\n          startOffset = indexOf.call(startContainer.childNodes, start),\n          endOffset = indexOf.call(endContainer.childNodes, end);\n\n      if (startContainer === endContainer) {\n        endOffset -= 1;\n      }\n\n      detach(start);\n      detach(end);\n\n      if (!range) {\n        range = this._doc.createRange();\n      }\n\n      range.setStart(startContainer, startOffset);\n      range.setEnd(endContainer, endOffset); // Merge any text nodes we split\n\n      mergeInlines(startContainer, range);\n\n      if (startContainer !== endContainer) {\n        mergeInlines(endContainer, range);\n      } // If we didn't split a text node, we should move into any adjacent\n      // text node to current selection point\n\n\n      if (range.collapsed) {\n        startContainer = range.startContainer;\n\n        if (startContainer.nodeType === TEXT_NODE) {\n          endContainer = startContainer.childNodes[range.startOffset];\n\n          if (!endContainer || endContainer.nodeType !== TEXT_NODE) {\n            endContainer = startContainer.childNodes[range.startOffset - 1];\n          }\n\n          if (endContainer && endContainer.nodeType === TEXT_NODE) {\n            range.setStart(endContainer, 0);\n            range.collapse(true);\n          }\n        }\n      }\n    }\n\n    return range || null;\n  }; // --- Undo ---\n\n\n  proto._keyUpDetectChange = function (event) {\n    var code = event.keyCode; // Presume document was changed if:\n    // 1. A modifier key (other than shift) wasn't held down\n    // 2. The key pressed is not in range 16<=x<=20 (control keys)\n    // 3. The key pressed is not in range 33<=x<=45 (navigation keys)\n\n    if (!event.ctrlKey && !event.metaKey && !event.altKey && (code < 16 || code > 20) && (code < 33 || code > 45)) {\n      this._docWasChanged();\n    }\n  };\n\n  proto._docWasChanged = function () {\n    if (canWeakMap) {\n      nodeCategoryCache = new WeakMap();\n    }\n\n    if (this._ignoreAllChanges) {\n      return;\n    }\n\n    if (canObserveMutations && this._ignoreChange) {\n      this._ignoreChange = false;\n      return;\n    }\n\n    if (this._isInUndoState) {\n      this._isInUndoState = false;\n      this.fireEvent('undoStateChange', {\n        canUndo: true,\n        canRedo: false\n      });\n    }\n\n    this.fireEvent('input');\n  }; // Leaves bookmark\n\n\n  proto._recordUndoState = function (range, replace) {\n    // Don't record if we're already in an undo state\n    if (!this._isInUndoState || replace) {\n      // Advance pointer to new position\n      var undoIndex = this._undoIndex;\n      var undoStack = this._undoStack;\n      var undoConfig = this._config.undo;\n      var undoThreshold = undoConfig.documentSizeThreshold;\n      var undoLimit = undoConfig.undoLimit;\n      var html;\n\n      if (!replace) {\n        undoIndex += 1;\n      } // Truncate stack if longer (i.e. if has been previously undone)\n\n\n      if (undoIndex < this._undoStackLength) {\n        undoStack.length = this._undoStackLength = undoIndex;\n      } // Get data\n\n\n      if (range) {\n        this._saveRangeToBookmark(range);\n      }\n\n      html = this._getHTML(); // If this document is above the configured size threshold,\n      // limit the number of saved undo states.\n      // Threshold is in bytes, JS uses 2 bytes per character\n\n      if (undoThreshold > -1 && html.length * 2 > undoThreshold) {\n        if (undoLimit > -1 && undoIndex > undoLimit) {\n          undoStack.splice(0, undoIndex - undoLimit);\n          undoIndex = undoLimit;\n          this._undoStackLength = undoLimit;\n        }\n      } // Save data\n\n\n      undoStack[undoIndex] = html;\n      this._undoIndex = undoIndex;\n      this._undoStackLength += 1;\n      this._isInUndoState = true;\n    }\n  };\n\n  proto.saveUndoState = function (range) {\n    if (range === undefined) {\n      range = this.getSelection();\n    }\n\n    this._recordUndoState(range, this._isInUndoState);\n\n    this._getRangeAndRemoveBookmark(range);\n\n    return this;\n  };\n\n  proto.undo = function () {\n    // Sanity check: must not be at beginning of the history stack\n    if (this._undoIndex !== 0 || !this._isInUndoState) {\n      // Make sure any changes since last checkpoint are saved.\n      this._recordUndoState(this.getSelection(), false);\n\n      this._undoIndex -= 1;\n\n      this._setHTML(this._undoStack[this._undoIndex]);\n\n      var range = this._getRangeAndRemoveBookmark();\n\n      if (range) {\n        this.setSelection(range);\n      }\n\n      this._isInUndoState = true;\n      this.fireEvent('undoStateChange', {\n        canUndo: this._undoIndex !== 0,\n        canRedo: true\n      });\n      this.fireEvent('input');\n    }\n\n    return this;\n  };\n\n  proto.redo = function () {\n    // Sanity check: must not be at end of stack and must be in an undo\n    // state.\n    var undoIndex = this._undoIndex,\n        undoStackLength = this._undoStackLength;\n\n    if (undoIndex + 1 < undoStackLength && this._isInUndoState) {\n      this._undoIndex += 1;\n\n      this._setHTML(this._undoStack[this._undoIndex]);\n\n      var range = this._getRangeAndRemoveBookmark();\n\n      if (range) {\n        this.setSelection(range);\n      }\n\n      this.fireEvent('undoStateChange', {\n        canUndo: true,\n        canRedo: undoIndex + 2 < undoStackLength\n      });\n      this.fireEvent('input');\n    }\n\n    return this;\n  }; // --- Inline formatting ---\n  // Looks for matching tag and attributes, so won't work\n  // if <strong> instead of <b> etc.\n\n\n  proto.hasFormat = function (tag, attributes, range) {\n    // 1. Normalise the arguments and get selection\n    tag = tag.toUpperCase();\n\n    if (!attributes) {\n      attributes = {};\n    }\n\n    if (!range && !(range = this.getSelection())) {\n      return false;\n    } // Sanitize range to prevent weird IE artifacts\n\n\n    if (!range.collapsed && range.startContainer.nodeType === TEXT_NODE && range.startOffset === range.startContainer.length && range.startContainer.nextSibling) {\n      range.setStartBefore(range.startContainer.nextSibling);\n    }\n\n    if (!range.collapsed && range.endContainer.nodeType === TEXT_NODE && range.endOffset === 0 && range.endContainer.previousSibling) {\n      range.setEndAfter(range.endContainer.previousSibling);\n    } // If the common ancestor is inside the tag we require, we definitely\n    // have the format.\n\n\n    var root = this._root;\n    var common = range.commonAncestorContainer;\n    var walker, node;\n\n    if (getNearest(common, root, tag, attributes)) {\n      return true;\n    } // If common ancestor is a text node and doesn't have the format, we\n    // definitely don't have it.\n\n\n    if (common.nodeType === TEXT_NODE) {\n      return false;\n    } // Otherwise, check each text node at least partially contained within\n    // the selection and make sure all of them have the format we want.\n\n\n    walker = new TreeWalker(common, SHOW_TEXT, function (node) {\n      return isNodeContainedInRange(range, node, true);\n    });\n    var seenNode = false;\n\n    while (node = walker.nextNode()) {\n      if (!getNearest(node, root, tag, attributes)) {\n        return false;\n      }\n\n      seenNode = true;\n    }\n\n    return seenNode;\n  }; // Extracts the font-family and font-size (if any) of the element\n  // holding the cursor. If there's a selection, returns an empty object.\n\n\n  proto.getFontInfo = function (range) {\n    var fontInfo = {\n      color: undefined,\n      backgroundColor: undefined,\n      family: undefined,\n      size: undefined\n    };\n    var seenAttributes = 0;\n    var element, style, attr;\n\n    if (!range && !(range = this.getSelection())) {\n      return fontInfo;\n    }\n\n    element = range.commonAncestorContainer;\n\n    if (range.collapsed || element.nodeType === TEXT_NODE) {\n      if (element.nodeType === TEXT_NODE) {\n        element = element.parentNode;\n      }\n\n      while (seenAttributes < 4 && element) {\n        if (style = element.style) {\n          if (!fontInfo.color && (attr = style.color)) {\n            fontInfo.color = attr;\n            seenAttributes += 1;\n          }\n\n          if (!fontInfo.backgroundColor && (attr = style.backgroundColor)) {\n            fontInfo.backgroundColor = attr;\n            seenAttributes += 1;\n          }\n\n          if (!fontInfo.family && (attr = style.fontFamily)) {\n            fontInfo.family = attr;\n            seenAttributes += 1;\n          }\n\n          if (!fontInfo.size && (attr = style.fontSize)) {\n            fontInfo.size = attr;\n            seenAttributes += 1;\n          }\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    return fontInfo;\n  };\n\n  proto._addFormat = function (tag, attributes, range) {\n    // If the range is collapsed we simply insert the node by wrapping\n    // it round the range and focus it.\n    var root = this._root;\n    var el, walker, startContainer, endContainer, startOffset, endOffset, node, needsFormat, block;\n\n    if (range.collapsed) {\n      el = fixCursor(this.createElement(tag, attributes), root);\n      insertNodeInRange(range, el);\n      range.setStart(el.firstChild, el.firstChild.length);\n      range.collapse(true); // Clean up any previous formats that may have been set on this block\n      // that are unused.\n\n      block = el;\n\n      while (isInline(block)) {\n        block = block.parentNode;\n      }\n\n      removeZWS(block, el);\n    } // Otherwise we find all the textnodes in the range (splitting\n    // partially selected nodes) and if they're not already formatted\n    // correctly we wrap them in the appropriate tag.\n    else {\n        // Create an iterator to walk over all the text nodes under this\n        // ancestor which are in the range and not already formatted\n        // correctly.\n        //\n        // In Blink/WebKit, empty blocks may have no text nodes, just a <br>.\n        // Therefore we wrap this in the tag as well, as this will then cause it\n        // to apply when the user types something in the block, which is\n        // presumably what was intended.\n        //\n        // IMG tags are included because we may want to create a link around\n        // them, and adding other styles is harmless.\n        walker = new TreeWalker(range.commonAncestorContainer, SHOW_TEXT | SHOW_ELEMENT, function (node) {\n          return (node.nodeType === TEXT_NODE || node.nodeName === 'BR' || node.nodeName === 'IMG') && isNodeContainedInRange(range, node, true);\n        }); // Start at the beginning node of the range and iterate through\n        // all the nodes in the range that need formatting.\n\n        startContainer = range.startContainer;\n        startOffset = range.startOffset;\n        endContainer = range.endContainer;\n        endOffset = range.endOffset; // Make sure we start with a valid node.\n\n        walker.currentNode = startContainer;\n\n        if (!walker.filter(startContainer)) {\n          startContainer = walker.nextNode();\n          startOffset = 0;\n        } // If there are no interesting nodes in the selection, abort\n\n\n        if (!startContainer) {\n          return range;\n        }\n\n        do {\n          node = walker.currentNode;\n          needsFormat = !getNearest(node, root, tag, attributes);\n\n          if (needsFormat) {\n            // <br> can never be a container node, so must have a text node\n            // if node == (end|start)Container\n            if (node === endContainer && node.length > endOffset) {\n              node.splitText(endOffset);\n            }\n\n            if (node === startContainer && startOffset) {\n              node = node.splitText(startOffset);\n\n              if (endContainer === startContainer) {\n                endContainer = node;\n                endOffset -= startOffset;\n              }\n\n              startContainer = node;\n              startOffset = 0;\n            }\n\n            el = this.createElement(tag, attributes);\n            replaceWith(node, el);\n            el.appendChild(node);\n          }\n        } while (walker.nextNode()); // If we don't finish inside a text node, offset may have changed.\n\n\n        if (endContainer.nodeType !== TEXT_NODE) {\n          if (node.nodeType === TEXT_NODE) {\n            endContainer = node;\n            endOffset = node.length;\n          } else {\n            // If <br>, we must have just wrapped it, so it must have only\n            // one child\n            endContainer = node.parentNode;\n            endOffset = 1;\n          }\n        } // Now set the selection to as it was before\n\n\n        range = this.createRange(startContainer, startOffset, endContainer, endOffset);\n      }\n\n    return range;\n  };\n\n  proto._removeFormat = function (tag, attributes, range, partial) {\n    // Add bookmark\n    this._saveRangeToBookmark(range); // We need a node in the selection to break the surrounding\n    // formatted text.\n\n\n    var doc = this._doc,\n        fixer;\n\n    if (range.collapsed) {\n      if (cantFocusEmptyTextNodes) {\n        fixer = doc.createTextNode(ZWS);\n\n        this._didAddZWS();\n      } else {\n        fixer = doc.createTextNode('');\n      }\n\n      insertNodeInRange(range, fixer);\n    } // Find block-level ancestor of selection\n\n\n    var root = range.commonAncestorContainer;\n\n    while (isInline(root)) {\n      root = root.parentNode;\n    } // Find text nodes inside formatTags that are not in selection and\n    // add an extra tag with the same formatting.\n\n\n    var startContainer = range.startContainer,\n        startOffset = range.startOffset,\n        endContainer = range.endContainer,\n        endOffset = range.endOffset,\n        toWrap = [],\n        examineNode = function (node, exemplar) {\n      // If the node is completely contained by the range then\n      // we're going to remove all formatting so ignore it.\n      if (isNodeContainedInRange(range, node, false)) {\n        return;\n      }\n\n      var isText = node.nodeType === TEXT_NODE,\n          child,\n          next; // If not at least partially contained, wrap entire contents\n      // in a clone of the tag we're removing and we're done.\n\n      if (!isNodeContainedInRange(range, node, true)) {\n        // Ignore bookmarks and empty text nodes\n        if (node.nodeName !== 'INPUT' && (!isText || node.data)) {\n          toWrap.push([exemplar, node]);\n        }\n\n        return;\n      } // Split any partially selected text nodes.\n\n\n      if (isText) {\n        if (node === endContainer && endOffset !== node.length) {\n          toWrap.push([exemplar, node.splitText(endOffset)]);\n        }\n\n        if (node === startContainer && startOffset) {\n          node.splitText(startOffset);\n          toWrap.push([exemplar, node]);\n        }\n      } // If not a text node, recurse onto all children.\n      // Beware, the tree may be rewritten with each call\n      // to examineNode, hence find the next sibling first.\n      else {\n          for (child = node.firstChild; child; child = next) {\n            next = child.nextSibling;\n            examineNode(child, exemplar);\n          }\n        }\n    },\n        formatTags = Array.prototype.filter.call(root.getElementsByTagName(tag), function (el) {\n      return isNodeContainedInRange(range, el, true) && hasTagAttributes(el, tag, attributes);\n    });\n\n    if (!partial) {\n      formatTags.forEach(function (node) {\n        examineNode(node, node);\n      });\n    } // Now wrap unselected nodes in the tag\n\n\n    toWrap.forEach(function (item) {\n      // [ exemplar, node ] tuple\n      var el = item[0].cloneNode(false),\n          node = item[1];\n      replaceWith(node, el);\n      el.appendChild(node);\n    }); // and remove old formatting tags.\n\n    formatTags.forEach(function (el) {\n      replaceWith(el, empty(el));\n    }); // Merge adjacent inlines:\n\n    this._getRangeAndRemoveBookmark(range);\n\n    if (fixer) {\n      range.collapse(false);\n    }\n\n    mergeInlines(root, range);\n    return range;\n  };\n\n  proto.changeFormat = function (add, remove, range, partial) {\n    // Normalise the arguments and get selection\n    if (!range && !(range = this.getSelection())) {\n      return this;\n    } // Save undo checkpoint\n\n\n    this.saveUndoState(range);\n\n    if (remove) {\n      range = this._removeFormat(remove.tag.toUpperCase(), remove.attributes || {}, range, partial);\n    }\n\n    if (add) {\n      range = this._addFormat(add.tag.toUpperCase(), add.attributes || {}, range);\n    }\n\n    this.setSelection(range);\n\n    this._updatePath(range, true); // We're not still in an undo state\n\n\n    if (!canObserveMutations) {\n      this._docWasChanged();\n    }\n\n    return this;\n  }; // --- Block formatting ---\n\n\n  var tagAfterSplit = {\n    DT: 'DD',\n    DD: 'DT',\n    LI: 'LI',\n    PRE: 'PRE'\n  };\n\n  var splitBlock = function (self, block, node, offset) {\n    var splitTag = tagAfterSplit[block.nodeName],\n        splitProperties = null,\n        nodeAfterSplit = split(node, offset, block.parentNode, self._root),\n        config = self._config;\n\n    if (!splitTag) {\n      splitTag = config.blockTag;\n      splitProperties = config.blockAttributes;\n    } // Make sure the new node is the correct type.\n\n\n    if (!hasTagAttributes(nodeAfterSplit, splitTag, splitProperties)) {\n      block = createElement(nodeAfterSplit.ownerDocument, splitTag, splitProperties);\n\n      if (nodeAfterSplit.dir) {\n        block.dir = nodeAfterSplit.dir;\n      }\n\n      replaceWith(nodeAfterSplit, block);\n      block.appendChild(empty(nodeAfterSplit));\n      nodeAfterSplit = block;\n    }\n\n    return nodeAfterSplit;\n  };\n\n  proto.forEachBlock = function (fn, mutates, range) {\n    if (!range && !(range = this.getSelection())) {\n      return this;\n    } // Save undo checkpoint\n\n\n    if (mutates) {\n      this.saveUndoState(range);\n    }\n\n    var root = this._root;\n    var start = getStartBlockOfRange(range, root);\n    var end = getEndBlockOfRange(range, root);\n\n    if (start && end) {\n      do {\n        if (fn(start) || start === end) {\n          break;\n        }\n      } while (start = getNextBlock(start, root));\n    }\n\n    if (mutates) {\n      this.setSelection(range); // Path may have changed\n\n      this._updatePath(range, true); // We're not still in an undo state\n\n\n      if (!canObserveMutations) {\n        this._docWasChanged();\n      }\n    }\n\n    return this;\n  };\n\n  proto.modifyBlocks = function (modify, range) {\n    if (!range && !(range = this.getSelection())) {\n      return this;\n    } // 1. Save undo checkpoint and bookmark selection\n\n\n    this._recordUndoState(range, this._isInUndoState);\n\n    var root = this._root;\n    var frag; // 2. Expand range to block boundaries\n\n    expandRangeToBlockBoundaries(range, root); // 3. Remove range.\n\n    moveRangeBoundariesUpTree(range, root, root, root);\n    frag = extractContentsOfRange(range, root, root); // 4. Modify tree of fragment and reinsert.\n\n    insertNodeInRange(range, modify.call(this, frag)); // 5. Merge containers at edges\n\n    if (range.endOffset < range.endContainer.childNodes.length) {\n      mergeContainers(range.endContainer.childNodes[range.endOffset], root);\n    }\n\n    mergeContainers(range.startContainer.childNodes[range.startOffset], root); // 6. Restore selection\n\n    this._getRangeAndRemoveBookmark(range);\n\n    this.setSelection(range);\n\n    this._updatePath(range, true); // 7. We're not still in an undo state\n\n\n    if (!canObserveMutations) {\n      this._docWasChanged();\n    }\n\n    return this;\n  };\n\n  var increaseBlockQuoteLevel = function (frag) {\n    return this.createElement('BLOCKQUOTE', this._config.tagAttributes.blockquote, [frag]);\n  };\n\n  var decreaseBlockQuoteLevel = function (frag) {\n    var root = this._root;\n    var blockquotes = frag.querySelectorAll('blockquote');\n    Array.prototype.filter.call(blockquotes, function (el) {\n      return !getNearest(el.parentNode, root, 'BLOCKQUOTE');\n    }).forEach(function (el) {\n      replaceWith(el, empty(el));\n    });\n    return frag;\n  };\n\n  var removeBlockQuote = function ()\n  /* frag */\n  {\n    return this.createDefaultBlock([this.createElement('INPUT', {\n      id: startSelectionId,\n      type: 'hidden'\n    }), this.createElement('INPUT', {\n      id: endSelectionId,\n      type: 'hidden'\n    })]);\n  };\n\n  var makeList = function (self, frag, type) {\n    var walker = getBlockWalker(frag, self._root),\n        node,\n        tag,\n        prev,\n        newLi,\n        tagAttributes = self._config.tagAttributes,\n        listAttrs = tagAttributes[type.toLowerCase()],\n        listItemAttrs = tagAttributes.li;\n\n    while (node = walker.nextNode()) {\n      if (node.parentNode.nodeName === 'LI') {\n        node = node.parentNode;\n        walker.currentNode = node.lastChild;\n      }\n\n      if (node.nodeName !== 'LI') {\n        newLi = self.createElement('LI', listItemAttrs);\n\n        if (node.dir) {\n          newLi.dir = node.dir;\n        } // Have we replaced the previous block with a new <ul>/<ol>?\n\n\n        if ((prev = node.previousSibling) && prev.nodeName === type) {\n          prev.appendChild(newLi);\n          detach(node);\n        } // Otherwise, replace this block with the <ul>/<ol>\n        else {\n            replaceWith(node, self.createElement(type, listAttrs, [newLi]));\n          }\n\n        newLi.appendChild(empty(node));\n        walker.currentNode = newLi;\n      } else {\n        node = node.parentNode;\n        tag = node.nodeName;\n\n        if (tag !== type && /^[OU]L$/.test(tag)) {\n          replaceWith(node, self.createElement(type, listAttrs, [empty(node)]));\n        }\n      }\n    }\n  };\n\n  var makeUnorderedList = function (frag) {\n    makeList(this, frag, 'UL');\n    return frag;\n  };\n\n  var makeOrderedList = function (frag) {\n    makeList(this, frag, 'OL');\n    return frag;\n  };\n\n  var removeList = function (frag) {\n    var lists = frag.querySelectorAll('UL, OL'),\n        items = frag.querySelectorAll('LI'),\n        root = this._root,\n        i,\n        l,\n        list,\n        listFrag,\n        item;\n\n    for (i = 0, l = lists.length; i < l; i += 1) {\n      list = lists[i];\n      listFrag = empty(list);\n      fixContainer(listFrag, root);\n      replaceWith(list, listFrag);\n    }\n\n    for (i = 0, l = items.length; i < l; i += 1) {\n      item = items[i];\n\n      if (isBlock(item)) {\n        replaceWith(item, this.createDefaultBlock([empty(item)]));\n      } else {\n        fixContainer(item, root);\n        replaceWith(item, empty(item));\n      }\n    }\n\n    return frag;\n  };\n\n  var getListSelection = function (range, root) {\n    // Get start+end li in single common ancestor\n    var list = range.commonAncestorContainer;\n    var startLi = range.startContainer;\n    var endLi = range.endContainer;\n\n    while (list && list !== root && !/^[OU]L$/.test(list.nodeName)) {\n      list = list.parentNode;\n    }\n\n    if (!list || list === root) {\n      return null;\n    }\n\n    if (startLi === list) {\n      startLi = startLi.childNodes[range.startOffset];\n    }\n\n    if (endLi === list) {\n      endLi = endLi.childNodes[range.endOffset];\n    }\n\n    while (startLi && startLi.parentNode !== list) {\n      startLi = startLi.parentNode;\n    }\n\n    while (endLi && endLi.parentNode !== list) {\n      endLi = endLi.parentNode;\n    }\n\n    return [list, startLi, endLi];\n  };\n\n  proto.increaseListLevel = function (range) {\n    if (!range && !(range = this.getSelection())) {\n      return this.focus();\n    }\n\n    var root = this._root;\n    var listSelection = getListSelection(range, root);\n\n    if (!listSelection) {\n      return this.focus();\n    }\n\n    var list = listSelection[0];\n    var startLi = listSelection[1];\n    var endLi = listSelection[2];\n\n    if (!startLi || startLi === list.firstChild) {\n      return this.focus();\n    } // Save undo checkpoint and bookmark selection\n\n\n    this._recordUndoState(range, this._isInUndoState); // Increase list depth\n\n\n    var type = list.nodeName;\n    var newParent = startLi.previousSibling;\n    var listAttrs, next;\n\n    if (newParent.nodeName !== type) {\n      listAttrs = this._config.tagAttributes[type.toLowerCase()];\n      newParent = this.createElement(type, listAttrs);\n      list.insertBefore(newParent, startLi);\n    }\n\n    do {\n      next = startLi === endLi ? null : startLi.nextSibling;\n      newParent.appendChild(startLi);\n    } while (startLi = next);\n\n    next = newParent.nextSibling;\n\n    if (next) {\n      mergeContainers(next, root);\n    } // Restore selection\n\n\n    this._getRangeAndRemoveBookmark(range);\n\n    this.setSelection(range);\n\n    this._updatePath(range, true); // We're not still in an undo state\n\n\n    if (!canObserveMutations) {\n      this._docWasChanged();\n    }\n\n    return this.focus();\n  };\n\n  proto.decreaseListLevel = function (range) {\n    if (!range && !(range = this.getSelection())) {\n      return this.focus();\n    }\n\n    var root = this._root;\n    var listSelection = getListSelection(range, root);\n\n    if (!listSelection) {\n      return this.focus();\n    }\n\n    var list = listSelection[0];\n    var startLi = listSelection[1];\n    var endLi = listSelection[2];\n    var newParent, next, insertBefore, makeNotList;\n\n    if (!startLi) {\n      startLi = list.firstChild;\n    }\n\n    if (!endLi) {\n      endLi = list.lastChild;\n    } // Save undo checkpoint and bookmark selection\n\n\n    this._recordUndoState(range, this._isInUndoState);\n\n    if (startLi) {\n      // Find the new parent list node\n      newParent = list.parentNode; // Split list if necesary\n\n      insertBefore = !endLi.nextSibling ? list.nextSibling : split(list, endLi.nextSibling, newParent, root);\n\n      if (newParent !== root && newParent.nodeName === 'LI') {\n        newParent = newParent.parentNode;\n\n        while (insertBefore) {\n          next = insertBefore.nextSibling;\n          endLi.appendChild(insertBefore);\n          insertBefore = next;\n        }\n\n        insertBefore = list.parentNode.nextSibling;\n      }\n\n      makeNotList = !/^[OU]L$/.test(newParent.nodeName);\n\n      do {\n        next = startLi === endLi ? null : startLi.nextSibling;\n        list.removeChild(startLi);\n\n        if (makeNotList && startLi.nodeName === 'LI') {\n          startLi = this.createDefaultBlock([empty(startLi)]);\n        }\n\n        newParent.insertBefore(startLi, insertBefore);\n      } while (startLi = next);\n    }\n\n    if (!list.firstChild) {\n      detach(list);\n    }\n\n    if (insertBefore) {\n      mergeContainers(insertBefore, root);\n    } // Restore selection\n\n\n    this._getRangeAndRemoveBookmark(range);\n\n    this.setSelection(range);\n\n    this._updatePath(range, true); // We're not still in an undo state\n\n\n    if (!canObserveMutations) {\n      this._docWasChanged();\n    }\n\n    return this.focus();\n  };\n\n  proto._ensureBottomLine = function () {\n    var root = this._root;\n    var last = root.lastElementChild;\n\n    if (!last || last.nodeName !== this._config.blockTag || !isBlock(last)) {\n      root.appendChild(this.createDefaultBlock());\n    }\n  }; // --- Keyboard interaction ---\n\n\n  proto.setKeyHandler = function (key, fn) {\n    this._keyHandlers[key] = fn;\n    return this;\n  }; // --- Get/Set data ---\n\n\n  proto._getHTML = function () {\n    return this._root.innerHTML;\n  };\n\n  proto._setHTML = function (html) {\n    var root = this._root;\n    var node = root;\n    node.innerHTML = html;\n\n    do {\n      fixCursor(node, root);\n    } while (node = getNextBlock(node, root));\n\n    this._ignoreChange = true;\n  };\n\n  proto.getHTML = function (withBookMark) {\n    var brs = [],\n        root,\n        node,\n        fixer,\n        html,\n        l,\n        range;\n\n    if (withBookMark && (range = this.getSelection())) {\n      this._saveRangeToBookmark(range);\n    }\n\n    if (useTextFixer) {\n      root = this._root;\n      node = root;\n\n      while (node = getNextBlock(node, root)) {\n        if (!node.textContent && !node.querySelector('BR')) {\n          fixer = this.createElement('BR');\n          node.appendChild(fixer);\n          brs.push(fixer);\n        }\n      }\n    }\n\n    html = this._getHTML().replace(/\\u200B/g, '');\n\n    if (useTextFixer) {\n      l = brs.length;\n\n      while (l--) {\n        detach(brs[l]);\n      }\n    }\n\n    if (range) {\n      this._getRangeAndRemoveBookmark(range);\n    }\n\n    return html;\n  };\n\n  proto.setHTML = function (html) {\n    var config = this._config;\n    var sanitizeToDOMFragment = config.isSetHTMLSanitized ? config.sanitizeToDOMFragment : null;\n    var root = this._root;\n    var div, frag, child; // Parse HTML into DOM tree\n\n    if (typeof sanitizeToDOMFragment === 'function') {\n      frag = sanitizeToDOMFragment(html, false, this);\n    } else {\n      div = this.createElement('DIV');\n      div.innerHTML = html;\n      frag = this._doc.createDocumentFragment();\n      frag.appendChild(empty(div));\n    }\n\n    cleanTree(frag, config);\n    cleanupBRs(frag, root, false);\n    fixContainer(frag, root); // Fix cursor\n\n    var node = frag;\n\n    while (node = getNextBlock(node, root)) {\n      fixCursor(node, root);\n    } // Don't fire an input event\n\n\n    this._ignoreChange = true; // Remove existing root children\n\n    while (child = root.lastChild) {\n      root.removeChild(child);\n    } // And insert new content\n\n\n    root.appendChild(frag);\n    fixCursor(root, root); // Reset the undo stack\n\n    this._undoIndex = -1;\n    this._undoStack.length = 0;\n    this._undoStackLength = 0;\n    this._isInUndoState = false; // Record undo state\n\n    var range = this._getRangeAndRemoveBookmark() || this.createRange(root.firstChild, 0);\n    this.saveUndoState(range); // IE will also set focus when selecting text so don't use\n    // setSelection. Instead, just store it in lastSelection, so if\n    // anything calls getSelection before first focus, we have a range\n    // to return.\n\n    this._lastSelection = range;\n    enableRestoreSelection.call(this);\n\n    this._updatePath(range, true);\n\n    return this;\n  };\n\n  proto.insertElement = function (el, range) {\n    if (!range) {\n      range = this.getSelection();\n    }\n\n    range.collapse(true);\n\n    if (isInline(el)) {\n      insertNodeInRange(range, el);\n      range.setStartAfter(el);\n    } else {\n      // Get containing block node.\n      var root = this._root;\n      var splitNode = getStartBlockOfRange(range, root) || root;\n      var parent, nodeAfterSplit; // While at end of container node, move up DOM tree.\n\n      while (splitNode !== root && !splitNode.nextSibling) {\n        splitNode = splitNode.parentNode;\n      } // If in the middle of a container node, split up to root.\n\n\n      if (splitNode !== root) {\n        parent = splitNode.parentNode;\n        nodeAfterSplit = split(parent, splitNode.nextSibling, root, root);\n      }\n\n      if (nodeAfterSplit) {\n        root.insertBefore(el, nodeAfterSplit);\n      } else {\n        root.appendChild(el); // Insert blank line below block.\n\n        nodeAfterSplit = this.createDefaultBlock();\n        root.appendChild(nodeAfterSplit);\n      }\n\n      range.setStart(nodeAfterSplit, 0);\n      range.setEnd(nodeAfterSplit, 0);\n      moveRangeBoundariesDownTree(range);\n    }\n\n    this.focus();\n    this.setSelection(range);\n\n    this._updatePath(range);\n\n    if (!canObserveMutations) {\n      this._docWasChanged();\n    }\n\n    return this;\n  };\n\n  proto.insertImage = function (src, attributes) {\n    var img = this.createElement('IMG', mergeObjects({\n      src: src\n    }, attributes, true));\n    this.insertElement(img);\n    return img;\n  };\n\n  proto.linkRegExp = /\\b((?:(?:ht|f)tps?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,}\\/)(?:[^\\s()<>]+|\\([^\\s()<>]+\\))+(?:\\((?:[^\\s()<>]+|(?:\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’]))|([\\w\\-.%+]+@(?:[\\w\\-]+\\.)+[A-Z]{2,}\\b)(?:\\?[^&?\\s]+=[^&?\\s]+(?:&[^&?\\s]+=[^&?\\s]+)*)?/i;\n\n  var addLinks = function (frag, root, self) {\n    var doc = frag.ownerDocument;\n    var walker = new TreeWalker(frag, SHOW_TEXT, function (node) {\n      return !getNearest(node, root, 'A');\n    });\n    var linkRegExp = self.linkRegExp;\n    var defaultAttributes = self._config.tagAttributes.a;\n    var node, data, parent, match, index, endIndex, child;\n\n    if (!linkRegExp) {\n      return;\n    }\n\n    while (node = walker.nextNode()) {\n      data = node.data;\n      parent = node.parentNode;\n\n      while (match = linkRegExp.exec(data)) {\n        index = match.index;\n        endIndex = index + match[0].length;\n\n        if (index) {\n          child = doc.createTextNode(data.slice(0, index));\n          parent.insertBefore(child, node);\n        }\n\n        child = self.createElement('A', mergeObjects({\n          href: match[1] ? /^(?:ht|f)tps?:/i.test(match[1]) ? match[1] : 'http://' + match[1] : 'mailto:' + match[0]\n        }, defaultAttributes, false));\n        child.textContent = data.slice(index, endIndex);\n        parent.insertBefore(child, node);\n        node.data = data = data.slice(endIndex);\n      }\n    }\n  }; // Insert HTML at the cursor location. If the selection is not collapsed\n  // insertTreeFragmentIntoRange will delete the selection so that it is replaced\n  // by the html being inserted.\n\n\n  proto.insertHTML = function (html, isPaste) {\n    var config = this._config;\n    var sanitizeToDOMFragment = config.isInsertedHTMLSanitized ? config.sanitizeToDOMFragment : null;\n    var range = this.getSelection();\n    var doc = this._doc;\n    var startFragmentIndex, endFragmentIndex;\n    var div, frag, root, node, event; // Edge doesn't just copy the fragment, but includes the surrounding guff\n    // including the full <head> of the page. Need to strip this out. If\n    // available use DOMPurify to parse and sanitise.\n\n    if (typeof sanitizeToDOMFragment === 'function') {\n      frag = sanitizeToDOMFragment(html, isPaste, this);\n    } else {\n      if (isPaste) {\n        startFragmentIndex = html.indexOf('<!--StartFragment-->');\n        endFragmentIndex = html.lastIndexOf('<!--EndFragment-->');\n\n        if (startFragmentIndex > -1 && endFragmentIndex > -1) {\n          html = html.slice(startFragmentIndex + 20, endFragmentIndex);\n        }\n      } // Wrap with <tr> if html contains dangling <td> tags\n\n\n      if (/<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test(html)) {\n        html = '<TR>' + html + '</TR>';\n      } // Wrap with <table> if html contains dangling <tr> tags\n\n\n      if (/<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test(html)) {\n        html = '<TABLE>' + html + '</TABLE>';\n      } // Parse HTML into DOM tree\n\n\n      div = this.createElement('DIV');\n      div.innerHTML = html;\n      frag = doc.createDocumentFragment();\n      frag.appendChild(empty(div));\n    } // Record undo checkpoint\n\n\n    this.saveUndoState(range);\n\n    try {\n      root = this._root;\n      node = frag;\n      event = {\n        fragment: frag,\n        preventDefault: function () {\n          this.defaultPrevented = true;\n        },\n        defaultPrevented: false\n      };\n      addLinks(frag, frag, this);\n      cleanTree(frag, config);\n      cleanupBRs(frag, root, false);\n      removeEmptyInlines(frag);\n      frag.normalize();\n\n      while (node = getNextBlock(node, frag)) {\n        fixCursor(node, root);\n      }\n\n      if (isPaste) {\n        this.fireEvent('willPaste', event);\n      }\n\n      if (!event.defaultPrevented) {\n        insertTreeFragmentIntoRange(range, event.fragment, root);\n\n        if (!canObserveMutations) {\n          this._docWasChanged();\n        }\n\n        range.collapse(false);\n\n        this._ensureBottomLine();\n      }\n\n      this.setSelection(range);\n\n      this._updatePath(range, true); // Safari sometimes loses focus after paste. Weird.\n\n\n      if (isPaste) {\n        this.focus();\n      }\n    } catch (error) {\n      this.didError(error);\n    }\n\n    return this;\n  };\n\n  var escapeHTMLFragement = function (text) {\n    return text.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;').split('\"').join('&quot;');\n  };\n\n  proto.insertPlainText = function (plainText, isPaste) {\n    var range = this.getSelection();\n\n    if (range.collapsed && getNearest(range.startContainer, this._root, 'PRE')) {\n      var node = range.startContainer;\n      var offset = range.startOffset;\n      var text, event;\n\n      if (!node || node.nodeType !== TEXT_NODE) {\n        text = this._doc.createTextNode('');\n        node.insertBefore(text, node.childNodes[offset]);\n        node = text;\n        offset = 0;\n      }\n\n      event = {\n        text: plainText,\n        preventDefault: function () {\n          this.defaultPrevented = true;\n        },\n        defaultPrevented: false\n      };\n\n      if (isPaste) {\n        this.fireEvent('willPaste', event);\n      }\n\n      if (!event.defaultPrevented) {\n        plainText = event.text;\n        node.insertData(offset, plainText);\n        range.setStart(node, offset + plainText.length);\n        range.collapse(true);\n      }\n\n      this.setSelection(range);\n      return this;\n    }\n\n    var lines = plainText.split('\\n');\n    var config = this._config;\n    var tag = config.blockTag;\n    var attributes = config.blockAttributes;\n    var closeBlock = '</' + tag + '>';\n    var openBlock = '<' + tag;\n    var attr, i, l, line;\n\n    for (attr in attributes) {\n      openBlock += ' ' + attr + '=\"' + escapeHTMLFragement(attributes[attr]) + '\"';\n    }\n\n    openBlock += '>';\n\n    for (i = 0, l = lines.length; i < l; i += 1) {\n      line = lines[i];\n      line = escapeHTMLFragement(line).replace(/ (?= )/g, '&nbsp;'); // Wrap each line in <div></div>\n\n      lines[i] = openBlock + (line || '<BR>') + closeBlock;\n    }\n\n    return this.insertHTML(lines.join(''), isPaste);\n  }; // --- Formatting ---\n\n\n  var command = function (method, arg, arg2) {\n    return function () {\n      this[method](arg, arg2);\n      return this.focus();\n    };\n  };\n\n  proto.addStyles = function (styles) {\n    if (styles) {\n      var head = this._doc.documentElement.firstChild,\n          style = this.createElement('STYLE', {\n        type: 'text/css'\n      });\n      style.appendChild(this._doc.createTextNode(styles));\n      head.appendChild(style);\n    }\n\n    return this;\n  };\n\n  proto.bold = command('changeFormat', {\n    tag: 'B'\n  });\n  proto.italic = command('changeFormat', {\n    tag: 'I'\n  });\n  proto.underline = command('changeFormat', {\n    tag: 'U'\n  });\n  proto.strikethrough = command('changeFormat', {\n    tag: 'S'\n  });\n  proto.subscript = command('changeFormat', {\n    tag: 'SUB'\n  }, {\n    tag: 'SUP'\n  });\n  proto.superscript = command('changeFormat', {\n    tag: 'SUP'\n  }, {\n    tag: 'SUB'\n  });\n  proto.removeBold = command('changeFormat', null, {\n    tag: 'B'\n  });\n  proto.removeItalic = command('changeFormat', null, {\n    tag: 'I'\n  });\n  proto.removeUnderline = command('changeFormat', null, {\n    tag: 'U'\n  });\n  proto.removeStrikethrough = command('changeFormat', null, {\n    tag: 'S'\n  });\n  proto.removeSubscript = command('changeFormat', null, {\n    tag: 'SUB'\n  });\n  proto.removeSuperscript = command('changeFormat', null, {\n    tag: 'SUP'\n  });\n\n  proto.makeLink = function (url, attributes) {\n    var range = this.getSelection();\n\n    if (range.collapsed) {\n      var protocolEnd = url.indexOf(':') + 1;\n\n      if (protocolEnd) {\n        while (url[protocolEnd] === '/') {\n          protocolEnd += 1;\n        }\n      }\n\n      insertNodeInRange(range, this._doc.createTextNode(url.slice(protocolEnd)));\n    }\n\n    attributes = mergeObjects(mergeObjects({\n      href: url\n    }, attributes, true), this._config.tagAttributes.a, false);\n    this.changeFormat({\n      tag: 'A',\n      attributes: attributes\n    }, {\n      tag: 'A'\n    }, range);\n    return this.focus();\n  };\n\n  proto.removeLink = function () {\n    this.changeFormat(null, {\n      tag: 'A'\n    }, this.getSelection(), true);\n    return this.focus();\n  };\n\n  proto.setFontFace = function (name) {\n    var className = this._config.classNames.fontFamily;\n    this.changeFormat(name ? {\n      tag: 'SPAN',\n      attributes: {\n        'class': className,\n        style: 'font-family: ' + name + ', sans-serif;'\n      }\n    } : null, {\n      tag: 'SPAN',\n      attributes: {\n        'class': className\n      }\n    });\n    return this.focus();\n  };\n\n  proto.setFontSize = function (size) {\n    var className = this._config.classNames.fontSize;\n    this.changeFormat(size ? {\n      tag: 'SPAN',\n      attributes: {\n        'class': className,\n        style: 'font-size: ' + (typeof size === 'number' ? size + 'px' : size)\n      }\n    } : null, {\n      tag: 'SPAN',\n      attributes: {\n        'class': className\n      }\n    });\n    return this.focus();\n  };\n\n  proto.setTextColour = function (colour) {\n    var className = this._config.classNames.colour;\n    this.changeFormat(colour ? {\n      tag: 'SPAN',\n      attributes: {\n        'class': className,\n        style: 'color:' + colour\n      }\n    } : null, {\n      tag: 'SPAN',\n      attributes: {\n        'class': className\n      }\n    });\n    return this.focus();\n  };\n\n  proto.setHighlightColour = function (colour) {\n    var className = this._config.classNames.highlight;\n    this.changeFormat(colour ? {\n      tag: 'SPAN',\n      attributes: {\n        'class': className,\n        style: 'background-color:' + colour\n      }\n    } : colour, {\n      tag: 'SPAN',\n      attributes: {\n        'class': className\n      }\n    });\n    return this.focus();\n  };\n\n  proto.setTextAlignment = function (alignment) {\n    this.forEachBlock(function (block) {\n      var className = block.className.split(/\\s+/).filter(function (klass) {\n        return !!klass && !/^align/.test(klass);\n      }).join(' ');\n\n      if (alignment) {\n        block.className = className + ' align-' + alignment;\n        block.style.textAlign = alignment;\n      } else {\n        block.className = className;\n        block.style.textAlign = '';\n      }\n    }, true);\n    return this.focus();\n  };\n\n  proto.setTextDirection = function (direction) {\n    this.forEachBlock(function (block) {\n      if (direction) {\n        block.dir = direction;\n      } else {\n        block.removeAttribute('dir');\n      }\n    }, true);\n    return this.focus();\n  }; // ---\n\n\n  var addPre = function (frag) {\n    var root = this._root;\n    var document = this._doc;\n    var output = document.createDocumentFragment();\n    var walker = getBlockWalker(frag, root);\n    var node; // 1. Extract inline content; drop all blocks and contains.\n\n    while (node = walker.nextNode()) {\n      // 2. Replace <br> with \\n in content\n      var nodes = node.querySelectorAll('BR');\n      var brBreaksLine = [];\n      var l = nodes.length;\n      var i, br; // Must calculate whether the <br> breaks a line first, because if we\n      // have two <br>s next to each other, after the first one is converted\n      // to a block split, the second will be at the end of a block and\n      // therefore seem to not be a line break. But in its original context it\n      // was, so we should also convert it to a block split.\n\n      for (i = 0; i < l; i += 1) {\n        brBreaksLine[i] = isLineBreak(nodes[i], false);\n      }\n\n      while (l--) {\n        br = nodes[l];\n\n        if (!brBreaksLine[l]) {\n          detach(br);\n        } else {\n          replaceWith(br, document.createTextNode('\\n'));\n        }\n      } // 3. Remove <code>; its format clashes with <pre>\n\n\n      nodes = node.querySelectorAll('CODE');\n      l = nodes.length;\n\n      while (l--) {\n        detach(nodes[l]);\n      }\n\n      if (output.childNodes.length) {\n        output.appendChild(document.createTextNode('\\n'));\n      }\n\n      output.appendChild(empty(node));\n    } // 4. Replace nbsp with regular sp\n\n\n    walker = new TreeWalker(output, SHOW_TEXT);\n\n    while (node = walker.nextNode()) {\n      node.data = node.data.replace(/ /g, ' '); // nbsp -> sp\n    }\n\n    output.normalize();\n    return fixCursor(this.createElement('PRE', this._config.tagAttributes.pre, [output]), root);\n  };\n\n  var removePre = function (frag) {\n    var document = this._doc;\n    var root = this._root;\n    var pres = frag.querySelectorAll('PRE');\n    var l = pres.length;\n    var pre, walker, node, value, contents, index;\n\n    while (l--) {\n      pre = pres[l];\n      walker = new TreeWalker(pre, SHOW_TEXT);\n\n      while (node = walker.nextNode()) {\n        value = node.data;\n        value = value.replace(/ (?= )/g, ' '); // sp -> nbsp\n\n        contents = document.createDocumentFragment();\n\n        while ((index = value.indexOf('\\n')) > -1) {\n          contents.appendChild(document.createTextNode(value.slice(0, index)));\n          contents.appendChild(document.createElement('BR'));\n          value = value.slice(index + 1);\n        }\n\n        node.parentNode.insertBefore(contents, node);\n        node.data = value;\n      }\n\n      fixContainer(pre, root);\n      replaceWith(pre, empty(pre));\n    }\n\n    return frag;\n  };\n\n  proto.code = function () {\n    var range = this.getSelection();\n\n    if (range.collapsed || isContainer(range.commonAncestorContainer)) {\n      this.modifyBlocks(addPre, range);\n    } else {\n      this.changeFormat({\n        tag: 'CODE',\n        attributes: this._config.tagAttributes.code\n      }, null, range);\n    }\n\n    return this.focus();\n  };\n\n  proto.removeCode = function () {\n    var range = this.getSelection();\n    var ancestor = range.commonAncestorContainer;\n    var inPre = getNearest(ancestor, this._root, 'PRE');\n\n    if (inPre) {\n      this.modifyBlocks(removePre, range);\n    } else {\n      this.changeFormat(null, {\n        tag: 'CODE'\n      }, range);\n    }\n\n    return this.focus();\n  };\n\n  proto.toggleCode = function () {\n    if (this.hasFormat('PRE') || this.hasFormat('CODE')) {\n      this.removeCode();\n    } else {\n      this.code();\n    }\n\n    return this;\n  }; // ---\n\n\n  function removeFormatting(self, root, clean) {\n    var node, next;\n\n    for (node = root.firstChild; node; node = next) {\n      next = node.nextSibling;\n\n      if (isInline(node)) {\n        if (node.nodeType === TEXT_NODE || node.nodeName === 'BR' || node.nodeName === 'IMG') {\n          clean.appendChild(node);\n          continue;\n        }\n      } else if (isBlock(node)) {\n        clean.appendChild(self.createDefaultBlock([removeFormatting(self, node, self._doc.createDocumentFragment())]));\n        continue;\n      }\n\n      removeFormatting(self, node, clean);\n    }\n\n    return clean;\n  }\n\n  proto.removeAllFormatting = function (range) {\n    if (!range && !(range = this.getSelection()) || range.collapsed) {\n      return this;\n    }\n\n    var root = this._root;\n    var stopNode = range.commonAncestorContainer;\n\n    while (stopNode && !isBlock(stopNode)) {\n      stopNode = stopNode.parentNode;\n    }\n\n    if (!stopNode) {\n      expandRangeToBlockBoundaries(range, root);\n      stopNode = root;\n    }\n\n    if (stopNode.nodeType === TEXT_NODE) {\n      return this;\n    } // Record undo point\n\n\n    this.saveUndoState(range); // Avoid splitting where we're already at edges.\n\n    moveRangeBoundariesUpTree(range, stopNode, stopNode, root); // Split the selection up to the block, or if whole selection in same\n    // block, expand range boundaries to ends of block and split up to root.\n\n    var doc = stopNode.ownerDocument;\n    var startContainer = range.startContainer;\n    var startOffset = range.startOffset;\n    var endContainer = range.endContainer;\n    var endOffset = range.endOffset; // Split end point first to avoid problems when end and start\n    // in same container.\n\n    var formattedNodes = doc.createDocumentFragment();\n    var cleanNodes = doc.createDocumentFragment();\n    var nodeAfterSplit = split(endContainer, endOffset, stopNode, root);\n    var nodeInSplit = split(startContainer, startOffset, stopNode, root);\n    var nextNode, childNodes; // Then replace contents in split with a cleaned version of the same:\n    // blocks become default blocks, text and leaf nodes survive, everything\n    // else is obliterated.\n\n    while (nodeInSplit !== nodeAfterSplit) {\n      nextNode = nodeInSplit.nextSibling;\n      formattedNodes.appendChild(nodeInSplit);\n      nodeInSplit = nextNode;\n    }\n\n    removeFormatting(this, formattedNodes, cleanNodes);\n    cleanNodes.normalize();\n    nodeInSplit = cleanNodes.firstChild;\n    nextNode = cleanNodes.lastChild; // Restore selection\n\n    childNodes = stopNode.childNodes;\n\n    if (nodeInSplit) {\n      stopNode.insertBefore(cleanNodes, nodeAfterSplit);\n      startOffset = indexOf.call(childNodes, nodeInSplit);\n      endOffset = indexOf.call(childNodes, nextNode) + 1;\n    } else {\n      startOffset = indexOf.call(childNodes, nodeAfterSplit);\n      endOffset = startOffset;\n    } // Merge text nodes at edges, if possible\n\n\n    range.setStart(stopNode, startOffset);\n    range.setEnd(stopNode, endOffset);\n    mergeInlines(stopNode, range); // And move back down the tree\n\n    moveRangeBoundariesDownTree(range);\n    this.setSelection(range);\n\n    this._updatePath(range, true);\n\n    return this.focus();\n  };\n\n  proto.increaseQuoteLevel = command('modifyBlocks', increaseBlockQuoteLevel);\n  proto.decreaseQuoteLevel = command('modifyBlocks', decreaseBlockQuoteLevel);\n  proto.makeUnorderedList = command('modifyBlocks', makeUnorderedList);\n  proto.makeOrderedList = command('modifyBlocks', makeOrderedList);\n  proto.removeList = command('modifyBlocks', removeList); // Node.js exports\n\n  Squire.isInline = isInline;\n  Squire.isBlock = isBlock;\n  Squire.isContainer = isContainer;\n  Squire.getBlockWalker = getBlockWalker;\n  Squire.getPreviousBlock = getPreviousBlock;\n  Squire.getNextBlock = getNextBlock;\n  Squire.areAlike = areAlike;\n  Squire.hasTagAttributes = hasTagAttributes;\n  Squire.getNearest = getNearest;\n  Squire.isOrContains = isOrContains;\n  Squire.detach = detach;\n  Squire.replaceWith = replaceWith;\n  Squire.empty = empty; // Range.js exports\n\n  Squire.getNodeBefore = getNodeBefore;\n  Squire.getNodeAfter = getNodeAfter;\n  Squire.insertNodeInRange = insertNodeInRange;\n  Squire.extractContentsOfRange = extractContentsOfRange;\n  Squire.deleteContentsOfRange = deleteContentsOfRange;\n  Squire.insertTreeFragmentIntoRange = insertTreeFragmentIntoRange;\n  Squire.isNodeContainedInRange = isNodeContainedInRange;\n  Squire.moveRangeBoundariesDownTree = moveRangeBoundariesDownTree;\n  Squire.moveRangeBoundariesUpTree = moveRangeBoundariesUpTree;\n  Squire.getStartBlockOfRange = getStartBlockOfRange;\n  Squire.getEndBlockOfRange = getEndBlockOfRange;\n  Squire.contentWalker = contentWalker;\n  Squire.rangeDoesStartAtBlockBoundary = rangeDoesStartAtBlockBoundary;\n  Squire.rangeDoesEndAtBlockBoundary = rangeDoesEndAtBlockBoundary;\n  Squire.expandRangeToBlockBoundaries = expandRangeToBlockBoundaries; // Clipboard.js exports\n\n  Squire.onPaste = onPaste; // Editor.js exports\n\n  Squire.addLinks = addLinks;\n  Squire.splitBlock = splitBlock;\n  Squire.startSelectionId = startSelectionId;\n  Squire.endSelectionId = endSelectionId;\n\n  if (true) {\n    module.exports = Squire;\n  } else {}\n}(document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL3NxdWlyZS5qcz83NTE1Il0sIm5hbWVzIjpbInNxIiwiZG9jIiwidW5kZWZpbmVkIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiRUxFTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwiRE9DVU1FTlRfTk9ERSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJTSE9XX0VMRU1FTlQiLCJTSE9XX1RFWFQiLCJTVEFSVF9UT19TVEFSVCIsIlNUQVJUX1RPX0VORCIsIkVORF9UT19FTkQiLCJFTkRfVE9fU1RBUlQiLCJaV1MiLCJ3aW4iLCJkZWZhdWx0VmlldyIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNBbmRyb2lkIiwidGVzdCIsImlzSU9TIiwiaXNNYWMiLCJpc1dpbiIsImlzR2Vja28iLCJpc0lFbHQxMSIsImlzUHJlc3RvIiwib3BlcmEiLCJpc0VkZ2UiLCJpc1dlYktpdCIsImlzSUUiLCJjdHJsS2V5IiwidXNlVGV4dEZpeGVyIiwiY2FudEZvY3VzRW1wdHlUZXh0Tm9kZXMiLCJsb3Nlc1NlbGVjdGlvbk9uQmx1ciIsImNhbk9ic2VydmVNdXRhdGlvbnMiLCJNdXRhdGlvbk9ic2VydmVyIiwiY2FuV2Vha01hcCIsIldlYWtNYXAiLCJub3RXUyIsImluZGV4T2YiLCJBcnJheSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvIiwiRiIsInR5cGVUb0JpdEFycmF5IiwiYWx3YXlzIiwiVHJlZVdhbGtlciIsInJvb3QiLCJub2RlVHlwZSIsImZpbHRlciIsImN1cnJlbnROb2RlIiwibmV4dE5vZGUiLCJjdXJyZW50Iiwibm9kZSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudE5vZGUiLCJwcmV2aW91c05vZGUiLCJwcmV2aW91c1NpYmxpbmciLCJsYXN0Q2hpbGQiLCJwcmV2aW91c1BPTm9kZSIsImlubGluZU5vZGVOYW1lcyIsImxlYWZOb2RlTmFtZXMiLCJCUiIsIkhSIiwiSUZSQU1FIiwiSU1HIiwiSU5QVVQiLCJldmVyeSIsIm5vZGVMaXN0IiwiZm4iLCJsIiwibGVuZ3RoIiwiVU5LTk9XTiIsIklOTElORSIsIkJMT0NLIiwiQ09OVEFJTkVSIiwibm9kZUNhdGVnb3J5Q2FjaGUiLCJpc0xlYWYiLCJub2RlTmFtZSIsImdldE5vZGVDYXRlZ29yeSIsImhhcyIsImdldCIsIm5vZGVDYXRlZ29yeSIsImNoaWxkTm9kZXMiLCJpc0lubGluZSIsInNldCIsImlzQmxvY2siLCJpc0NvbnRhaW5lciIsImdldEJsb2NrV2Fsa2VyIiwid2Fsa2VyIiwiZ2V0UHJldmlvdXNCbG9jayIsImdldE5leHRCbG9jayIsImlzRW1wdHlCbG9jayIsImJsb2NrIiwidGV4dENvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwiYXJlQWxpa2UiLCJub2RlMiIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImhhc1RhZ0F0dHJpYnV0ZXMiLCJ0YWciLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsImdldE5lYXJlc3QiLCJpc09yQ29udGFpbnMiLCJwYXJlbnQiLCJnZXRQYXRoIiwiY29uZmlnIiwicGF0aCIsImlkIiwiY2xhc3NOYW1lcyIsImRpciIsInN0eWxlTmFtZXMiLCJ0cmltIiwic3BsaXQiLCJzb3J0Iiwiam9pbiIsImNhbGwiLCJoaWdobGlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJyZXBsYWNlIiwiY29sb3VyIiwiY29sb3IiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJnZXRMZW5ndGgiLCJkZXRhY2giLCJyZW1vdmVDaGlsZCIsInJlcGxhY2VXaXRoIiwicmVwbGFjZUNoaWxkIiwiZW1wdHkiLCJmcmFnIiwib3duZXJEb2N1bWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJwcm9wcyIsImNoaWxkcmVuIiwiZWwiLCJ2YWx1ZSIsImkiLCJzZXRBdHRyaWJ1dGUiLCJmaXhDdXJzb3IiLCJzZWxmIiwiX19zcXVpcmVfXyIsIm9yaWdpbmFsTm9kZSIsImZpeGVyIiwiY2hpbGQiLCJjcmVhdGVEZWZhdWx0QmxvY2siLCJkYXRhIiwiY3JlYXRlVGV4dE5vZGUiLCJfZGlkQWRkWldTIiwiaW5zZXJ0QmVmb3JlIiwibGFzdEVsZW1lbnRDaGlsZCIsImVycm9yIiwiZGlkRXJyb3IiLCJuYW1lIiwibWVzc2FnZSIsImlubmVySFRNTCIsImZpeENvbnRhaW5lciIsImNvbnRhaW5lciIsIndyYXBwZXIiLCJpc0JSIiwiX2NvbmZpZyIsImJsb2NrVGFnIiwiYmxvY2tBdHRyaWJ1dGVzIiwib2Zmc2V0Iiwic3RvcE5vZGUiLCJjbG9uZSIsIm5leHQiLCJzcGxpdFRleHQiLCJjbG9uZU5vZGUiLCJzdGFydCIsIl9tZXJnZUlubGluZXMiLCJmYWtlUmFuZ2UiLCJmcmFncyIsInByZXYiLCJsZW4iLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0IiwiYXBwZW5kRGF0YSIsInB1c2giLCJwb3AiLCJtZXJnZUlubGluZXMiLCJyYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwibWVyZ2VXaXRoQmxvY2siLCJsYXN0IiwiY29sbGFwc2UiLCJtZXJnZUNvbnRhaW5lcnMiLCJmaXJzdCIsImlzTGlzdEl0ZW0iLCJuZWVkc0ZpeCIsImdldE5vZGVCZWZvcmUiLCJnZXROb2RlQWZ0ZXIiLCJpbnNlcnROb2RlSW5SYW5nZSIsImNoaWxkQ291bnQiLCJhZnRlclNwbGl0IiwiY29sbGFwc2VkIiwiZXh0cmFjdENvbnRlbnRzT2ZSYW5nZSIsImNvbW1vbiIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwiZW5kTm9kZSIsInN0YXJ0Tm9kZSIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlVGV4dCIsImFmdGVyVGV4dCIsImNoYXJBdCIsInNsaWNlIiwiZGVsZXRlQ29udGVudHNPZlJhbmdlIiwic3RhcnRCbG9jayIsImdldFN0YXJ0QmxvY2tPZlJhbmdlIiwiZW5kQmxvY2siLCJnZXRFbmRCbG9ja09mUmFuZ2UiLCJuZWVkc01lcmdlIiwibW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlIiwibW92ZVJhbmdlQm91bmRhcmllc1VwVHJlZSIsInNlbGVjdE5vZGVDb250ZW50cyIsImluc2VydFRyZWVGcmFnbWVudEludG9SYW5nZSIsImJsb2NrQ29udGVudHNBZnRlclNwbGl0Iiwic3RvcFBvaW50IiwicmVwbGFjZUJsb2NrIiwiZmlyc3RCbG9ja0luRnJhZyIsIm5vZGVBZnRlclNwbGl0Iiwibm9kZUJlZm9yZVNwbGl0IiwidGVtcFJhbmdlIiwiY2xlYW51cEJScyIsInNldEVuZEJlZm9yZSIsImNsb25lUmFuZ2UiLCJpc05vZGVDb250YWluZWRJblJhbmdlIiwicGFydGlhbCIsIm5vZGVSYW5nZSIsImNyZWF0ZVJhbmdlIiwic2VsZWN0Tm9kZSIsIm5vZGVFbmRCZWZvcmVTdGFydCIsImNvbXBhcmVCb3VuZGFyeVBvaW50cyIsIm5vZGVTdGFydEFmdGVyRW5kIiwibm9kZVN0YXJ0QWZ0ZXJTdGFydCIsIm5vZGVFbmRCZWZvcmVFbmQiLCJtYXlTa2lwQlIiLCJzdGFydE1heCIsImVuZE1heCIsImNvbnRlbnRXYWxrZXIiLCJyYW5nZURvZXNTdGFydEF0QmxvY2tCb3VuZGFyeSIsIm5vZGVBZnRlckN1cnNvciIsInJhbmdlRG9lc0VuZEF0QmxvY2tCb3VuZGFyeSIsImV4cGFuZFJhbmdlVG9CbG9ja0JvdW5kYXJpZXMiLCJlbmQiLCJrZXlzIiwib25LZXkiLCJldmVudCIsImNvZGUiLCJrZXlDb2RlIiwia2V5IiwibW9kaWZpZXJzIiwiZ2V0U2VsZWN0aW9uIiwiZGVmYXVsdFByZXZlbnRlZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInRvTG93ZXJDYXNlIiwid2hpY2giLCJhbHRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJfa2V5SGFuZGxlcnMiLCJpc0NvbXBvc2luZyIsInNhdmVVbmRvU3RhdGUiLCJfcm9vdCIsIl9lbnN1cmVCb3R0b21MaW5lIiwic2V0U2VsZWN0aW9uIiwiX3VwZGF0ZVBhdGgiLCJtYXBLZXlUbyIsIm1ldGhvZCIsInByZXZlbnREZWZhdWx0IiwibWFwS2V5VG9Gb3JtYXQiLCJyZW1vdmUiLCJoYXNGb3JtYXQiLCJjaGFuZ2VGb3JtYXQiLCJhZnRlckRlbGV0ZSIsImtleUhhbmRsZXJzIiwiZW50ZXIiLCJfcmVjb3JkVW5kb1N0YXRlIiwiYWRkTGlua3MiLCJfcmVtb3ZlWldTIiwiX2dldFJhbmdlQW5kUmVtb3ZlQm9va21hcmsiLCJfZG9jIiwiZGVsZXRlRGF0YSIsImluc2VydERhdGEiLCJzZXRTdGFydEFmdGVyIiwiX2RvY1dhc0NoYW5nZWQiLCJkZWNyZWFzZUxpc3RMZXZlbCIsIm1vZGlmeUJsb2NrcyIsInJlbW92ZUJsb2NrUXVvdGUiLCJzcGxpdEJsb2NrIiwicmVtb3ZlWldTIiwicmVtb3ZlRW1wdHlJbmxpbmVzIiwiYmFja3NwYWNlIiwicHJldmlvdXMiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImRlY3JlYXNlQmxvY2tRdW90ZUxldmVsIiwic2V0VGltZW91dCIsIm9yaWdpbmFsUmFuZ2UiLCJjdXJzb3JDb250YWluZXIiLCJjdXJzb3JPZmZzZXQiLCJ0YWIiLCJpbmNyZWFzZUxpc3RMZXZlbCIsInNwYWNlIiwiXyIsImxlZnQiLCJyaWdodCIsInNlbCIsImdldFdpbmRvd1NlbGVjdGlvbiIsIm1vZGlmeSIsInBhZ2V1cCIsIm1vdmVDdXJzb3JUb1N0YXJ0IiwicGFnZWRvd24iLCJtb3ZlQ3Vyc29yVG9FbmQiLCJmb250U2l6ZXMiLCJzdHlsZVRvU2VtYW50aWMiLCJyZWdleHAiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiZmFtaWx5Iiwic2l6ZSIsInRleHREZWNvcmF0aW9uIiwicmVwbGFjZVdpdGhUYWciLCJyZXBsYWNlU3R5bGVzIiwiY29udmVydGVyIiwiY3NzIiwibmV3VHJlZUJvdHRvbSIsIm5ld1RyZWVUb3AiLCJzdHlsZXNSZXdyaXRlcnMiLCJQIiwiU1BBTiIsIlNUUk9ORyIsIkVNIiwiSU5TIiwiU1RSSUtFIiwiRk9OVCIsImZhY2UiLCJmb250U3BhbiIsInNpemVTcGFuIiwiY29sb3VyU3BhbiIsIlRUIiwiYWxsb3dlZEJsb2NrIiwiYmxhY2tsaXN0IiwiY2xlYW5UcmVlIiwicHJlc2VydmVXUyIsIm5vbklubGluZVBhcmVudCIsInJld3JpdGVyIiwiY2hpbGRMZW5ndGgiLCJzdGFydHNXaXRoV1MiLCJlbmRzV2l0aFdTIiwic2libGluZyIsIm5vdFdTVGV4dE5vZGUiLCJpc0xpbmVCcmVhayIsImJyIiwiaXNMQklmRW1wdHlCbG9jayIsImtlZXBGb3JCbGFua0xpbmUiLCJicnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYnJCcmVha3NMaW5lIiwic2V0Q2xpcGJvYXJkRGF0YSIsImNsaXBib2FyZERhdGEiLCJib2R5Iiwid2lsbEN1dENvcHkiLCJodG1sIiwidGV4dCIsImlubmVyVGV4dCIsInNldERhdGEiLCJvbkN1dCIsImNvcHlSb290IiwiY29udGVudHMiLCJuZXdDb250ZW50cyIsIm9uQ29weSIsImNsb25lQ29udGVudHMiLCJtb25pdG9yU2hpZnRLZXkiLCJpc1NoaWZ0RG93biIsIm9uUGFzdGUiLCJpdGVtcyIsImNob29zZVBsYWluIiwiZmlyZURyb3AiLCJoYXNSVEYiLCJoYXNJbWFnZSIsInBsYWluSXRlbSIsImh0bWxJdGVtIiwiaXRlbSIsInR5cGUiLCJ0eXBlcyIsImZpcmVFdmVudCIsImRhdGFUcmFuc2ZlciIsImdldEFzU3RyaW5nIiwiaW5zZXJ0SFRNTCIsImluc2VydFBsYWluVGV4dCIsImdldERhdGEiLCJfYXdhaXRpbmdQYXN0ZSIsInBhc3RlQXJlYSIsImNvbnRlbnRlZGl0YWJsZSIsIm9uRHJvcCIsImhhc1BsYWluIiwiaGFzSFRNTCIsIm1lcmdlT2JqZWN0cyIsImJhc2UiLCJleHRyYXMiLCJtYXlPdmVycmlkZSIsInByb3AiLCJjb25zdHJ1Y3RvciIsIlNxdWlyZSIsIm11dGF0aW9uIiwiX3dpbiIsIl9ldmVudHMiLCJfaXNGb2N1c2VkIiwiX2xhc3RTZWxlY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwiX2hhc1pXUyIsIl9sYXN0QW5jaG9yTm9kZSIsIl9sYXN0Rm9jdXNOb2RlIiwiX3BhdGgiLCJfd2lsbFVwZGF0ZVBhdGgiLCJfdXBkYXRlUGF0aE9uRXZlbnQiLCJfdW5kb0luZGV4IiwiX3VuZG9TdGFjayIsIl91bmRvU3RhY2tMZW5ndGgiLCJfaXNJblVuZG9TdGF0ZSIsIl9pZ25vcmVDaGFuZ2UiLCJfaWdub3JlQWxsQ2hhbmdlcyIsImJpbmQiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJfbXV0YXRpb24iLCJfa2V5VXBEZXRlY3RDaGFuZ2UiLCJfcmVzdG9yZVNlbGVjdGlvbiIsImVuYWJsZVJlc3RvcmVTZWxlY3Rpb24iLCJkaXNhYmxlUmVzdG9yZVNlbGVjdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJzZXRDb25maWciLCJUZXh0IiwidG9EZWxldGUiLCJleGVjQ29tbWFuZCIsInNldEhUTUwiLCJzYW5pdGl6ZVRvRE9NRnJhZ21lbnQiLCJpc1Bhc3RlIiwiRE9NUHVyaWZ5Iiwic2FuaXRpemUiLCJBTExPV19VTktOT1dOX1BST1RPQ09MUyIsIldIT0xFX0RPQ1VNRU5UIiwiUkVUVVJOX0RPTSIsIlJFVFVSTl9ET01fRlJBR01FTlQiLCJpbXBvcnROb2RlIiwidGFnQXR0cmlidXRlcyIsImJsb2NrcXVvdGUiLCJ1bCIsIm9sIiwibGkiLCJhIiwidW5kbyIsImRvY3VtZW50U2l6ZVRocmVzaG9sZCIsInVuZG9MaW1pdCIsImlzSW5zZXJ0ZWRIVE1MU2FuaXRpemVkIiwiaXNTZXRIVE1MU2FuaXRpemVkIiwiaXNTdXBwb3J0ZWQiLCJ0b1VwcGVyQ2FzZSIsImNvbnNvbGUiLCJsb2ciLCJnZXREb2N1bWVudCIsImdldFJvb3QiLCJtb2RpZnlEb2N1bWVudCIsIm1vZGlmaWNhdGlvbkNhbGxiYWNrIiwidGFrZVJlY29yZHMiLCJkaXNjb25uZWN0IiwiY3VzdG9tRXZlbnRzIiwicGF0aENoYW5nZSIsInNlbGVjdCIsImlucHV0IiwidW5kb1N0YXRlQ2hhbmdlIiwiaGFuZGxlcnMiLCJpc0ZvY3VzZWQiLCJvYmoiLCJhY3RpdmVFbGVtZW50IiwiaGFuZGxlRXZlbnQiLCJkZXRhaWxzIiwiZGVzdHJveSIsImV2ZW50cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0YXJnZXQiLCJzcGxpY2UiLCJSYW5nZSIsImRvbVJhbmdlIiwiZ2V0Q3Vyc29yUG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZWN0IiwidG9wIiwiX21vdmVDdXJzb3JUbyIsInRvU3RhcnQiLCJibHVyIiwiZm9jdXMiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0Iiwic2V0U3RhcnRCZWZvcmUiLCJnZXRTZWxlY3RlZFRleHQiLCJhZGRlZFRleHRJbkJsb2NrIiwia2VlcE5vZGUiLCJpbmRleCIsImZvcmNlIiwiYW5jaG9yIiwibmV3UGF0aCIsInByZXZlbnRTY3JvbGwiLCJzdGFydFNlbGVjdGlvbklkIiwiZW5kU2VsZWN0aW9uSWQiLCJfc2F2ZVJhbmdlVG9Cb29rbWFyayIsInRlbXAiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImNhblVuZG8iLCJjYW5SZWRvIiwidW5kb0luZGV4IiwidW5kb1N0YWNrIiwidW5kb0NvbmZpZyIsInVuZG9UaHJlc2hvbGQiLCJfZ2V0SFRNTCIsIl9zZXRIVE1MIiwicmVkbyIsInVuZG9TdGFja0xlbmd0aCIsInNldEVuZEFmdGVyIiwic2Vlbk5vZGUiLCJnZXRGb250SW5mbyIsImZvbnRJbmZvIiwic2VlbkF0dHJpYnV0ZXMiLCJlbGVtZW50IiwiX2FkZEZvcm1hdCIsIm5lZWRzRm9ybWF0IiwiX3JlbW92ZUZvcm1hdCIsInRvV3JhcCIsImV4YW1pbmVOb2RlIiwiZXhlbXBsYXIiLCJpc1RleHQiLCJmb3JtYXRUYWdzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJmb3JFYWNoIiwiYWRkIiwidGFnQWZ0ZXJTcGxpdCIsIkRUIiwiREQiLCJMSSIsIlBSRSIsInNwbGl0VGFnIiwic3BsaXRQcm9wZXJ0aWVzIiwiZm9yRWFjaEJsb2NrIiwibXV0YXRlcyIsImluY3JlYXNlQmxvY2tRdW90ZUxldmVsIiwiYmxvY2txdW90ZXMiLCJtYWtlTGlzdCIsIm5ld0xpIiwibGlzdEF0dHJzIiwibGlzdEl0ZW1BdHRycyIsIm1ha2VVbm9yZGVyZWRMaXN0IiwibWFrZU9yZGVyZWRMaXN0IiwicmVtb3ZlTGlzdCIsImxpc3RzIiwibGlzdCIsImxpc3RGcmFnIiwiZ2V0TGlzdFNlbGVjdGlvbiIsInN0YXJ0TGkiLCJlbmRMaSIsImxpc3RTZWxlY3Rpb24iLCJuZXdQYXJlbnQiLCJtYWtlTm90TGlzdCIsInNldEtleUhhbmRsZXIiLCJnZXRIVE1MIiwid2l0aEJvb2tNYXJrIiwiZGl2IiwiaW5zZXJ0RWxlbWVudCIsInNwbGl0Tm9kZSIsImluc2VydEltYWdlIiwic3JjIiwiaW1nIiwibGlua1JlZ0V4cCIsImRlZmF1bHRBdHRyaWJ1dGVzIiwibWF0Y2giLCJlbmRJbmRleCIsImV4ZWMiLCJocmVmIiwic3RhcnRGcmFnbWVudEluZGV4IiwiZW5kRnJhZ21lbnRJbmRleCIsImxhc3RJbmRleE9mIiwiZnJhZ21lbnQiLCJub3JtYWxpemUiLCJlc2NhcGVIVE1MRnJhZ2VtZW50IiwicGxhaW5UZXh0IiwibGluZXMiLCJjbG9zZUJsb2NrIiwib3BlbkJsb2NrIiwibGluZSIsImNvbW1hbmQiLCJhcmciLCJhcmcyIiwiYWRkU3R5bGVzIiwic3R5bGVzIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJzdHJpa2V0aHJvdWdoIiwic3Vic2NyaXB0Iiwic3VwZXJzY3JpcHQiLCJyZW1vdmVCb2xkIiwicmVtb3ZlSXRhbGljIiwicmVtb3ZlVW5kZXJsaW5lIiwicmVtb3ZlU3RyaWtldGhyb3VnaCIsInJlbW92ZVN1YnNjcmlwdCIsInJlbW92ZVN1cGVyc2NyaXB0IiwibWFrZUxpbmsiLCJ1cmwiLCJwcm90b2NvbEVuZCIsInJlbW92ZUxpbmsiLCJzZXRGb250RmFjZSIsInNldEZvbnRTaXplIiwic2V0VGV4dENvbG91ciIsInNldEhpZ2hsaWdodENvbG91ciIsInNldFRleHRBbGlnbm1lbnQiLCJhbGlnbm1lbnQiLCJrbGFzcyIsInRleHRBbGlnbiIsInNldFRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJhZGRQcmUiLCJkb2N1bWVudCIsIm91dHB1dCIsIm5vZGVzIiwicHJlIiwicmVtb3ZlUHJlIiwicHJlcyIsInJlbW92ZUNvZGUiLCJhbmNlc3RvciIsImluUHJlIiwidG9nZ2xlQ29kZSIsInJlbW92ZUZvcm1hdHRpbmciLCJjbGVhbiIsInJlbW92ZUFsbEZvcm1hdHRpbmciLCJmb3JtYXR0ZWROb2RlcyIsImNsZWFuTm9kZXMiLCJub2RlSW5TcGxpdCIsImluY3JlYXNlUXVvdGVMZXZlbCIsImRlY3JlYXNlUXVvdGVMZXZlbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTUEsRUFBRSxHQUFNLFVBQVdDLEdBQVgsRUFBZ0JDLFNBQWhCLEVBQTRCO0FBRTFDOztBQUVBLE1BQUlDLDJCQUEyQixHQUFHLENBQWxDLENBSjBDLENBSUw7O0FBQ3JDLE1BQUlDLFlBQVksR0FBRyxDQUFuQixDQUwwQyxDQUtMOztBQUNyQyxNQUFJQyxTQUFTLEdBQUcsQ0FBaEIsQ0FOMEMsQ0FNTDs7QUFDckMsTUFBSUMsYUFBYSxHQUFHLENBQXBCLENBUDBDLENBT0w7O0FBQ3JDLE1BQUlDLHNCQUFzQixHQUFHLEVBQTdCLENBUjBDLENBUUw7O0FBQ3JDLE1BQUlDLFlBQVksR0FBRyxDQUFuQixDQVQwQyxDQVNMOztBQUNyQyxNQUFJQyxTQUFTLEdBQUcsQ0FBaEIsQ0FWMEMsQ0FVTDs7QUFFckMsTUFBSUMsY0FBYyxHQUFHLENBQXJCLENBWjBDLENBWWxCOztBQUN4QixNQUFJQyxZQUFZLEdBQUcsQ0FBbkIsQ0FiMEMsQ0FhbEI7O0FBQ3hCLE1BQUlDLFVB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b0JBQTlCO0FBQ0FvTSxRQUFNLENBQUNsTSxrQkFBUCxHQUE0QkEsa0JBQTVCO0FBQ0FrTSxRQUFNLENBQUNySyxhQUFQLEdBQXVCQSxhQUF2QjtBQUNBcUssUUFBTSxDQUFDcEssNkJBQVAsR0FBdUNBLDZCQUF2QztBQUNBb0ssUUFBTSxDQUFDbEssMkJBQVAsR0FBcUNBLDJCQUFyQztBQUNBa0ssUUFBTSxDQUFDakssNEJBQVAsR0FBc0NBLDRCQUF0QyxDQTEwSjBDLENBNDBKMUM7O0FBQ0FpSyxRQUFNLENBQUM3QixPQUFQLEdBQWlCQSxPQUFqQixDQTcwSjBDLENBKzBKMUM7O0FBQ0E2QixRQUFNLENBQUM3SCxRQUFQLEdBQWtCQSxRQUFsQjtBQUNBNkgsUUFBTSxDQUFDbEgsVUFBUCxHQUFvQkEsVUFBcEI7QUFDQWtILFFBQU0sQ0FBQ3lHLGdCQUFQLEdBQTBCQSxnQkFBMUI7QUFDQXpHLFFBQU0sQ0FBQzBHLGNBQVAsR0FBd0JBLGNBQXhCOztBQUVBLE1BQUssSUFBTCxFQUFtQztBQUMvQnlJLFVBQU0sQ0FBQ0MsT0FBUCxHQUFpQnBQLE1BQWpCO0FBQ0gsR0FGRCxNQUVPLEVBZU47QUFFQSxDQXgySmEsQ0F3MkpYaU8sUUF4MkpXLENBQWQiLCJmaWxlIjoiLi9zcmMvcmVzb3VyY2VzL3dyaXRlL3NxdWlyZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCDCqSAyMDExLTIwMTUgYnkgTmVpbCBKZW5raW5zLiBNSVQgTGljZW5zZWQuICovXG5jb25zdCBzcSA9ICAoIGZ1bmN0aW9uICggZG9jLCB1bmRlZmluZWQgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HID0gMjsgLy8gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkdcbnZhciBFTEVNRU5UX05PREUgPSAxOyAgICAgICAgICAgICAgICAvLyBOb2RlLkVMRU1FTlRfTk9ERTtcbnZhciBURVhUX05PREUgPSAzOyAgICAgICAgICAgICAgICAgICAvLyBOb2RlLlRFWFRfTk9ERTtcbnZhciBET0NVTUVOVF9OT0RFID0gOTsgICAgICAgICAgICAgICAvLyBOb2RlLkRPQ1VNRU5UX05PREU7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExOyAgICAgLy8gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xudmFyIFNIT1dfRUxFTUVOVCA9IDE7ICAgICAgICAgICAgICAgIC8vIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UO1xudmFyIFNIT1dfVEVYVCA9IDQ7ICAgICAgICAgICAgICAgICAgIC8vIE5vZGVGaWx0ZXIuU0hPV19URVhUO1xuXG52YXIgU1RBUlRfVE9fU1RBUlQgPSAwOyAvLyBSYW5nZS5TVEFSVF9UT19TVEFSVFxudmFyIFNUQVJUX1RPX0VORCA9IDE7ICAgLy8gUmFuZ2UuU1RBUlRfVE9fRU5EXG52YXIgRU5EX1RPX0VORCA9IDI7ICAgICAvLyBSYW5nZS5FTkRfVE9fRU5EXG52YXIgRU5EX1RPX1NUQVJUID0gMzsgICAvLyBSYW5nZS5FTkRfVE9fU1RBUlRcblxudmFyIFpXUyA9ICdcXHUyMDBCJztcblxudmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxudmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxudmFyIGlzQW5kcm9pZCA9IC9BbmRyb2lkLy50ZXN0KCB1YSApO1xudmFyIGlzSU9TID0gL2lQKD86YWR8aG9uZXxvZCkvLnRlc3QoIHVhICk7XG52YXIgaXNNYWMgPSAvTWFjIE9TIFgvLnRlc3QoIHVhICk7XG52YXIgaXNXaW4gPSAvV2luZG93cyBOVC8udGVzdCggdWEgKTtcblxudmFyIGlzR2Vja28gPSAvR2Vja29cXC8vLnRlc3QoIHVhICk7XG52YXIgaXNJRWx0MTEgPSAvVHJpZGVudFxcL1s0NTZdXFwuLy50ZXN0KCB1YSApO1xudmFyIGlzUHJlc3RvID0gISF3aW4ub3BlcmE7XG52YXIgaXNFZGdlID0gL0VkZ2VcXC8vLnRlc3QoIHVhICk7XG52YXIgaXNXZWJLaXQgPSAhaXNFZGdlICYmIC9XZWJLaXRcXC8vLnRlc3QoIHVhICk7XG52YXIgaXNJRSA9IC9UcmlkZW50XFwvWzQ1NjddXFwuLy50ZXN0KCB1YSApO1xuXG52YXIgY3RybEtleSA9IGlzTWFjID8gJ21ldGEtJyA6ICdjdHJsLSc7XG5cbnZhciB1c2VUZXh0Rml4ZXIgPSBpc0lFbHQxMSB8fCBpc1ByZXN0bztcbnZhciBjYW50Rm9jdXNFbXB0eVRleHROb2RlcyA9IGlzSUVsdDExIHx8IGlzV2ViS2l0O1xudmFyIGxvc2VzU2VsZWN0aW9uT25CbHVyID0gaXNJRWx0MTE7XG5cbnZhciBjYW5PYnNlcnZlTXV0YXRpb25zID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xudmFyIGNhbldlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIFVzZSBbXiBcXHRcXHJcXG5dIGluc3RlYWQgb2YgXFxTIHNvIHRoYXQgbmJzcCBkb2VzIG5vdCBjb3VudCBhcyB3aGl0ZS1zcGFjZVxudmFyIG5vdFdTID0gL1teIFxcdFxcclxcbl0vO1xuXG52YXIgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuXG4vLyBQb2x5ZmlsbCBmb3IgRkYzLjVcbmlmICggIU9iamVjdC5jcmVhdGUgKSB7XG4gICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uICggcHJvdG8gKSB7XG4gICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgIH07XG59XG5cbi8qXG4gICAgTmF0aXZlIFRyZWVXYWxrZXIgaXMgYnVnZ3kgaW4gSUUgYW5kIE9wZXJhOlxuICAgICogSUU5LzEwIHNvbWV0aW1lcyB0aHJvdyBlcnJvcnMgd2hlbiBjYWxsaW5nIFRyZWVXYWxrZXIjbmV4dE5vZGUgb3JcbiAgICAgIFRyZWVXYWxrZXIjcHJldmlvdXNOb2RlLiBObyB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhpcy5cbiAgICAqIFNvbWUgdmVyc2lvbnMgb2YgT3BlcmEgaGF2ZSBhIGJ1ZyBpbiBUcmVlV2Fsa2VyI3ByZXZpb3VzTm9kZSB3aGljaCBtYWtlc1xuICAgICAgaXQgc2tpcCB0byB0aGUgd3Jvbmcgbm9kZS5cblxuICAgIFJhdGhlciB0aGFuIHJpc2sgZnVydGhlciBidWdzLCBpdCdzIGVhc2llc3QganVzdCB0byBpbXBsZW1lbnQgb3VyIG93blxuICAgIChzdWJzZXQpIG9mIHRoZSBzcGVjIGluIGFsbCBicm93c2Vycy5cbiovXG5cbnZhciB0eXBlVG9CaXRBcnJheSA9IHtcbiAgICAvLyBFTEVNRU5UX05PREVcbiAgICAxOiAxLFxuICAgIC8vIEFUVFJJQlVURV9OT0RFXG4gICAgMjogMixcbiAgICAvLyBURVhUX05PREVcbiAgICAzOiA0LFxuICAgIC8vIENPTU1FTlRfTk9ERVxuICAgIDg6IDEyOCxcbiAgICAvLyBET0NVTUVOVF9OT0RFXG4gICAgOTogMjU2LFxuICAgIC8vIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgICAxMTogMTAyNFxufTtcblxudmFyIGFsd2F5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIFRyZWVXYWxrZXIgKCByb290LCBub2RlVHlwZSwgZmlsdGVyICkge1xuICAgIHRoaXMucm9vdCA9IHRoaXMuY3VycmVudE5vZGUgPSByb290O1xuICAgIHRoaXMubm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlciB8fCBhbHdheXM7XG59XG5cblRyZWVXYWxrZXIucHJvdG90eXBlLm5leHROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50Tm9kZSxcbiAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgbm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlLFxuICAgICAgICBmaWx0ZXIgPSB0aGlzLmZpbHRlcixcbiAgICAgICAgbm9kZTtcbiAgICB3aGlsZSAoIHRydWUgKSB7XG4gICAgICAgIG5vZGUgPSBjdXJyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICggIW5vZGUgJiYgY3VycmVudCApIHtcbiAgICAgICAgICAgIGlmICggY3VycmVudCA9PT0gcm9vdCApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCAhbm9kZSApIHsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggIW5vZGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICggdHlwZVRvQml0QXJyYXlbIG5vZGUubm9kZVR5cGUgXSAmIG5vZGVUeXBlICkgJiZcbiAgICAgICAgICAgICAgICBmaWx0ZXIoIG5vZGUgKSApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG5vZGU7XG4gICAgfVxufTtcblxuVHJlZVdhbGtlci5wcm90b3R5cGUucHJldmlvdXNOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50Tm9kZSxcbiAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgbm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlLFxuICAgICAgICBmaWx0ZXIgPSB0aGlzLmZpbHRlcixcbiAgICAgICAgbm9kZTtcbiAgICB3aGlsZSAoIHRydWUgKSB7XG4gICAgICAgIGlmICggY3VycmVudCA9PT0gcm9vdCApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBjdXJyZW50LnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCBub2RlICkge1xuICAgICAgICAgICAgd2hpbGUgKCBjdXJyZW50ID0gbm9kZS5sYXN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggIW5vZGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICggdHlwZVRvQml0QXJyYXlbIG5vZGUubm9kZVR5cGUgXSAmIG5vZGVUeXBlICkgJiZcbiAgICAgICAgICAgICAgICBmaWx0ZXIoIG5vZGUgKSApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG5vZGU7XG4gICAgfVxufTtcblxuLy8gUHJldmlvdXMgbm9kZSBpbiBwb3N0LW9yZGVyLlxuVHJlZVdhbGtlci5wcm90b3R5cGUucHJldmlvdXNQT05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnROb2RlLFxuICAgICAgICByb290ID0gdGhpcy5yb290LFxuICAgICAgICBub2RlVHlwZSA9IHRoaXMubm9kZVR5cGUsXG4gICAgICAgIGZpbHRlciA9IHRoaXMuZmlsdGVyLFxuICAgICAgICBub2RlO1xuICAgIHdoaWxlICggdHJ1ZSApIHtcbiAgICAgICAgbm9kZSA9IGN1cnJlbnQubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAoICFub2RlICYmIGN1cnJlbnQgKSB7XG4gICAgICAgICAgICBpZiAoIGN1cnJlbnQgPT09IHJvb3QgKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gY3VycmVudC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBpZiAoICFub2RlICkgeyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhbm9kZSApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggKCB0eXBlVG9CaXRBcnJheVsgbm9kZS5ub2RlVHlwZSBdICYgbm9kZVR5cGUgKSAmJlxuICAgICAgICAgICAgICAgIGZpbHRlciggbm9kZSApICkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICB9XG59O1xuXG52YXIgaW5saW5lTm9kZU5hbWVzICA9IC9eKD86I3RleHR8QSg/OkJCUnxDUk9OWU0pP3xCKD86UnxEW0lPXSk/fEMoPzpJVEV8T0RFKXxEKD86QVRBfEVMfEZOKXxFTXxGT05UfEhSfEkoPzpGUkFNRXxNR3xOUFVUfE5TKT98S0JEfFF8Uig/OlB8VHxVQlkpfFMoPzpBTVB8TUFMTHxQQU58VFIoPzpJS0V8T05HKXxVW0JQXSk/fFRJTUV8VXxWQVJ8V0JSKSQvO1xuXG52YXIgbGVhZk5vZGVOYW1lcyA9IHtcbiAgICBCUjogMSxcbiAgICBIUjogMSxcbiAgICBJRlJBTUU6IDEsXG4gICAgSU1HOiAxLFxuICAgIElOUFVUOiAxXG59O1xuXG5mdW5jdGlvbiBldmVyeSAoIG5vZGVMaXN0LCBmbiApIHtcbiAgICB2YXIgbCA9IG5vZGVMaXN0Lmxlbmd0aDtcbiAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgaWYgKCAhZm4oIG5vZGVMaXN0W2xdICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIC0tLVxuXG52YXIgVU5LTk9XTiA9IDA7XG52YXIgSU5MSU5FID0gMTtcbnZhciBCTE9DSyA9IDI7XG52YXIgQ09OVEFJTkVSID0gMztcblxudmFyIG5vZGVDYXRlZ29yeUNhY2hlID0gY2FuV2Vha01hcCA/IG5ldyBXZWFrTWFwKCkgOiBudWxsO1xuXG5mdW5jdGlvbiBpc0xlYWYgKCBub2RlICkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgISFsZWFmTm9kZU5hbWVzWyBub2RlLm5vZGVOYW1lIF07XG59XG5mdW5jdGlvbiBnZXROb2RlQ2F0ZWdvcnkgKCBub2RlICkge1xuICAgIHN3aXRjaCAoIG5vZGUubm9kZVR5cGUgKSB7XG4gICAgY2FzZSBURVhUX05PREU6XG4gICAgICAgIHJldHVybiBJTkxJTkU7XG4gICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICBpZiAoIGNhbldlYWtNYXAgJiYgbm9kZUNhdGVnb3J5Q2FjaGUuaGFzKCBub2RlICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUNhdGVnb3J5Q2FjaGUuZ2V0KCBub2RlICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFVOS05PV047XG4gICAgfVxuXG4gICAgdmFyIG5vZGVDYXRlZ29yeTtcbiAgICBpZiAoICFldmVyeSggbm9kZS5jaGlsZE5vZGVzLCBpc0lubGluZSApICkge1xuICAgICAgICAvLyBNYWxmb3JtZWQgSFRNTCBjYW4gaGF2ZSBibG9jayB0YWdzIGluc2lkZSBpbmxpbmUgdGFncy4gTmVlZCB0byB0cmVhdFxuICAgICAgICAvLyB0aGVzZSBhcyBjb250YWluZXJzIHJhdGhlciB0aGFuIGlubGluZS4gU2VlICMyMzkuXG4gICAgICAgIG5vZGVDYXRlZ29yeSA9IENPTlRBSU5FUjtcbiAgICB9IGVsc2UgaWYgKCBpbmxpbmVOb2RlTmFtZXMudGVzdCggbm9kZS5ub2RlTmFtZSApICkge1xuICAgICAgICBub2RlQ2F0ZWdvcnkgPSBJTkxJTkU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUNhdGVnb3J5ID0gQkxPQ0s7XG4gICAgfVxuICAgIGlmICggY2FuV2Vha01hcCApIHtcbiAgICAgICAgbm9kZUNhdGVnb3J5Q2FjaGUuc2V0KCBub2RlLCBub2RlQ2F0ZWdvcnkgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVDYXRlZ29yeTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lICggbm9kZSApIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUNhdGVnb3J5KCBub2RlICkgPT09IElOTElORTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2sgKCBub2RlICkge1xuICAgIHJldHVybiBnZXROb2RlQ2F0ZWdvcnkoIG5vZGUgKSA9PT0gQkxPQ0s7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lciAoIG5vZGUgKSB7XG4gICAgcmV0dXJuIGdldE5vZGVDYXRlZ29yeSggbm9kZSApID09PSBDT05UQUlORVI7XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrV2Fsa2VyICggbm9kZSwgcm9vdCApIHtcbiAgICB2YXIgd2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoIHJvb3QsIFNIT1dfRUxFTUVOVCwgaXNCbG9jayApO1xuICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIHdhbGtlcjtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzQmxvY2sgKCBub2RlLCByb290ICkge1xuICAgIG5vZGUgPSBnZXRCbG9ja1dhbGtlciggbm9kZSwgcm9vdCApLnByZXZpb3VzTm9kZSgpO1xuICAgIHJldHVybiBub2RlICE9PSByb290ID8gbm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXROZXh0QmxvY2sgKCBub2RlLCByb290ICkge1xuICAgIG5vZGUgPSBnZXRCbG9ja1dhbGtlciggbm9kZSwgcm9vdCApLm5leHROb2RlKCk7XG4gICAgcmV0dXJuIG5vZGUgIT09IHJvb3QgPyBub2RlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eUJsb2NrICggYmxvY2sgKSB7XG4gICAgcmV0dXJuICFibG9jay50ZXh0Q29udGVudCAmJiAhYmxvY2sucXVlcnlTZWxlY3RvciggJ0lNRycgKTtcbn1cblxuZnVuY3Rpb24gYXJlQWxpa2UgKCBub2RlLCBub2RlMiApIHtcbiAgICByZXR1cm4gIWlzTGVhZiggbm9kZSApICYmIChcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gbm9kZTIubm9kZVR5cGUgJiZcbiAgICAgICAgbm9kZS5ub2RlTmFtZSA9PT0gbm9kZTIubm9kZU5hbWUgJiZcbiAgICAgICAgbm9kZS5ub2RlTmFtZSAhPT0gJ0EnICYmXG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID09PSBub2RlMi5jbGFzc05hbWUgJiZcbiAgICAgICAgKCAoICFub2RlLnN0eWxlICYmICFub2RlMi5zdHlsZSApIHx8XG4gICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID09PSBub2RlMi5zdHlsZS5jc3NUZXh0IClcbiAgICApO1xufVxuZnVuY3Rpb24gaGFzVGFnQXR0cmlidXRlcyAoIG5vZGUsIHRhZywgYXR0cmlidXRlcyApIHtcbiAgICBpZiAoIG5vZGUubm9kZU5hbWUgIT09IHRhZyApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKCB2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzICkge1xuICAgICAgICBpZiAoIG5vZGUuZ2V0QXR0cmlidXRlKCBhdHRyICkgIT09IGF0dHJpYnV0ZXNbIGF0dHIgXSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3QgKCBub2RlLCByb290LCB0YWcsIGF0dHJpYnV0ZXMgKSB7XG4gICAgd2hpbGUgKCBub2RlICYmIG5vZGUgIT09IHJvb3QgKSB7XG4gICAgICAgIGlmICggaGFzVGFnQXR0cmlidXRlcyggbm9kZSwgdGFnLCBhdHRyaWJ1dGVzICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzT3JDb250YWlucyAoIHBhcmVudCwgbm9kZSApIHtcbiAgICB3aGlsZSAoIG5vZGUgKSB7XG4gICAgICAgIGlmICggbm9kZSA9PT0gcGFyZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoICggbm9kZSwgcm9vdCwgY29uZmlnICkge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGlkLCBjbGFzc05hbWUsIGNsYXNzTmFtZXMsIGRpciwgc3R5bGVOYW1lcztcbiAgICBpZiAoIG5vZGUgJiYgbm9kZSAhPT0gcm9vdCApIHtcbiAgICAgICAgcGF0aCA9IGdldFBhdGgoIG5vZGUucGFyZW50Tm9kZSwgcm9vdCwgY29uZmlnICk7XG4gICAgICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICkge1xuICAgICAgICAgICAgcGF0aCArPSAoIHBhdGggPyAnPicgOiAnJyApICsgbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIGlmICggaWQgPSBub2RlLmlkICkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gJyMnICsgaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lLnRyaW0oKSApIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lLnNwbGl0KCAvXFxzXFxzKi8gKTtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcuJztcbiAgICAgICAgICAgICAgICBwYXRoICs9IGNsYXNzTmFtZXMuam9pbiggJy4nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGRpciA9IG5vZGUuZGlyICkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gJ1tkaXI9JyArIGRpciArICddJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggY2xhc3NOYW1lcyApIHtcbiAgICAgICAgICAgICAgICBzdHlsZU5hbWVzID0gY29uZmlnLmNsYXNzTmFtZXM7XG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleE9mLmNhbGwoIGNsYXNzTmFtZXMsIHN0eWxlTmFtZXMuaGlnaGxpZ2h0ICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSAnW2JhY2tncm91bmRDb2xvcj0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoIC8gL2csJycgKSArICddJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleE9mLmNhbGwoIGNsYXNzTmFtZXMsIHN0eWxlTmFtZXMuY29sb3VyICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSAnW2NvbG9yPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5jb2xvci5yZXBsYWNlKCAvIC9nLCcnICkgKyAnXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggaW5kZXhPZi5jYWxsKCBjbGFzc05hbWVzLCBzdHlsZU5hbWVzLmZvbnRGYW1pbHkgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoICs9ICdbZm9udEZhbWlseT0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseS5yZXBsYWNlKCAvIC9nLCcnICkgKyAnXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggaW5kZXhPZi5jYWxsKCBjbGFzc05hbWVzLCBzdHlsZU5hbWVzLmZvbnRTaXplICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSAnW2ZvbnRTaXplPScgKyBub2RlLnN0eWxlLmZvbnRTaXplICsgJ10nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoICggbm9kZSApIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHJldHVybiBub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID9cbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA6IG5vZGUubGVuZ3RoIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGRldGFjaCAoIG5vZGUgKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAoIHBhcmVudCApIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKCBub2RlICk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVwbGFjZVdpdGggKCBub2RlLCBub2RlMiApIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKCBub2RlMiwgbm9kZSApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVtcHR5ICggbm9kZSApIHtcbiAgICB2YXIgZnJhZyA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgIGwgPSBjaGlsZE5vZGVzID8gY2hpbGROb2Rlcy5sZW5ndGggOiAwO1xuICAgIHdoaWxlICggbC0tICkge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKCBkb2MsIHRhZywgcHJvcHMsIGNoaWxkcmVuICkge1xuICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCB0YWcgKSxcbiAgICAgICAgYXR0ciwgdmFsdWUsIGksIGw7XG4gICAgaWYgKCBwcm9wcyBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgICBjaGlsZHJlbiA9IHByb3BzO1xuICAgICAgICBwcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICggcHJvcHMgKSB7XG4gICAgICAgIGZvciAoIGF0dHIgaW4gcHJvcHMgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzWyBhdHRyIF07XG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCBhdHRyLCBwcm9wc1sgYXR0ciBdICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCBjaGlsZHJlbiApIHtcbiAgICAgICAgZm9yICggaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICs9IDEgKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZCggY2hpbGRyZW5baV0gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGZpeEN1cnNvciAoIG5vZGUsIHJvb3QgKSB7XG4gICAgLy8gSW4gV2Via2l0IGFuZCBHZWNrbywgYmxvY2sgbGV2ZWwgZWxlbWVudHMgYXJlIGNvbGxhcHNlZCBhbmRcbiAgICAvLyB1bmZvY3Vzc2FibGUgaWYgdGhleSBoYXZlIG5vIGNvbnRlbnQuIFRvIHJlbWVkeSB0aGlzLCBhIDxCUj4gbXVzdCBiZVxuICAgIC8vIGluc2VydGVkLiBJbiBPcGVyYSBhbmQgSUUsIHdlIGp1c3QgbmVlZCBhIHRleHRub2RlIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjdXJzb3IgdG8gYXBwZWFyLlxuICAgIHZhciBzZWxmID0gcm9vdC5fX3NxdWlyZV9fO1xuICAgIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgdmFyIGZpeGVyLCBjaGlsZDtcblxuICAgIGlmICggbm9kZSA9PT0gcm9vdCApIHtcbiAgICAgICAgaWYgKCAhKCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCApIHx8IGNoaWxkLm5vZGVOYW1lID09PSAnQlInICkge1xuICAgICAgICAgICAgZml4ZXIgPSBzZWxmLmNyZWF0ZURlZmF1bHRCbG9jaygpO1xuICAgICAgICAgICAgaWYgKCBjaGlsZCApIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlcGxhY2VDaGlsZCggZml4ZXIsIGNoaWxkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKCBmaXhlciApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IGZpeGVyO1xuICAgICAgICAgICAgZml4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKCBpc0lubGluZSggbm9kZSApICkge1xuICAgICAgICBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKCBjYW50Rm9jdXNFbXB0eVRleHROb2RlcyAmJiBjaGlsZCAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUgJiYgIWNoaWxkLmRhdGEgKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKCBjaGlsZCApO1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhY2hpbGQgKSB7XG4gICAgICAgICAgICBpZiAoIGNhbnRGb2N1c0VtcHR5VGV4dE5vZGVzICkge1xuICAgICAgICAgICAgICAgIGZpeGVyID0gZG9jLmNyZWF0ZVRleHROb2RlKCBaV1MgKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9kaWRBZGRaV1MoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZXIgPSBkb2MuY3JlYXRlVGV4dE5vZGUoICcnICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIHVzZVRleHRGaXhlciApIHtcbiAgICAgICAgICAgIHdoaWxlICggbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICYmICFpc0xlYWYoIG5vZGUgKSApIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoICFjaGlsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZXIgPSBkb2MuY3JlYXRlVGV4dE5vZGUoICcnICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSB3aWxsIGNvbGxhcHNlIHRoZSBibG9jayBlbGVtZW50IGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgICAgICAgLy8ganVzdCBzcGFjZXMgKGJ1dCBub3QgaWYgaXQgY29udGFpbnMgbm8gZGF0YSBhdCBhbGwpLlxuICAgICAgICAgICAgICAgIGlmICggL14gKyQvLnRlc3QoIG5vZGUuZGF0YSApICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBpc0xlYWYoIG5vZGUgKSApIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBkb2MuY3JlYXRlVGV4dE5vZGUoICcnICksIG5vZGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggIW5vZGUucXVlcnlTZWxlY3RvciggJ0JSJyApICkge1xuICAgICAgICAgICAgZml4ZXIgPSBjcmVhdGVFbGVtZW50KCBkb2MsICdCUicgKTtcbiAgICAgICAgICAgIHdoaWxlICggKCBjaGlsZCA9IG5vZGUubGFzdEVsZW1lbnRDaGlsZCApICYmICFpc0lubGluZSggY2hpbGQgKSApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCBmaXhlciApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoIGZpeGVyICk7XG4gICAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgICAgIHNlbGYuZGlkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTcXVpcmU6IGZpeEN1cnNvciDigJMgJyArIGVycm9yLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQYXJlbnQ6ICcgKyBub2RlLm5vZGVOYW1lICsgJy8nICsgbm9kZS5pbm5lckhUTUwgK1xuICAgICAgICAgICAgICAgICAgICAnIGFwcGVuZENoaWxkOiAnICsgZml4ZXIubm9kZU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsTm9kZTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgZXhhbWluZSBjb250YWluZXIgbm9kZXMgYW5kIHdyYXAgYW55IGlubGluZSBjaGlsZHJlbi5cbmZ1bmN0aW9uIGZpeENvbnRhaW5lciAoIGNvbnRhaW5lciwgcm9vdCApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGROb2RlcztcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIHdyYXBwZXIgPSBudWxsO1xuICAgIHZhciBpLCBsLCBjaGlsZCwgaXNCUjtcbiAgICB2YXIgY29uZmlnID0gcm9vdC5fX3NxdWlyZV9fLl9jb25maWc7XG5cbiAgICBmb3IgKCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSApIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaXNCUiA9IGNoaWxkLm5vZGVOYW1lID09PSAnQlInO1xuICAgICAgICBpZiAoICFpc0JSICYmIGlzSW5saW5lKCBjaGlsZCApICkge1xuICAgICAgICAgICAgaWYgKCAhd3JhcHBlciApIHtcbiAgICAgICAgICAgICAgICAgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoIGRvYyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJsb2NrVGFnLCBjb25maWcuYmxvY2tBdHRyaWJ1dGVzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKCBjaGlsZCApO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgbCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKCBpc0JSIHx8IHdyYXBwZXIgKSB7XG4gICAgICAgICAgICBpZiAoICF3cmFwcGVyICkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KCBkb2MsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ibG9ja1RhZywgY29uZmlnLmJsb2NrQXR0cmlidXRlcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZml4Q3Vyc29yKCB3cmFwcGVyLCByb290ICk7XG4gICAgICAgICAgICBpZiAoIGlzQlIgKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlcGxhY2VDaGlsZCggd3JhcHBlciwgY2hpbGQgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSggd3JhcHBlciwgY2hpbGQgKTtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBpc0NvbnRhaW5lciggY2hpbGQgKSApIHtcbiAgICAgICAgICAgIGZpeENvbnRhaW5lciggY2hpbGQsIHJvb3QgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIHdyYXBwZXIgKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZml4Q3Vyc29yKCB3cmFwcGVyLCByb290ICkgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gc3BsaXQgKCBub2RlLCBvZmZzZXQsIHN0b3BOb2RlLCByb290ICkge1xuICAgIHZhciBub2RlVHlwZSA9IG5vZGUubm9kZVR5cGUsXG4gICAgICAgIHBhcmVudCwgY2xvbmUsIG5leHQ7XG4gICAgaWYgKCBub2RlVHlwZSA9PT0gVEVYVF9OT0RFICYmIG5vZGUgIT09IHN0b3BOb2RlICkge1xuICAgICAgICByZXR1cm4gc3BsaXQoXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUsIG5vZGUuc3BsaXRUZXh0KCBvZmZzZXQgKSwgc3RvcE5vZGUsIHJvb3QgKTtcbiAgICB9XG4gICAgaWYgKCBub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICkge1xuICAgICAgICBpZiAoIHR5cGVvZiggb2Zmc2V0ICkgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzWyBvZmZzZXQgXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBub2RlID09PSBzdG9wTm9kZSApIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZSBub2RlIHdpdGhvdXQgY2hpbGRyZW5cbiAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKCBmYWxzZSApO1xuXG4gICAgICAgIC8vIEFkZCByaWdodC1oYW5kIHNpYmxpbmdzIHRvIHRoZSBjbG9uZVxuICAgICAgICB3aGlsZSAoIG9mZnNldCApIHtcbiAgICAgICAgICAgIG5leHQgPSBvZmZzZXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZCggb2Zmc2V0ICk7XG4gICAgICAgICAgICBvZmZzZXQgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFpbnRhaW4gbGkgbnVtYmVyaW5nIGlmIGluc2lkZSBhIHF1b3RlLlxuICAgICAgICBpZiAoIG5vZGUubm9kZU5hbWUgPT09ICdPTCcgJiZcbiAgICAgICAgICAgICAgICBnZXROZWFyZXN0KCBub2RlLCByb290LCAnQkxPQ0tRVU9URScgKSApIHtcbiAgICAgICAgICAgIGNsb25lLnN0YXJ0ID0gKCArbm9kZS5zdGFydCB8fCAxICkgKyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERPIE5PVCBOT1JNQUxJU0UuIFRoaXMgbWF5IHVuZG8gdGhlIGZpeEN1cnNvcigpIGNhbGxcbiAgICAgICAgLy8gb2YgYSBub2RlIGxvd2VyIGRvd24gdGhlIHRyZWUhXG5cbiAgICAgICAgLy8gV2UgbmVlZCBzb21ldGhpbmcgaW4gdGhlIGVsZW1lbnQgaW4gb3JkZXIgZm9yIHRoZSBjdXJzb3IgdG8gYXBwZWFyLlxuICAgICAgICBmaXhDdXJzb3IoIG5vZGUsIHJvb3QgKTtcbiAgICAgICAgZml4Q3Vyc29yKCBjbG9uZSwgcm9vdCApO1xuXG4gICAgICAgIC8vIEluamVjdCBjbG9uZSBhZnRlciBvcmlnaW5hbCBub2RlXG4gICAgICAgIGlmICggbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBjbG9uZSwgbmV4dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKCBjbG9uZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCBvbiBzcGxpdHRpbmcgdXAgdGhlIHRyZWVcbiAgICAgICAgcmV0dXJuIHNwbGl0KCBwYXJlbnQsIGNsb25lLCBzdG9wTm9kZSwgcm9vdCApO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBfbWVyZ2VJbmxpbmVzICggbm9kZSwgZmFrZVJhbmdlICkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgbCA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgZnJhZ3MgPSBbXSxcbiAgICAgICAgY2hpbGQsIHByZXYsIGxlbjtcbiAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltsXTtcbiAgICAgICAgcHJldiA9IGwgJiYgY2hpbGRyZW5bIGwgLSAxIF07XG4gICAgICAgIGlmICggbCAmJiBpc0lubGluZSggY2hpbGQgKSAmJiBhcmVBbGlrZSggY2hpbGQsIHByZXYgKSAmJlxuICAgICAgICAgICAgICAgICFsZWFmTm9kZU5hbWVzWyBjaGlsZC5ub2RlTmFtZSBdICkge1xuICAgICAgICAgICAgaWYgKCBmYWtlUmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGNoaWxkICkge1xuICAgICAgICAgICAgICAgIGZha2VSYW5nZS5zdGFydENvbnRhaW5lciA9IHByZXY7XG4gICAgICAgICAgICAgICAgZmFrZVJhbmdlLnN0YXJ0T2Zmc2V0ICs9IGdldExlbmd0aCggcHJldiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmYWtlUmFuZ2UuZW5kQ29udGFpbmVyID09PSBjaGlsZCApIHtcbiAgICAgICAgICAgICAgICBmYWtlUmFuZ2UuZW5kQ29udGFpbmVyID0gcHJldjtcbiAgICAgICAgICAgICAgICBmYWtlUmFuZ2UuZW5kT2Zmc2V0ICs9IGdldExlbmd0aCggcHJldiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmYWtlUmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBmYWtlUmFuZ2Uuc3RhcnRPZmZzZXQgPiBsICkge1xuICAgICAgICAgICAgICAgICAgICBmYWtlUmFuZ2Uuc3RhcnRPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGZha2VSYW5nZS5zdGFydE9mZnNldCA9PT0gbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZmFrZVJhbmdlLnN0YXJ0Q29udGFpbmVyID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgZmFrZVJhbmdlLnN0YXJ0T2Zmc2V0ID0gZ2V0TGVuZ3RoKCBwcmV2ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmYWtlUmFuZ2UuZW5kQ29udGFpbmVyID09PSBub2RlICkge1xuICAgICAgICAgICAgICAgIGlmICggZmFrZVJhbmdlLmVuZE9mZnNldCA+IGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZha2VSYW5nZS5lbmRPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGZha2VSYW5nZS5lbmRPZmZzZXQgPT09IGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZha2VSYW5nZS5lbmRDb250YWluZXIgPSBwcmV2O1xuICAgICAgICAgICAgICAgICAgICBmYWtlUmFuZ2UuZW5kT2Zmc2V0ID0gZ2V0TGVuZ3RoKCBwcmV2ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0YWNoKCBjaGlsZCApO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICkge1xuICAgICAgICAgICAgICAgIHByZXYuYXBwZW5kRGF0YSggY2hpbGQuZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaCggZW1wdHkoIGNoaWxkICkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggY2hpbGQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSApIHtcbiAgICAgICAgICAgIGxlbiA9IGZyYWdzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYXBwZW5kQ2hpbGQoIGZyYWdzLnBvcCgpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWVyZ2VJbmxpbmVzKCBjaGlsZCwgZmFrZVJhbmdlICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW5saW5lcyAoIG5vZGUsIHJhbmdlICkge1xuICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSApIHtcbiAgICAgICAgdmFyIGZha2VSYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyOiByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZENvbnRhaW5lcjogcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiByYW5nZS5lbmRPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgICAgX21lcmdlSW5saW5lcyggbm9kZSwgZmFrZVJhbmdlICk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KCBmYWtlUmFuZ2Uuc3RhcnRDb250YWluZXIsIGZha2VSYW5nZS5zdGFydE9mZnNldCApO1xuICAgICAgICByYW5nZS5zZXRFbmQoIGZha2VSYW5nZS5lbmRDb250YWluZXIsIGZha2VSYW5nZS5lbmRPZmZzZXQgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlV2l0aEJsb2NrICggYmxvY2ssIG5leHQsIHJhbmdlLCByb290ICkge1xuICAgIHZhciBjb250YWluZXIgPSBuZXh0O1xuICAgIHZhciBwYXJlbnQsIGxhc3QsIG9mZnNldDtcbiAgICB3aGlsZSAoICggcGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGUgKSAmJlxuICAgICAgICAgICAgcGFyZW50ICE9PSByb290ICYmXG4gICAgICAgICAgICBwYXJlbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJlxuICAgICAgICAgICAgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuICAgICAgICBjb250YWluZXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGRldGFjaCggY29udGFpbmVyICk7XG5cbiAgICBvZmZzZXQgPSBibG9jay5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIC8vIFJlbW92ZSBleHRyYSA8QlI+IGZpeGVyIGlmIHByZXNlbnQuXG4gICAgbGFzdCA9IGJsb2NrLmxhc3RDaGlsZDtcbiAgICBpZiAoIGxhc3QgJiYgbGFzdC5ub2RlTmFtZSA9PT0gJ0JSJyApIHtcbiAgICAgICAgYmxvY2sucmVtb3ZlQ2hpbGQoIGxhc3QgKTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgfVxuXG4gICAgYmxvY2suYXBwZW5kQ2hpbGQoIGVtcHR5KCBuZXh0ICkgKTtcblxuICAgIHJhbmdlLnNldFN0YXJ0KCBibG9jaywgb2Zmc2V0ICk7XG4gICAgcmFuZ2UuY29sbGFwc2UoIHRydWUgKTtcbiAgICBtZXJnZUlubGluZXMoIGJsb2NrLCByYW5nZSApO1xuXG4gICAgLy8gT3BlcmEgaW5zZXJ0cyBhIEJSIGlmIHlvdSBkZWxldGUgdGhlIGxhc3QgcGllY2Ugb2YgdGV4dFxuICAgIC8vIGluIGEgYmxvY2stbGV2ZWwgZWxlbWVudC4gVW5mb3J0dW5hdGVseSwgaXQgdGhlbiBnZXRzXG4gICAgLy8gY29uZnVzZWQgd2hlbiBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gc3Vic2VxdWVudGx5IGFuZFxuICAgIC8vIHJlZnVzZXMgdG8gYWNjZXB0IHRoZSByYW5nZSB0aGF0IGZpbmlzaGVzIGp1c3QgYmVmb3JlIHRoZVxuICAgIC8vIEJSLiBSZW1vdmluZyB0aGUgQlIgZml4ZXMgdGhlIGJ1Zy5cbiAgICAvLyBTdGVwcyB0byByZXByb2R1Y2UgYnVnOiBUeXBlIFwiYS1iLWNcIiAod2hlcmUgLSBpcyByZXR1cm4pXG4gICAgLy8gdGhlbiBiYWNrc3BhY2UgdHdpY2UuIFRoZSBjdXJzb3IgZ29lcyB0byB0aGUgdG9wIGluc3RlYWRcbiAgICAvLyBvZiBhZnRlciBcImJcIi5cbiAgICBpZiAoIGlzUHJlc3RvICYmICggbGFzdCA9IGJsb2NrLmxhc3RDaGlsZCApICYmIGxhc3Qubm9kZU5hbWUgPT09ICdCUicgKSB7XG4gICAgICAgIGJsb2NrLnJlbW92ZUNoaWxkKCBsYXN0ICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUNvbnRhaW5lcnMgKCBub2RlLCByb290ICkge1xuICAgIHZhciBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgIGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLFxuICAgICAgICBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGlzTGlzdEl0ZW0gPSAoIG5vZGUubm9kZU5hbWUgPT09ICdMSScgKSxcbiAgICAgICAgbmVlZHNGaXgsIGJsb2NrO1xuXG4gICAgLy8gRG8gbm90IG1lcmdlIExJcywgdW5sZXNzIGl0IG9ubHkgY29udGFpbnMgYSBVTFxuICAgIGlmICggaXNMaXN0SXRlbSAmJiAoICFmaXJzdCB8fCAhL15bT1VdTCQvLnRlc3QoIGZpcnN0Lm5vZGVOYW1lICkgKSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggcHJldiAmJiBhcmVBbGlrZSggcHJldiwgbm9kZSApICkge1xuICAgICAgICBpZiAoICFpc0NvbnRhaW5lciggcHJldiApICkge1xuICAgICAgICAgICAgaWYgKCBpc0xpc3RJdGVtICkge1xuICAgICAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlRWxlbWVudCggZG9jLCAnRElWJyApO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKCBlbXB0eSggcHJldiApICk7XG4gICAgICAgICAgICAgICAgcHJldi5hcHBlbmRDaGlsZCggYmxvY2sgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFjaCggbm9kZSApO1xuICAgICAgICBuZWVkc0ZpeCA9ICFpc0NvbnRhaW5lciggbm9kZSApO1xuICAgICAgICBwcmV2LmFwcGVuZENoaWxkKCBlbXB0eSggbm9kZSApICk7XG4gICAgICAgIGlmICggbmVlZHNGaXggKSB7XG4gICAgICAgICAgICBmaXhDb250YWluZXIoIHByZXYsIHJvb3QgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGZpcnN0ICkge1xuICAgICAgICAgICAgbWVyZ2VDb250YWluZXJzKCBmaXJzdCwgcm9vdCApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICggaXNMaXN0SXRlbSApIHtcbiAgICAgICAgcHJldiA9IGNyZWF0ZUVsZW1lbnQoIGRvYywgJ0RJVicgKTtcbiAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoIHByZXYsIGZpcnN0ICk7XG4gICAgICAgIGZpeEN1cnNvciggcHJldiwgcm9vdCApO1xuICAgIH1cbn1cblxudmFyIGdldE5vZGVCZWZvcmUgPSBmdW5jdGlvbiAoIG5vZGUsIG9mZnNldCApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgd2hpbGUgKCBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICkge1xuICAgICAgICBub2RlID0gY2hpbGRyZW5bIG9mZnNldCAtIDEgXTtcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIG9mZnNldCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgZ2V0Tm9kZUFmdGVyID0gZnVuY3Rpb24gKCBub2RlLCBvZmZzZXQgKSB7XG4gICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKCBvZmZzZXQgPCBjaGlsZHJlbi5sZW5ndGggKSB7XG4gICAgICAgICAgICBub2RlID0gY2hpbGRyZW5bIG9mZnNldCBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCBub2RlICYmICFub2RlLm5leHRTaWJsaW5nICkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG5vZGUgKSB7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vLyAtLS1cblxudmFyIGluc2VydE5vZGVJblJhbmdlID0gZnVuY3Rpb24gKCByYW5nZSwgbm9kZSApIHtcbiAgICAvLyBJbnNlcnQgYXQgc3RhcnQuXG4gICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgICBwYXJlbnQsIGNoaWxkcmVuLCBjaGlsZENvdW50LCBhZnRlclNwbGl0O1xuXG4gICAgLy8gSWYgcGFydCB3YXkgdGhyb3VnaCBhIHRleHQgbm9kZSwgc3BsaXQgaXQuXG4gICAgaWYgKCBzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICkge1xuICAgICAgICBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIHN0YXJ0T2Zmc2V0ID09PSBzdGFydENvbnRhaW5lci5sZW5ndGggKSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IGluZGV4T2YuY2FsbCggY2hpbGRyZW4sIHN0YXJ0Q29udGFpbmVyICkgKyAxO1xuICAgICAgICAgICAgaWYgKCByYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBzdGFydE9mZnNldCApIHtcbiAgICAgICAgICAgICAgICBhZnRlclNwbGl0ID0gc3RhcnRDb250YWluZXIuc3BsaXRUZXh0KCBzdGFydE9mZnNldCApO1xuICAgICAgICAgICAgICAgIGlmICggZW5kQ29udGFpbmVyID09PSBzdGFydENvbnRhaW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0IC09IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSBhZnRlclNwbGl0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggZW5kQ29udGFpbmVyID09PSBwYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGFmdGVyU3BsaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IGluZGV4T2YuY2FsbCggY2hpbGRyZW4sIHN0YXJ0Q29udGFpbmVyICk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBwYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgIH1cblxuICAgIGNoaWxkQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBpZiAoIHN0YXJ0T2Zmc2V0ID09PSBjaGlsZENvdW50ICkge1xuICAgICAgICBzdGFydENvbnRhaW5lci5hcHBlbmRDaGlsZCggbm9kZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyLmluc2VydEJlZm9yZSggbm9kZSwgY2hpbGRyZW5bIHN0YXJ0T2Zmc2V0IF0gKTtcbiAgICB9XG5cbiAgICBpZiAoIHN0YXJ0Q29udGFpbmVyID09PSBlbmRDb250YWluZXIgKSB7XG4gICAgICAgIGVuZE9mZnNldCArPSBjaGlsZHJlbi5sZW5ndGggLSBjaGlsZENvdW50O1xuICAgIH1cblxuICAgIHJhbmdlLnNldFN0YXJ0KCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQgKTtcbiAgICByYW5nZS5zZXRFbmQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ICk7XG59O1xuXG52YXIgZXh0cmFjdENvbnRlbnRzT2ZSYW5nZSA9IGZ1bmN0aW9uICggcmFuZ2UsIGNvbW1vbiwgcm9vdCApIHtcbiAgICB2YXIgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgc3RhcnRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgZW5kQ29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICBlbmRPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG5cbiAgICBpZiAoICFjb21tb24gKSB7XG4gICAgICAgIGNvbW1vbiA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIGlmICggY29tbW9uLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgIGNvbW1vbiA9IGNvbW1vbi5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHZhciBlbmROb2RlID0gc3BsaXQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0LCBjb21tb24sIHJvb3QgKSxcbiAgICAgICAgc3RhcnROb2RlID0gc3BsaXQoIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgY29tbW9uLCByb290ICksXG4gICAgICAgIGZyYWcgPSBjb21tb24ub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIG5leHQsIGJlZm9yZSwgYWZ0ZXIsIGJlZm9yZVRleHQsIGFmdGVyVGV4dDtcblxuICAgIC8vIEVuZCBub2RlIHdpbGwgYmUgbnVsbCBpZiBhdCBlbmQgb2YgY2hpbGQgbm9kZXMgbGlzdC5cbiAgICB3aGlsZSAoIHN0YXJ0Tm9kZSAhPT0gZW5kTm9kZSApIHtcbiAgICAgICAgbmV4dCA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCggc3RhcnROb2RlICk7XG4gICAgICAgIHN0YXJ0Tm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgc3RhcnRDb250YWluZXIgPSBjb21tb247XG4gICAgc3RhcnRPZmZzZXQgPSBlbmROb2RlID9cbiAgICAgICAgaW5kZXhPZi5jYWxsKCBjb21tb24uY2hpbGROb2RlcywgZW5kTm9kZSApIDpcbiAgICAgICAgY29tbW9uLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gTWVyZ2UgdGV4dCBub2RlcyBpZiBhZGphY2VudC4gSUUxMCBpbiBwYXJ0aWN1bGFyIHdpbGwgbm90IGZvY3VzXG4gICAgLy8gYmV0d2VlbiB0d28gdGV4dCBub2Rlc1xuICAgIGFmdGVyID0gY29tbW9uLmNoaWxkTm9kZXNbIHN0YXJ0T2Zmc2V0IF07XG4gICAgYmVmb3JlID0gYWZ0ZXIgJiYgYWZ0ZXIucHJldmlvdXNTaWJsaW5nO1xuICAgIGlmICggYmVmb3JlICYmXG4gICAgICAgICAgICBiZWZvcmUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgYWZ0ZXIubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBiZWZvcmU7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGJlZm9yZS5kYXRhO1xuICAgICAgICBhZnRlclRleHQgPSBhZnRlci5kYXRhO1xuXG4gICAgICAgIC8vIElmIHdlIG5vdyBoYXZlIHR3byBhZGphY2VudCBzcGFjZXMsIHRoZSBzZWNvbmQgb25lIG5lZWRzIHRvIGJlY29tZVxuICAgICAgICAvLyBhIG5ic3AsIG90aGVyd2lzZSB0aGUgYnJvd3NlciB3aWxsIHN3YWxsb3cgaXQgZHVlIHRvIEhUTUwgd2hpdGVzcGFjZVxuICAgICAgICAvLyBjb2xsYXBzaW5nLlxuICAgICAgICBpZiAoIGJlZm9yZVRleHQuY2hhckF0KCBiZWZvcmVUZXh0Lmxlbmd0aCAtIDEgKSA9PT0gJyAnICYmXG4gICAgICAgICAgICAgICAgYWZ0ZXJUZXh0LmNoYXJBdCggMCApID09PSAnICcgKSB7XG4gICAgICAgICAgICBhZnRlclRleHQgPSAnICcgKyBhZnRlclRleHQuc2xpY2UoIDEgKTsgLy8gbmJzcFxuICAgICAgICB9XG4gICAgICAgIGJlZm9yZS5hcHBlbmREYXRhKCBhZnRlclRleHQgKTtcbiAgICAgICAgZGV0YWNoKCBhZnRlciApO1xuICAgIH1cblxuICAgIHJhbmdlLnNldFN0YXJ0KCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQgKTtcbiAgICByYW5nZS5jb2xsYXBzZSggdHJ1ZSApO1xuXG4gICAgZml4Q3Vyc29yKCBjb21tb24sIHJvb3QgKTtcblxuICAgIHJldHVybiBmcmFnO1xufTtcblxudmFyIGRlbGV0ZUNvbnRlbnRzT2ZSYW5nZSA9IGZ1bmN0aW9uICggcmFuZ2UsIHJvb3QgKSB7XG4gICAgdmFyIHN0YXJ0QmxvY2sgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICB2YXIgZW5kQmxvY2sgPSBnZXRFbmRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgdmFyIG5lZWRzTWVyZ2UgPSAoIHN0YXJ0QmxvY2sgIT09IGVuZEJsb2NrICk7XG4gICAgdmFyIGZyYWcsIGNoaWxkO1xuXG4gICAgLy8gTW92ZSBib3VuZGFyaWVzIHVwIGFzIG11Y2ggYXMgcG9zc2libGUgd2l0aG91dCBleGl0aW5nIGJsb2NrLFxuICAgIC8vIHRvIHJlZHVjZSBuZWVkIHRvIHNwbGl0LlxuICAgIG1vdmVSYW5nZUJvdW5kYXJpZXNEb3duVHJlZSggcmFuZ2UgKTtcbiAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzVXBUcmVlKCByYW5nZSwgc3RhcnRCbG9jaywgZW5kQmxvY2ssIHJvb3QgKTtcblxuICAgIC8vIFJlbW92ZSBzZWxlY3RlZCByYW5nZVxuICAgIGZyYWcgPSBleHRyYWN0Q29udGVudHNPZlJhbmdlKCByYW5nZSwgbnVsbCwgcm9vdCApO1xuXG4gICAgLy8gTW92ZSBib3VuZGFyaWVzIGJhY2sgZG93biB0cmVlIGFzIGZhciBhcyBwb3NzaWJsZS5cbiAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzRG93blRyZWUoIHJhbmdlICk7XG5cbiAgICAvLyBJZiB3ZSBzcGxpdCBpbnRvIHR3byBkaWZmZXJlbnQgYmxvY2tzLCBtZXJnZSB0aGUgYmxvY2tzLlxuICAgIGlmICggbmVlZHNNZXJnZSApIHtcbiAgICAgICAgLy8gZW5kQmxvY2sgd2lsbCBoYXZlIGJlZW4gc3BsaXQsIHNvIG5lZWQgdG8gcmVmZXRjaFxuICAgICAgICBlbmRCbG9jayA9IGdldEVuZEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgaWYgKCBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmIHN0YXJ0QmxvY2sgIT09IGVuZEJsb2NrICkge1xuICAgICAgICAgICAgbWVyZ2VXaXRoQmxvY2soIHN0YXJ0QmxvY2ssIGVuZEJsb2NrLCByYW5nZSwgcm9vdCApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGJsb2NrIGhhcyBuZWNlc3NhcnkgY2hpbGRyZW5cbiAgICBpZiAoIHN0YXJ0QmxvY2sgKSB7XG4gICAgICAgIGZpeEN1cnNvciggc3RhcnRCbG9jaywgcm9vdCApO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSByb290IGhhcyBhIGJsb2NrLWxldmVsIGVsZW1lbnQgaW4gaXQuXG4gICAgY2hpbGQgPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKCAhY2hpbGQgfHwgY2hpbGQubm9kZU5hbWUgPT09ICdCUicgKSB7XG4gICAgICAgIGZpeEN1cnNvciggcm9vdCwgcm9vdCApO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoIHJvb3QuZmlyc3RDaGlsZCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKCB0cnVlICk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xufTtcblxuLy8gLS0tXG5cbi8vIENvbnRlbnRzIG9mIHJhbmdlIHdpbGwgYmUgZGVsZXRlZC5cbi8vIEFmdGVyIG1ldGhvZCwgcmFuZ2Ugd2lsbCBiZSBhcm91bmQgaW5zZXJ0ZWQgY29udGVudFxudmFyIGluc2VydFRyZWVGcmFnbWVudEludG9SYW5nZSA9IGZ1bmN0aW9uICggcmFuZ2UsIGZyYWcsIHJvb3QgKSB7XG4gICAgdmFyIG5vZGUsIGJsb2NrLCBibG9ja0NvbnRlbnRzQWZ0ZXJTcGxpdCwgc3RvcFBvaW50LCBjb250YWluZXIsIG9mZnNldDtcbiAgICB2YXIgcmVwbGFjZUJsb2NrLCBmaXJzdEJsb2NrSW5GcmFnLCBub2RlQWZ0ZXJTcGxpdCwgbm9kZUJlZm9yZVNwbGl0O1xuICAgIHZhciB0ZW1wUmFuZ2U7XG5cbiAgICAvLyBGaXh1cCBjb250ZW50OiBlbnN1cmUgbm8gdG9wLWxldmVsIGlubGluZSwgYW5kIGFkZCBjdXJzb3IgZml4IGVsZW1lbnRzLlxuICAgIGZpeENvbnRhaW5lciggZnJhZywgcm9vdCApO1xuICAgIG5vZGUgPSBmcmFnO1xuICAgIHdoaWxlICggKCBub2RlID0gZ2V0TmV4dEJsb2NrKCBub2RlLCByb290ICkgKSApIHtcbiAgICAgICAgZml4Q3Vyc29yKCBub2RlLCByb290ICk7XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGFueSBzZWxlY3RlZCBjb250ZW50LlxuICAgIGlmICggIXJhbmdlLmNvbGxhcHNlZCApIHtcbiAgICAgICAgZGVsZXRlQ29udGVudHNPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuICAgIH1cblxuICAgIC8vIE1vdmUgcmFuZ2UgZG93biBpbnRvIHRleHQgbm9kZXMuXG4gICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuICAgIHJhbmdlLmNvbGxhcHNlKCBmYWxzZSApOyAvLyBjb2xsYXBzZSB0byBlbmRcblxuICAgIC8vIFdoZXJlIHdpbGwgd2Ugc3BsaXQgdXAgdG8/IEZpcnN0IGJsb2NrcXVvdGUgcGFyZW50LCBvdGhlcndpc2Ugcm9vdC5cbiAgICBzdG9wUG9pbnQgPSBnZXROZWFyZXN0KCByYW5nZS5lbmRDb250YWluZXIsIHJvb3QsICdCTE9DS1FVT1RFJyApIHx8IHJvb3Q7XG5cbiAgICAvLyBNZXJnZSB0aGUgY29udGVudHMgb2YgdGhlIGZpcnN0IGJsb2NrIGluIHRoZSBmcmFnIHdpdGggdGhlIGZvY3VzZWQgYmxvY2suXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNvbnRlbnRzIGluIHRoZSBibG9jayBhZnRlciB0aGUgZm9jdXMgcG9pbnQsIGNvbGxlY3QgdGhpc1xuICAgIC8vIHVwIHRvIGluc2VydCBpbiB0aGUgbGFzdCBibG9jayBsYXRlci4gSWYgdGhlIGJsb2NrIGlzIGVtcHR5LCByZXBsYWNlXG4gICAgLy8gaXQgaW5zdGVhZCBvZiBtZXJnaW5nLlxuICAgIGJsb2NrID0gZ2V0U3RhcnRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgZmlyc3RCbG9ja0luRnJhZyA9IGdldE5leHRCbG9jayggZnJhZywgZnJhZyApO1xuICAgIHJlcGxhY2VCbG9jayA9ICEhYmxvY2sgJiYgaXNFbXB0eUJsb2NrKCBibG9jayApO1xuICAgIGlmICggYmxvY2sgJiYgZmlyc3RCbG9ja0luRnJhZyAmJiAhcmVwbGFjZUJsb2NrICYmXG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB0YWJsZSBjZWxscyBvciBQUkUgZWxlbWVudHMgaW50byBibG9ja1xuICAgICAgICAgICAgIWdldE5lYXJlc3QoIGZpcnN0QmxvY2tJbkZyYWcsIGZyYWcsICdQUkUnICkgJiZcbiAgICAgICAgICAgICFnZXROZWFyZXN0KCBmaXJzdEJsb2NrSW5GcmFnLCBmcmFnLCAnVEFCTEUnICkgKSB7XG4gICAgICAgIG1vdmVSYW5nZUJvdW5kYXJpZXNVcFRyZWUoIHJhbmdlLCBibG9jaywgYmxvY2ssIHJvb3QgKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoIHRydWUgKTsgLy8gY29sbGFwc2UgdG8gc3RhcnRcbiAgICAgICAgY29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICBvZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyA8YnI+IOKAkyB3ZSBkb24ndCB3YW50IHRoaXMgY29uc2lkZXJlZCBjb250ZW50IHRvIGJlXG4gICAgICAgIC8vIGluc2VydGVkIGFnYWluIGxhdGVyXG4gICAgICAgIGNsZWFudXBCUnMoIGJsb2NrLCByb290LCBmYWxzZSApO1xuICAgICAgICBpZiAoIGlzSW5saW5lKCBjb250YWluZXIgKSApIHtcbiAgICAgICAgICAgIC8vIFNwbGl0IHVwIHRvIGJsb2NrIHBhcmVudC5cbiAgICAgICAgICAgIG5vZGVBZnRlclNwbGl0ID0gc3BsaXQoXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLCBvZmZzZXQsIGdldFByZXZpb3VzQmxvY2soIGNvbnRhaW5lciwgcm9vdCApLCByb290ICk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBub2RlQWZ0ZXJTcGxpdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaW5kZXhPZi5jYWxsKCBjb250YWluZXIuY2hpbGROb2Rlcywgbm9kZUFmdGVyU3BsaXQgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIC8qaXNCbG9jayggY29udGFpbmVyICkgJiYgKi9vZmZzZXQgIT09IGdldExlbmd0aCggY29udGFpbmVyICkgKSB7XG4gICAgICAgICAgICAvLyBDb2xsZWN0IGFueSBpbmxpbmUgY29udGVudHMgb2YgdGhlIGJsb2NrIGFmdGVyIHRoZSByYW5nZSBwb2ludFxuICAgICAgICAgICAgYmxvY2tDb250ZW50c0FmdGVyU3BsaXQgPVxuICAgICAgICAgICAgICAgIHJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAoICggbm9kZSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzWyBvZmZzZXQgXSApICkge1xuICAgICAgICAgICAgICAgIGJsb2NrQ29udGVudHNBZnRlclNwbGl0LmFwcGVuZENoaWxkKCBub2RlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5kIG1lcmdlIHRoZSBmaXJzdCBibG9jayBpbi5cbiAgICAgICAgbWVyZ2VXaXRoQmxvY2soIGNvbnRhaW5lciwgZmlyc3RCbG9ja0luRnJhZywgcmFuZ2UsIHJvb3QgKTtcblxuICAgICAgICAvLyBBbmQgd2hlcmUgd2Ugd2lsbCBpbnNlcnRcbiAgICAgICAgb2Zmc2V0ID0gaW5kZXhPZi5jYWxsKCBjb250YWluZXIucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBjb250YWluZXIgKSArIDE7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICByYW5nZS5zZXRFbmQoIGNvbnRhaW5lciwgb2Zmc2V0ICk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlcmUgc3RpbGwgYW55IGNvbnRlbnQgaW4gdGhlIGZyYWdtZW50P1xuICAgIGlmICggZ2V0TGVuZ3RoKCBmcmFnICkgKSB7XG4gICAgICAgIGlmICggcmVwbGFjZUJsb2NrICkge1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQmVmb3JlKCBibG9jayApO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoIGZhbHNlICk7XG4gICAgICAgICAgICBkZXRhY2goIGJsb2NrICk7XG4gICAgICAgIH1cbiAgICAgICAgbW92ZVJhbmdlQm91bmRhcmllc1VwVHJlZSggcmFuZ2UsIHN0b3BQb2ludCwgc3RvcFBvaW50LCByb290ICk7XG4gICAgICAgIC8vIE5vdyBzcGxpdCBhZnRlciBibG9jayB1cCB0byBibG9ja3F1b3RlIChpZiBhIHBhcmVudCkgb3Igcm9vdFxuICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IHNwbGl0KFxuICAgICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIHN0b3BQb2ludCwgcm9vdCApO1xuICAgICAgICBub2RlQmVmb3JlU3BsaXQgPSBub2RlQWZ0ZXJTcGxpdCA/XG4gICAgICAgICAgICBub2RlQWZ0ZXJTcGxpdC5wcmV2aW91c1NpYmxpbmcgOlxuICAgICAgICAgICAgc3RvcFBvaW50Lmxhc3RDaGlsZDtcbiAgICAgICAgc3RvcFBvaW50Lmluc2VydEJlZm9yZSggZnJhZywgbm9kZUFmdGVyU3BsaXQgKTtcbiAgICAgICAgaWYgKCBub2RlQWZ0ZXJTcGxpdCApIHtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZSggbm9kZUFmdGVyU3BsaXQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZCggc3RvcFBvaW50LCBnZXRMZW5ndGgoIHN0b3BQb2ludCApICk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2sgPSBnZXRFbmRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG5cbiAgICAgICAgLy8gR2V0IGEgcmVmZXJlbmNlIHRoYXQgd29uJ3QgYmUgaW52YWxpZGF0ZWQgaWYgd2UgbWVyZ2UgY29udGFpbmVycy5cbiAgICAgICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuICAgICAgICBjb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIG9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcblxuICAgICAgICAvLyBNZXJnZSBpbnNlcnRlZCBjb250YWluZXJzIHdpdGggZWRnZXMgb2Ygc3BsaXRcbiAgICAgICAgaWYgKCBub2RlQWZ0ZXJTcGxpdCAmJiBpc0NvbnRhaW5lciggbm9kZUFmdGVyU3BsaXQgKSApIHtcbiAgICAgICAgICAgIG1lcmdlQ29udGFpbmVycyggbm9kZUFmdGVyU3BsaXQsIHJvb3QgKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IG5vZGVCZWZvcmVTcGxpdCAmJiBub2RlQmVmb3JlU3BsaXQubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICggbm9kZUFmdGVyU3BsaXQgJiYgaXNDb250YWluZXIoIG5vZGVBZnRlclNwbGl0ICkgKSB7XG4gICAgICAgICAgICBtZXJnZUNvbnRhaW5lcnMoIG5vZGVBZnRlclNwbGl0LCByb290ICk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2Uuc2V0RW5kKCBjb250YWluZXIsIG9mZnNldCApO1xuICAgIH1cblxuICAgIC8vIEluc2VydCBpbmxpbmUgY29udGVudCBzYXZlZCBmcm9tIGJlZm9yZS5cbiAgICBpZiAoIGJsb2NrQ29udGVudHNBZnRlclNwbGl0ICkge1xuICAgICAgICB0ZW1wUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIG1lcmdlV2l0aEJsb2NrKCBibG9jaywgYmxvY2tDb250ZW50c0FmdGVyU3BsaXQsIHRlbXBSYW5nZSwgcm9vdCApO1xuICAgICAgICByYW5nZS5zZXRFbmQoIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQgKTtcbiAgICB9XG4gICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xufTtcblxuLy8gLS0tXG5cbnZhciBpc05vZGVDb250YWluZWRJblJhbmdlID0gZnVuY3Rpb24gKCByYW5nZSwgbm9kZSwgcGFydGlhbCApIHtcbiAgICB2YXIgbm9kZVJhbmdlID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICBub2RlUmFuZ2Uuc2VsZWN0Tm9kZSggbm9kZSApO1xuXG4gICAgaWYgKCBwYXJ0aWFsICkge1xuICAgICAgICAvLyBOb2RlIG11c3Qgbm90IGZpbmlzaCBiZWZvcmUgcmFuZ2Ugc3RhcnRzIG9yIHN0YXJ0IGFmdGVyIHJhbmdlXG4gICAgICAgIC8vIGZpbmlzaGVzLlxuICAgICAgICB2YXIgbm9kZUVuZEJlZm9yZVN0YXJ0ID0gKCByYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoXG4gICAgICAgICAgICAgICAgRU5EX1RPX1NUQVJULCBub2RlUmFuZ2UgKSA+IC0xICksXG4gICAgICAgICAgICBub2RlU3RhcnRBZnRlckVuZCA9ICggcmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKFxuICAgICAgICAgICAgICAgIFNUQVJUX1RPX0VORCwgbm9kZVJhbmdlICkgPCAxICk7XG4gICAgICAgIHJldHVybiAoICFub2RlRW5kQmVmb3JlU3RhcnQgJiYgIW5vZGVTdGFydEFmdGVyRW5kICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBOb2RlIG11c3Qgc3RhcnQgYWZ0ZXIgcmFuZ2Ugc3RhcnRzIGFuZCBmaW5pc2ggYmVmb3JlIHJhbmdlXG4gICAgICAgIC8vIGZpbmlzaGVzXG4gICAgICAgIHZhciBub2RlU3RhcnRBZnRlclN0YXJ0ID0gKCByYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoXG4gICAgICAgICAgICAgICAgU1RBUlRfVE9fU1RBUlQsIG5vZGVSYW5nZSApIDwgMSApLFxuICAgICAgICAgICAgbm9kZUVuZEJlZm9yZUVuZCA9ICggcmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKFxuICAgICAgICAgICAgICAgIEVORF9UT19FTkQsIG5vZGVSYW5nZSApID4gLTEgKTtcbiAgICAgICAgcmV0dXJuICggbm9kZVN0YXJ0QWZ0ZXJTdGFydCAmJiBub2RlRW5kQmVmb3JlRW5kICk7XG4gICAgfVxufTtcblxudmFyIG1vdmVSYW5nZUJvdW5kYXJpZXNEb3duVHJlZSA9IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG4gICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgICBtYXlTa2lwQlIgPSB0cnVlLFxuICAgICAgICBjaGlsZDtcblxuICAgIHdoaWxlICggc3RhcnRDb250YWluZXIubm9kZVR5cGUgIT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgY2hpbGQgPSBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzWyBzdGFydE9mZnNldCBdO1xuICAgICAgICBpZiAoICFjaGlsZCB8fCBpc0xlYWYoIGNoaWxkICkgKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGFydENvbnRhaW5lciA9IGNoaWxkO1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmICggZW5kT2Zmc2V0ICkge1xuICAgICAgICB3aGlsZSAoIGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbmRDb250YWluZXIuY2hpbGROb2Rlc1sgZW5kT2Zmc2V0IC0gMSBdO1xuICAgICAgICAgICAgaWYgKCAhY2hpbGQgfHwgaXNMZWFmKCBjaGlsZCApICkge1xuICAgICAgICAgICAgICAgIGlmICggbWF5U2tpcEJSICYmIGNoaWxkICYmIGNoaWxkLm5vZGVOYW1lID09PSAnQlInICkge1xuICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF5U2tpcEJSID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGNoaWxkO1xuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gZ2V0TGVuZ3RoKCBlbmRDb250YWluZXIgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlICggZW5kQ29udGFpbmVyLm5vZGVUeXBlICE9PSBURVhUX05PREUgKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVuZENvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCAhY2hpbGQgfHwgaXNMZWFmKCBjaGlsZCApICkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBjb2xsYXBzZWQsIHRoaXMgYWxnb3JpdGhtIGZpbmRzIHRoZSBuZWFyZXN0IHRleHQgbm9kZSBwb3NpdGlvbnNcbiAgICAvLyAqb3V0c2lkZSogdGhlIHJhbmdlIHJhdGhlciB0aGFuIGluc2lkZSwgYnV0IGFsc28gaXQgZmxpcHMgd2hpY2ggaXNcbiAgICAvLyBhc3NpZ25lZCB0byB3aGljaC5cbiAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCApIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ICk7XG4gICAgICAgIHJhbmdlLnNldEVuZCggc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCApO1xuICAgICAgICByYW5nZS5zZXRFbmQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ICk7XG4gICAgfVxufTtcblxudmFyIG1vdmVSYW5nZUJvdW5kYXJpZXNVcFRyZWUgPSBmdW5jdGlvbiAoIHJhbmdlLCBzdGFydE1heCwgZW5kTWF4LCByb290ICkge1xuICAgIHZhciBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIHZhciBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgdmFyIGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICB2YXIgbWF5U2tpcEJSID0gdHJ1ZTtcbiAgICB2YXIgcGFyZW50O1xuXG4gICAgaWYgKCAhc3RhcnRNYXggKSB7XG4gICAgICAgIHN0YXJ0TWF4ID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuICAgIGlmICggIWVuZE1heCApIHtcbiAgICAgICAgZW5kTWF4ID0gc3RhcnRNYXg7XG4gICAgfVxuXG4gICAgd2hpbGUgKCAhc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyICE9PSBzdGFydE1heCAmJlxuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgIT09IHJvb3QgKSB7XG4gICAgICAgIHBhcmVudCA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gaW5kZXhPZi5jYWxsKCBwYXJlbnQuY2hpbGROb2Rlcywgc3RhcnRDb250YWluZXIgKTtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKCB0cnVlICkge1xuICAgICAgICBpZiAoIG1heVNraXBCUiAmJlxuICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICYmXG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyLmNoaWxkTm9kZXNbIGVuZE9mZnNldCBdICYmXG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyLmNoaWxkTm9kZXNbIGVuZE9mZnNldCBdLm5vZGVOYW1lID09PSAnQlInICkge1xuICAgICAgICAgICAgZW5kT2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICBtYXlTa2lwQlIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGVuZENvbnRhaW5lciA9PT0gZW5kTWF4IHx8XG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID09PSByb290IHx8XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ICE9PSBnZXRMZW5ndGgoIGVuZENvbnRhaW5lciApICkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gZW5kQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGVuZE9mZnNldCA9IGluZGV4T2YuY2FsbCggcGFyZW50LmNoaWxkTm9kZXMsIGVuZENvbnRhaW5lciApICsgMTtcbiAgICAgICAgZW5kQ29udGFpbmVyID0gcGFyZW50O1xuICAgIH1cblxuICAgIHJhbmdlLnNldFN0YXJ0KCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQgKTtcbiAgICByYW5nZS5zZXRFbmQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ICk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBibG9jayBhdCBsZWFzdCBwYXJ0aWFsbHkgY29udGFpbmVkIGJ5IHRoZSByYW5nZSxcbi8vIG9yIG51bGwgaWYgbm8gYmxvY2sgaXMgY29udGFpbmVkIGJ5IHRoZSByYW5nZS5cbnZhciBnZXRTdGFydEJsb2NrT2ZSYW5nZSA9IGZ1bmN0aW9uICggcmFuZ2UsIHJvb3QgKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICBibG9jaztcblxuICAgIC8vIElmIGlubGluZSwgZ2V0IHRoZSBjb250YWluaW5nIGJsb2NrLlxuICAgIGlmICggaXNJbmxpbmUoIGNvbnRhaW5lciApICkge1xuICAgICAgICBibG9jayA9IGdldFByZXZpb3VzQmxvY2soIGNvbnRhaW5lciwgcm9vdCApO1xuICAgIH0gZWxzZSBpZiAoIGNvbnRhaW5lciAhPT0gcm9vdCAmJiBpc0Jsb2NrKCBjb250YWluZXIgKSApIHtcbiAgICAgICAgYmxvY2sgPSBjb250YWluZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2sgPSBnZXROb2RlQmVmb3JlKCBjb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0ICk7XG4gICAgICAgIGJsb2NrID0gZ2V0TmV4dEJsb2NrKCBibG9jaywgcm9vdCApO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgYmxvY2sgYWN0dWFsbHkgaW50ZXJzZWN0cyB0aGUgcmFuZ2VcbiAgICByZXR1cm4gYmxvY2sgJiYgaXNOb2RlQ29udGFpbmVkSW5SYW5nZSggcmFuZ2UsIGJsb2NrLCB0cnVlICkgPyBibG9jayA6IG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBsYXN0IGJsb2NrIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgYnkgdGhlIHJhbmdlLFxuLy8gb3IgbnVsbCBpZiBubyBibG9jayBpcyBjb250YWluZWQgYnkgdGhlIHJhbmdlLlxudmFyIGdldEVuZEJsb2NrT2ZSYW5nZSA9IGZ1bmN0aW9uICggcmFuZ2UsIHJvb3QgKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgYmxvY2ssIGNoaWxkO1xuXG4gICAgLy8gSWYgaW5saW5lLCBnZXQgdGhlIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgaWYgKCBpc0lubGluZSggY29udGFpbmVyICkgKSB7XG4gICAgICAgIGJsb2NrID0gZ2V0UHJldmlvdXNCbG9jayggY29udGFpbmVyLCByb290ICk7XG4gICAgfSBlbHNlIGlmICggY29udGFpbmVyICE9PSByb290ICYmIGlzQmxvY2soIGNvbnRhaW5lciApICkge1xuICAgICAgICBibG9jayA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IGdldE5vZGVBZnRlciggY29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQgKTtcbiAgICAgICAgaWYgKCAhYmxvY2sgfHwgIWlzT3JDb250YWlucyggcm9vdCwgYmxvY2sgKSApIHtcbiAgICAgICAgICAgIGJsb2NrID0gcm9vdDtcbiAgICAgICAgICAgIHdoaWxlICggY2hpbGQgPSBibG9jay5sYXN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgYmxvY2sgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBibG9jayA9IGdldFByZXZpb3VzQmxvY2soIGJsb2NrLCByb290ICk7XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBibG9jayBhY3R1YWxseSBpbnRlcnNlY3RzIHRoZSByYW5nZVxuICAgIHJldHVybiBibG9jayAmJiBpc05vZGVDb250YWluZWRJblJhbmdlKCByYW5nZSwgYmxvY2ssIHRydWUgKSA/IGJsb2NrIDogbnVsbDtcbn07XG5cbnZhciBjb250ZW50V2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoIG51bGwsXG4gICAgU0hPV19URVhUfFNIT1dfRUxFTUVOVCxcbiAgICBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgP1xuICAgICAgICAgICAgbm90V1MudGVzdCggbm9kZS5kYXRhICkgOlxuICAgICAgICAgICAgbm9kZS5ub2RlTmFtZSA9PT0gJ0lNRyc7XG4gICAgfVxuKTtcblxudmFyIHJhbmdlRG9lc1N0YXJ0QXRCbG9ja0JvdW5kYXJ5ID0gZnVuY3Rpb24gKCByYW5nZSwgcm9vdCApIHtcbiAgICB2YXIgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICB2YXIgbm9kZUFmdGVyQ3Vyc29yO1xuXG4gICAgLy8gSWYgaW4gdGhlIG1pZGRsZSBvciBlbmQgb2YgYSB0ZXh0IG5vZGUsIHdlJ3JlIG5vdCBhdCB0aGUgYm91bmRhcnkuXG4gICAgY29udGVudFdhbGtlci5yb290ID0gbnVsbDtcbiAgICBpZiAoIHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgIGlmICggc3RhcnRPZmZzZXQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZUFmdGVyQ3Vyc29yID0gc3RhcnRDb250YWluZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUFmdGVyQ3Vyc29yID0gZ2V0Tm9kZUFmdGVyKCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQgKTtcbiAgICAgICAgaWYgKCBub2RlQWZ0ZXJDdXJzb3IgJiYgIWlzT3JDb250YWlucyggcm9vdCwgbm9kZUFmdGVyQ3Vyc29yICkgKSB7XG4gICAgICAgICAgICBub2RlQWZ0ZXJDdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjdXJzb3Igd2FzIHJpZ2h0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmICggIW5vZGVBZnRlckN1cnNvciApIHtcbiAgICAgICAgICAgIG5vZGVBZnRlckN1cnNvciA9IGdldE5vZGVCZWZvcmUoIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCApO1xuICAgICAgICAgICAgaWYgKCBub2RlQWZ0ZXJDdXJzb3Iubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlQWZ0ZXJDdXJzb3IubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgbG9vayBmb3IgYW55IHByZXZpb3VzIGNvbnRlbnQgaW4gdGhlIHNhbWUgYmxvY2suXG4gICAgY29udGVudFdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGVBZnRlckN1cnNvcjtcbiAgICBjb250ZW50V2Fsa2VyLnJvb3QgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcblxuICAgIHJldHVybiAhY29udGVudFdhbGtlci5wcmV2aW91c05vZGUoKTtcbn07XG5cbnZhciByYW5nZURvZXNFbmRBdEJsb2NrQm91bmRhcnkgPSBmdW5jdGlvbiAoIHJhbmdlLCByb290ICkge1xuICAgIHZhciBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIsXG4gICAgICAgIGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldCxcbiAgICAgICAgbGVuZ3RoO1xuXG4gICAgLy8gSWYgaW4gYSB0ZXh0IG5vZGUgd2l0aCBjb250ZW50LCBhbmQgbm90IGF0IHRoZSBlbmQsIHdlJ3JlIG5vdFxuICAgIC8vIGF0IHRoZSBib3VuZGFyeVxuICAgIGNvbnRlbnRXYWxrZXIucm9vdCA9IG51bGw7XG4gICAgaWYgKCBlbmRDb250YWluZXIubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgbGVuZ3RoID0gZW5kQ29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIGxlbmd0aCAmJiBlbmRPZmZzZXQgPCBsZW5ndGggKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFdhbGtlci5jdXJyZW50Tm9kZSA9IGVuZENvbnRhaW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gZ2V0Tm9kZUJlZm9yZSggZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGxvb2sgZm9yIGFueSBmdXJ0aGVyIGNvbnRlbnQgaW4gdGhlIHNhbWUgYmxvY2suXG4gICAgY29udGVudFdhbGtlci5yb290ID0gZ2V0RW5kQmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuXG4gICAgcmV0dXJuICFjb250ZW50V2Fsa2VyLm5leHROb2RlKCk7XG59O1xuXG52YXIgZXhwYW5kUmFuZ2VUb0Jsb2NrQm91bmRhcmllcyA9IGZ1bmN0aW9uICggcmFuZ2UsIHJvb3QgKSB7XG4gICAgdmFyIHN0YXJ0ID0gZ2V0U3RhcnRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICksXG4gICAgICAgIGVuZCA9IGdldEVuZEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKSxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKCBzdGFydCAmJiBlbmQgKSB7XG4gICAgICAgIHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KCBwYXJlbnQsIGluZGV4T2YuY2FsbCggcGFyZW50LmNoaWxkTm9kZXMsIHN0YXJ0ICkgKTtcbiAgICAgICAgcGFyZW50ID0gZW5kLnBhcmVudE5vZGU7XG4gICAgICAgIHJhbmdlLnNldEVuZCggcGFyZW50LCBpbmRleE9mLmNhbGwoIHBhcmVudC5jaGlsZE5vZGVzLCBlbmQgKSArIDEgKTtcbiAgICB9XG59O1xuXG52YXIga2V5cyA9IHtcbiAgICA4OiAnYmFja3NwYWNlJyxcbiAgICA5OiAndGFiJyxcbiAgICAxMzogJ2VudGVyJyxcbiAgICAzMjogJ3NwYWNlJyxcbiAgICAzMzogJ3BhZ2V1cCcsXG4gICAgMzQ6ICdwYWdlZG93bicsXG4gICAgMzc6ICdsZWZ0JyxcbiAgICAzOTogJ3JpZ2h0JyxcbiAgICA0NjogJ2RlbGV0ZScsXG4gICAgMjE5OiAnWycsXG4gICAgMjIxOiAnXSdcbn07XG5cbi8vIFJlZjogaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9rZXkuaHRtbFxudmFyIG9uS2V5ID0gZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICB2YXIgY29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgIGtleSA9IGtleXNbIGNvZGUgXSxcbiAgICAgICAgbW9kaWZpZXJzID0gJycsXG4gICAgICAgIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICggZXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggIWtleSApIHtcbiAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSggY29kZSApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIE9ubHkgcmVsaWFibGUgZm9yIGxldHRlcnMgYW5kIG51bWJlcnNcbiAgICAgICAgaWYgKCAhL15bQS1aYS16MC05XSQvLnRlc3QoIGtleSApICkge1xuICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbiBrZXlwcmVzcywgZGVsZXRlIGFuZCAnLicgYm90aCBoYXZlIGV2ZW50LmtleUNvZGUgNDZcbiAgICAvLyBNdXN0IGNoZWNrIGV2ZW50LndoaWNoIHRvIGRpZmZlcmVudGlhdGUuXG4gICAgaWYgKCBpc1ByZXN0byAmJiBldmVudC53aGljaCA9PT0gNDYgKSB7XG4gICAgICAgIGtleSA9ICcuJztcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiBrZXlzXG4gICAgaWYgKCAxMTEgPCBjb2RlICYmIGNvZGUgPCAxMjQgKSB7XG4gICAgICAgIGtleSA9ICdmJyArICggY29kZSAtIDExMSApO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gYXBwbHkgdGhlIGJhY2tzcGFjZS9kZWxldGUgaGFuZGxlcnMgcmVnYXJkbGVzcyBvZlxuICAgIC8vIGNvbnRyb2wga2V5IG1vZGlmaWVycy5cbiAgICBpZiAoIGtleSAhPT0gJ2JhY2tzcGFjZScgJiYga2V5ICE9PSAnZGVsZXRlJyApIHtcbiAgICAgICAgaWYgKCBldmVudC5hbHRLZXkgICkgeyBtb2RpZmllcnMgKz0gJ2FsdC0nOyB9XG4gICAgICAgIGlmICggZXZlbnQuY3RybEtleSApIHsgbW9kaWZpZXJzICs9ICdjdHJsLSc7IH1cbiAgICAgICAgaWYgKCBldmVudC5tZXRhS2V5ICkgeyBtb2RpZmllcnMgKz0gJ21ldGEtJzsgfVxuICAgIH1cbiAgICAvLyBIb3dldmVyLCBvbiBXaW5kb3dzLCBzaGlmdC1kZWxldGUgaXMgYXBwYXJlbnRseSBcImN1dFwiIChXVEYgcmlnaHQ/KSwgc29cbiAgICAvLyB3ZSB3YW50IHRvIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgc2hpZnQtZGVsZXRlLlxuICAgIGlmICggZXZlbnQuc2hpZnRLZXkgKSB7IG1vZGlmaWVycyArPSAnc2hpZnQtJzsgfVxuXG4gICAga2V5ID0gbW9kaWZpZXJzICsga2V5O1xuXG4gICAgaWYgKCB0aGlzLl9rZXlIYW5kbGVyc1sga2V5IF0gKSB7XG4gICAgICAgIHRoaXMuX2tleUhhbmRsZXJzWyBrZXkgXSggdGhpcywgZXZlbnQsIHJhbmdlICk7XG4gICAgLy8gIWV2ZW50LmlzQ29tcG9zaW5nIHN0b3BzIHVzIGZyb20gYmxhdHRpbmcgS2FuYS1LYW5qaSBjb252ZXJzaW9uIGluIFNhZmFyaVxuICAgIH0gZWxzZSBpZiAoICFyYW5nZS5jb2xsYXBzZWQgJiYgIWV2ZW50LmlzQ29tcG9zaW5nICYmXG4gICAgICAgICAgICAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgICAgICAgKCBldmVudC5rZXkgfHwga2V5ICkubGVuZ3RoID09PSAxICkge1xuICAgICAgICAvLyBSZWNvcmQgdW5kbyBjaGVja3BvaW50LlxuICAgICAgICB0aGlzLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGRlbGV0ZUNvbnRlbnRzT2ZSYW5nZSggcmFuZ2UsIHRoaXMuX3Jvb3QgKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlQm90dG9tTGluZSgpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcbiAgICB9XG59O1xuXG52YXIgbWFwS2V5VG8gPSBmdW5jdGlvbiAoIG1ldGhvZCApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBzZWxmLCBldmVudCApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZlsgbWV0aG9kIF0oKTtcbiAgICB9O1xufTtcblxudmFyIG1hcEtleVRvRm9ybWF0ID0gZnVuY3Rpb24gKCB0YWcsIHJlbW92ZSApIHtcbiAgICByZW1vdmUgPSByZW1vdmUgfHwgbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBzZWxmLCBldmVudCApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsZi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCBzZWxmLmhhc0Zvcm1hdCggdGFnLCBudWxsLCByYW5nZSApICkge1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VGb3JtYXQoIG51bGwsIHsgdGFnOiB0YWcgfSwgcmFuZ2UgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuY2hhbmdlRm9ybWF0KCB7IHRhZzogdGFnIH0sIHJlbW92ZSwgcmFuZ2UgKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBJZiB5b3UgZGVsZXRlIHRoZSBjb250ZW50IGluc2lkZSBhIHNwYW4gd2l0aCBhIGZvbnQgc3R5bGluZywgV2Via2l0IHdpbGxcbi8vIHJlcGxhY2UgaXQgd2l0aCBhIDxmb250PiB0YWcgKCEpLiBJZiB5b3UgZGVsZXRlIGFsbCB0aGUgdGV4dCBpbnNpZGUgYVxuLy8gbGluayBpbiBPcGVyYSwgaXQgd29uJ3QgZGVsZXRlIHRoZSBsaW5rLiBMZXQncyBtYWtlIHRoaW5ncyBjb25zaXN0ZW50LiBJZlxuLy8geW91IGRlbGV0ZSBhbGwgdGV4dCBpbnNpZGUgYW4gaW5saW5lIHRhZywgcmVtb3ZlIHRoZSBpbmxpbmUgdGFnLlxudmFyIGFmdGVyRGVsZXRlID0gZnVuY3Rpb24gKCBzZWxmLCByYW5nZSApIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoICFyYW5nZSApIHsgcmFuZ2UgPSBzZWxmLmdldFNlbGVjdGlvbigpOyB9XG4gICAgICAgIHZhciBub2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICBwYXJlbnQ7XG4gICAgICAgIC8vIENsaW1iIHRoZSB0cmVlIGZyb20gdGhlIGZvY3VzIHBvaW50IHdoaWxlIHdlIGFyZSBpbnNpZGUgYW4gZW1wdHlcbiAgICAgICAgLy8gaW5saW5lIGVsZW1lbnRcbiAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgIHdoaWxlICggaXNJbmxpbmUoIHBhcmVudCApICYmXG4gICAgICAgICAgICAgICAgKCAhcGFyZW50LnRleHRDb250ZW50IHx8IHBhcmVudC50ZXh0Q29udGVudCA9PT0gWldTICkgKSB7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGZvY3VzZWQgaW4gZW1wdHkgaW5saW5lIGVsZW1lbnRcbiAgICAgICAgaWYgKCBub2RlICE9PSBwYXJlbnQgKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGZvY3VzIHRvIGp1c3QgYmVmb3JlIGVtcHR5IGlubGluZShzKVxuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIHBhcmVudCxcbiAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwoIHBhcmVudC5jaGlsZE5vZGVzLCBub2RlICkgKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKCB0cnVlICk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZW1wdHkgaW5saW5lKHMpXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgICAgIC8vIEZpeCBjdXJzb3IgaW4gYmxvY2tcbiAgICAgICAgICAgIGlmICggIWlzQmxvY2soIHBhcmVudCApICkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGdldFByZXZpb3VzQmxvY2soIHBhcmVudCwgc2VsZi5fcm9vdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZml4Q3Vyc29yKCBwYXJlbnQsIHNlbGYuX3Jvb3QgKTtcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGludG8gdGV4dCBub2RlXG4gICAgICAgICAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzRG93blRyZWUoIHJhbmdlICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgeW91IGRlbGV0ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIHNvbGUgPGRpdj4gaW4gQ2hyb21lLFxuICAgICAgICAvLyBpdCByZW1vdmVzIHRoZSBkaXYgYW5kIHJlcGxhY2VzIGl0IHdpdGgganVzdCBhIDxicj4gaW5zaWRlIHRoZVxuICAgICAgICAvLyByb290LiBEZXRhY2ggdGhlIDxicj47IHRoZSBfZW5zdXJlQm90dG9tTGluZSBjYWxsIHdpbGwgaW5zZXJ0IGEgbmV3XG4gICAgICAgIC8vIGJsb2NrLlxuICAgICAgICBpZiAoIG5vZGUgPT09IHNlbGYuX3Jvb3QgJiZcbiAgICAgICAgICAgICAgICAoIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQgKSAmJiBub2RlLm5vZGVOYW1lID09PSAnQlInICkge1xuICAgICAgICAgICAgZGV0YWNoKCBub2RlICk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZW5zdXJlQm90dG9tTGluZSgpO1xuICAgICAgICBzZWxmLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgc2VsZi5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcbiAgICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgICAgIHNlbGYuZGlkRXJyb3IoIGVycm9yICk7XG4gICAgfVxufTtcblxudmFyIGtleUhhbmRsZXJzID0ge1xuICAgIGVudGVyOiBmdW5jdGlvbiAoIHNlbGYsIGV2ZW50LCByYW5nZSApIHtcbiAgICAgICAgdmFyIHJvb3QgPSBzZWxmLl9yb290O1xuICAgICAgICB2YXIgYmxvY2ssIHBhcmVudCwgbm9kZSwgb2Zmc2V0LCBub2RlQWZ0ZXJTcGxpdDtcblxuICAgICAgICAvLyBXZSBoYW5kbGUgdGhpcyBvdXJzZWx2ZXNcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBTYXZlIHVuZG8gY2hlY2twb2ludCBhbmQgYWRkIGFueSBsaW5rcyBpbiB0aGUgcHJlY2VkaW5nIHNlY3Rpb24uXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgendzIHNvIHdlIGRvbid0IHRoaW5rIHRoZXJlJ3MgY29udGVudCBpbiBhbiBlbXB0eVxuICAgICAgICAvLyBibG9jay5cbiAgICAgICAgc2VsZi5fcmVjb3JkVW5kb1N0YXRlKCByYW5nZSApO1xuICAgICAgICBhZGRMaW5rcyggcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJvb3QsIHNlbGYgKTtcbiAgICAgICAgc2VsZi5fcmVtb3ZlWldTKCk7XG4gICAgICAgIHNlbGYuX2dldFJhbmdlQW5kUmVtb3ZlQm9va21hcmsoIHJhbmdlICk7XG5cbiAgICAgICAgLy8gU2VsZWN0ZWQgdGV4dCBpcyBvdmVyd3JpdHRlbiwgdGhlcmVmb3JlIGRlbGV0ZSB0aGUgY29udGVudHNcbiAgICAgICAgLy8gdG8gY29sbGFwc2Ugc2VsZWN0aW9uLlxuICAgICAgICBpZiAoICFyYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgICAgICBkZWxldGVDb250ZW50c09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jayA9IGdldFN0YXJ0QmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuXG4gICAgICAgIC8vIEluc2lkZSBhIFBSRSwgaW5zZXJ0IGxpdGVyYWwgbmV3bGluZSwgdW5sZXNzIG9uIGJsYW5rIGxpbmUuXG4gICAgICAgIGlmICggYmxvY2sgJiYgKCBwYXJlbnQgPSBnZXROZWFyZXN0KCBibG9jaywgcm9vdCwgJ1BSRScgKSApICkge1xuICAgICAgICAgICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuICAgICAgICAgICAgbm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2VsZi5fZG9jLmNyZWF0ZVRleHROb2RlKCAnJyApO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoIG5vZGUsIHBhcmVudC5maXJzdENoaWxkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBibGFuayBsaW5lOiBzcGxpdCBhbmQgaW5zZXJ0IGRlZmF1bHQgYmxvY2tcbiAgICAgICAgICAgIGlmICggIWV2ZW50LnNoaWZ0S2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICggbm9kZS5kYXRhLmNoYXJBdCggb2Zmc2V0IC0gMSApID09PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VEb2VzU3RhcnRBdEJsb2NrQm91bmRhcnkoIHJhbmdlLCByb290ICkgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIG5vZGUuZGF0YS5jaGFyQXQoIG9mZnNldCApID09PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VEb2VzRW5kQXRCbG9ja0JvdW5kYXJ5KCByYW5nZSwgcm9vdCApICkgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kZWxldGVEYXRhKCBvZmZzZXQgJiYgb2Zmc2V0IC0gMSwgb2Zmc2V0ID8gMiA6IDEgKTtcbiAgICAgICAgICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0KCBub2RlLCBvZmZzZXQgJiYgb2Zmc2V0IC0gMSwgcm9vdCwgcm9vdCApO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlQWZ0ZXJTcGxpdC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKCAhbm9kZS50ZXh0Q29udGVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWNoKCBub2RlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBzZWxmLmNyZWF0ZURlZmF1bHRCbG9jaygpO1xuICAgICAgICAgICAgICAgIG5vZGVBZnRlclNwbGl0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBub2RlLCBub2RlQWZ0ZXJTcGxpdCApO1xuICAgICAgICAgICAgICAgIGlmICggIW5vZGVBZnRlclNwbGl0LnRleHRDb250ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBkZXRhY2goIG5vZGVBZnRlclNwbGl0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KCBub2RlLCAwICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0RGF0YSggb2Zmc2V0LCAnXFxuJyApO1xuICAgICAgICAgICAgICAgIGZpeEN1cnNvciggcGFyZW50LCByb290ICk7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBidWc6IGlmIHlvdSBzZXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdGV4dCBub2RlIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ldyBsaW5lLCBpdCBkcmF3cyB0aGUgY3Vyc29yIGJlZm9yZSB0aGUgbGluZSBicmVhayBzdGlsbFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpZiB5b3Ugc2V0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVxdWl2YWxlbnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcGFyZW50LCBpdCB3b3Jrcy5cbiAgICAgICAgICAgICAgICBpZiAoIG5vZGUubGVuZ3RoID09PSBvZmZzZXQgKyAxICkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKCBub2RlICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIG5vZGUsIG9mZnNldCArIDEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSggdHJ1ZSApO1xuICAgICAgICAgICAgc2VsZi5zZXRTZWxlY3Rpb24oIHJhbmdlICk7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuICAgICAgICAgICAgc2VsZi5fZG9jV2FzQ2hhbmdlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG1hbGZvcm1lZCBiaXQgb2YgZG9jdW1lbnQgb3IgaW4gYSB0YWJsZTtcbiAgICAgICAgLy8ganVzdCBwbGF5IGl0IHNhZmUgYW5kIGluc2VydCBhIDxicj4uXG4gICAgICAgIGlmICggIWJsb2NrIHx8IGV2ZW50LnNoaWZ0S2V5IHx8IC9eVFtIRF0kLy50ZXN0KCBibG9jay5ub2RlTmFtZSApICkge1xuICAgICAgICAgICAgLy8gSWYgaW5zaWRlIGFuIDxhPiwgbW92ZSBmb2N1cyBvdXRcbiAgICAgICAgICAgIHBhcmVudCA9IGdldE5lYXJlc3QoIHJhbmdlLmVuZENvbnRhaW5lciwgcm9vdCwgJ0EnICk7XG4gICAgICAgICAgICBpZiAoIHBhcmVudCApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzVXBUcmVlKCByYW5nZSwgcGFyZW50LCBwYXJlbnQsIHJvb3QgKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSggZmFsc2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydE5vZGVJblJhbmdlKCByYW5nZSwgc2VsZi5jcmVhdGVFbGVtZW50KCAnQlInICkgKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKCBmYWxzZSApO1xuICAgICAgICAgICAgc2VsZi5zZXRTZWxlY3Rpb24oIHJhbmdlICk7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaW4gYSBsaXN0LCB3ZSdsbCBzcGxpdCB0aGUgTEkgaW5zdGVhZC5cbiAgICAgICAgaWYgKCBwYXJlbnQgPSBnZXROZWFyZXN0KCBibG9jaywgcm9vdCwgJ0xJJyApICkge1xuICAgICAgICAgICAgYmxvY2sgPSBwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGlzRW1wdHlCbG9jayggYmxvY2sgKSApIHtcbiAgICAgICAgICAgIC8vIEJyZWFrIGxpc3RcbiAgICAgICAgICAgIGlmICggZ2V0TmVhcmVzdCggYmxvY2ssIHJvb3QsICdVTCcgKSB8fFxuICAgICAgICAgICAgICAgICAgICBnZXROZWFyZXN0KCBibG9jaywgcm9vdCwgJ09MJyApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlY3JlYXNlTGlzdExldmVsKCByYW5nZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnJlYWsgYmxvY2txdW90ZVxuICAgICAgICAgICAgZWxzZSBpZiAoIGdldE5lYXJlc3QoIGJsb2NrLCByb290LCAnQkxPQ0tRVU9URScgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5tb2RpZnlCbG9ja3MoIHJlbW92ZUJsb2NrUXVvdGUsIHJhbmdlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIHNwbGl0IGF0IGN1cnNvciBwb2ludC5cbiAgICAgICAgbm9kZUFmdGVyU3BsaXQgPSBzcGxpdEJsb2NrKCBzZWxmLCBibG9jayxcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCApO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBlbXB0eSBpbmxpbmVzIGlmIHdlIGhpdCBlbnRlciBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgICAgICAvLyBibG9ja1xuICAgICAgICByZW1vdmVaV1MoIGJsb2NrICk7XG4gICAgICAgIHJlbW92ZUVtcHR5SW5saW5lcyggYmxvY2sgKTtcbiAgICAgICAgZml4Q3Vyc29yKCBibG9jaywgcm9vdCApO1xuXG4gICAgICAgIC8vIEZvY3VzIGN1cnNvclxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgPGI+LzxpPiBldGMuIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwbGl0XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBmb2N1cyBpbnNpZGUgaXQuXG4gICAgICAgIHdoaWxlICggbm9kZUFmdGVyU3BsaXQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSApIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVBZnRlclNwbGl0LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV4dDtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbGlua3Mgb3ZlciBhIGJsb2NrIGJyZWFrOyB1bmxpa2VseSB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIGRlc2lyZWQgb3V0Y29tZS5cbiAgICAgICAgICAgIGlmICggbm9kZUFmdGVyU3BsaXQubm9kZU5hbWUgPT09ICdBJyAmJlxuICAgICAgICAgICAgICAgICAgICAoICFub2RlQWZ0ZXJTcGxpdC50ZXh0Q29udGVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUFmdGVyU3BsaXQudGV4dENvbnRlbnQgPT09IFpXUyApICkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gc2VsZi5fZG9jLmNyZWF0ZVRleHROb2RlKCAnJyApO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VXaXRoKCBub2RlQWZ0ZXJTcGxpdCwgY2hpbGQgKTtcbiAgICAgICAgICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoIGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUgJiYgIWNoaWxkLmRhdGEgKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmICggIW5leHQgfHwgbmV4dC5ub2RlTmFtZSA9PT0gJ0JSJyApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRldGFjaCggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICdCUidzIGVzc2VudGlhbGx5IGRvbid0IGNvdW50OyB0aGV5J3JlIGEgYnJvd3NlciBoYWNrLlxuICAgICAgICAgICAgLy8gSWYgeW91IHRyeSB0byBzZWxlY3QgdGhlIGNvbnRlbnRzIG9mIGEgJ0JSJywgRkYgd2lsbCBub3QgbGV0XG4gICAgICAgICAgICAvLyB5b3UgdHlwZSBhbnl0aGluZyFcbiAgICAgICAgICAgIGlmICggIWNoaWxkIHx8IGNoaWxkLm5vZGVOYW1lID09PSAnQlInIHx8XG4gICAgICAgICAgICAgICAgICAgICggY2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJiAhaXNQcmVzdG8gKSApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVBZnRlclNwbGl0ID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSBzZWxmLmNyZWF0ZVJhbmdlKCBub2RlQWZ0ZXJTcGxpdCwgMCApO1xuICAgICAgICBzZWxmLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgc2VsZi5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgJ3NoaWZ0LWVudGVyJzogZnVuY3Rpb24gKCBzZWxmLCBldmVudCwgcmFuZ2UgKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlIYW5kbGVycy5lbnRlciggc2VsZiwgZXZlbnQsIHJhbmdlICk7XG4gICAgfSxcblxuICAgIGJhY2tzcGFjZTogZnVuY3Rpb24gKCBzZWxmLCBldmVudCwgcmFuZ2UgKSB7XG4gICAgICAgIHZhciByb290ID0gc2VsZi5fcm9vdDtcbiAgICAgICAgc2VsZi5fcmVtb3ZlWldTKCk7XG4gICAgICAgIC8vIFJlY29yZCB1bmRvIGNoZWNrcG9pbnQuXG4gICAgICAgIHNlbGYuc2F2ZVVuZG9TdGF0ZSggcmFuZ2UgKTtcbiAgICAgICAgLy8gSWYgbm90IGNvbGxhcHNlZCwgZGVsZXRlIGNvbnRlbnRzXG4gICAgICAgIGlmICggIXJhbmdlLmNvbGxhcHNlZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkZWxldGVDb250ZW50c09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgICAgICAgICBhZnRlckRlbGV0ZSggc2VsZiwgcmFuZ2UgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhdCBiZWdpbm5pbmcgb2YgYmxvY2ssIG1lcmdlIHdpdGggcHJldmlvdXNcbiAgICAgICAgZWxzZSBpZiAoIHJhbmdlRG9lc1N0YXJ0QXRCbG9ja0JvdW5kYXJ5KCByYW5nZSwgcm9vdCApICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZ2V0U3RhcnRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoICFjdXJyZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGNhc2UgaW5saW5lIGRhdGEgaGFzIHNvbWVob3cgZ290IGJldHdlZW4gYmxvY2tzLlxuICAgICAgICAgICAgZml4Q29udGFpbmVyKCBjdXJyZW50LnBhcmVudE5vZGUsIHJvb3QgKTtcbiAgICAgICAgICAgIC8vIE5vdyBnZXQgcHJldmlvdXMgYmxvY2tcbiAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0UHJldmlvdXNCbG9jayggY3VycmVudCwgcm9vdCApO1xuICAgICAgICAgICAgLy8gTXVzdCBub3QgYmUgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IGFyZWEuXG4gICAgICAgICAgICBpZiAoIHByZXZpb3VzICkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBlZGl0YWJsZSwganVzdCBkZWxldGUgd2hvbGUgYmxvY2suXG4gICAgICAgICAgICAgICAgaWYgKCAhcHJldmlvdXMuaXNDb250ZW50RWRpdGFibGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFjaCggcHJldmlvdXMgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgbWVyZ2UuXG4gICAgICAgICAgICAgICAgbWVyZ2VXaXRoQmxvY2soIHByZXZpb3VzLCBjdXJyZW50LCByYW5nZSwgcm9vdCApO1xuICAgICAgICAgICAgICAgIC8vIElmIGRlbGV0ZWQgbGluZSBiZXR3ZWVuIGNvbnRhaW5lcnMsIG1lcmdlIG5ld2x5IGFkamFjZW50XG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVycy5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gcHJldmlvdXMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGN1cnJlbnQgIT09IHJvb3QgJiYgIWN1cnJlbnQubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggY3VycmVudCAhPT0gcm9vdCAmJiAoIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRTaWJsaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQ29udGFpbmVycyggY3VycmVudCwgcm9vdCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGF0IHZlcnkgYmVnaW5uaW5nIG9mIHRleHQgYXJlYSwgYWxsb3cgYmFja3NwYWNlXG4gICAgICAgICAgICAvLyB0byBicmVhayBsaXN0cy9ibG9ja3F1b3RlLlxuICAgICAgICAgICAgZWxzZSBpZiAoIGN1cnJlbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgbGlzdFxuICAgICAgICAgICAgICAgIGlmICggZ2V0TmVhcmVzdCggY3VycmVudCwgcm9vdCwgJ1VMJyApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXROZWFyZXN0KCBjdXJyZW50LCByb290LCAnT0wnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlY3JlYXNlTGlzdExldmVsKCByYW5nZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCcmVhayBibG9ja3F1b3RlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGdldE5lYXJlc3QoIGN1cnJlbnQsIHJvb3QsICdCTE9DS1FVT1RFJyApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5tb2RpZnlCbG9ja3MoIGRlY3JlYXNlQmxvY2tRdW90ZUxldmVsLCByYW5nZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmUgdG8gYnJvd3NlciBidXQgY2hlY2sgYWZ0ZXJ3YXJkcyB3aGV0aGVyIGl0IGhhc1xuICAgICAgICAvLyBsZWZ0IGJlaGluZCBhbiBlbXB0eSBpbmxpbmUgdGFnLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkgeyBhZnRlckRlbGV0ZSggc2VsZiApOyB9LCAwICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdkZWxldGUnOiBmdW5jdGlvbiAoIHNlbGYsIGV2ZW50LCByYW5nZSApIHtcbiAgICAgICAgdmFyIHJvb3QgPSBzZWxmLl9yb290O1xuICAgICAgICB2YXIgY3VycmVudCwgbmV4dCwgb3JpZ2luYWxSYW5nZSxcbiAgICAgICAgICAgIGN1cnNvckNvbnRhaW5lciwgY3Vyc29yT2Zmc2V0LCBub2RlQWZ0ZXJDdXJzb3I7XG4gICAgICAgIHNlbGYuX3JlbW92ZVpXUygpO1xuICAgICAgICAvLyBSZWNvcmQgdW5kbyBjaGVja3BvaW50LlxuICAgICAgICBzZWxmLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG4gICAgICAgIC8vIElmIG5vdCBjb2xsYXBzZWQsIGRlbGV0ZSBjb250ZW50c1xuICAgICAgICBpZiAoICFyYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZGVsZXRlQ29udGVudHNPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuICAgICAgICAgICAgYWZ0ZXJEZWxldGUoIHNlbGYsIHJhbmdlICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXQgZW5kIG9mIGJsb2NrLCBtZXJnZSBuZXh0IGludG8gdGhpcyBibG9ja1xuICAgICAgICBlbHNlIGlmICggcmFuZ2VEb2VzRW5kQXRCbG9ja0JvdW5kYXJ5KCByYW5nZSwgcm9vdCApICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgICAgIGlmICggIWN1cnJlbnQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gY2FzZSBpbmxpbmUgZGF0YSBoYXMgc29tZWhvdyBnb3QgYmV0d2VlbiBibG9ja3MuXG4gICAgICAgICAgICBmaXhDb250YWluZXIoIGN1cnJlbnQucGFyZW50Tm9kZSwgcm9vdCApO1xuICAgICAgICAgICAgLy8gTm93IGdldCBuZXh0IGJsb2NrXG4gICAgICAgICAgICBuZXh0ID0gZ2V0TmV4dEJsb2NrKCBjdXJyZW50LCByb290ICk7XG4gICAgICAgICAgICAvLyBNdXN0IG5vdCBiZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIHRleHQgYXJlYS5cbiAgICAgICAgICAgIGlmICggbmV4dCApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgZWRpdGFibGUsIGp1c3QgZGVsZXRlIHdob2xlIGJsb2NrLlxuICAgICAgICAgICAgICAgIGlmICggIW5leHQuaXNDb250ZW50RWRpdGFibGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFjaCggbmV4dCApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBtZXJnZS5cbiAgICAgICAgICAgICAgICBtZXJnZVdpdGhCbG9jayggY3VycmVudCwgbmV4dCwgcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBkZWxldGVkIGxpbmUgYmV0d2VlbiBjb250YWluZXJzLCBtZXJnZSBuZXdseSBhZGphY2VudFxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lcnMuXG4gICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIG5leHQgIT09IHJvb3QgJiYgIW5leHQubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggbmV4dCAhPT0gcm9vdCAmJiAoIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQ29udGFpbmVycyggbmV4dCwgcm9vdCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmUgdG8gYnJvd3NlciBidXQgY2hlY2sgYWZ0ZXJ3YXJkcyB3aGV0aGVyIGl0IGhhc1xuICAgICAgICAvLyBsZWZ0IGJlaGluZCBhbiBlbXB0eSBpbmxpbmUgdGFnLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCBjaGVjayBpZiB0aGUgY3Vyc29yIGlzIGp1c3QgYmVmb3JlIGFuIElNRyB0YWcuIElmIHNvLFxuICAgICAgICAgICAgLy8gZGVsZXRlIGl0IG91cnNlbHZlcywgYmVjYXVzZSB0aGUgYnJvd3NlciB3b24ndCBpZiBpdCBpcyBub3RcbiAgICAgICAgICAgIC8vIGlubGluZS5cbiAgICAgICAgICAgIG9yaWdpbmFsUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzVXBUcmVlKCByYW5nZSwgcm9vdCwgcm9vdCwgcm9vdCApO1xuICAgICAgICAgICAgY3Vyc29yQ29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgY3Vyc29yT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCBjdXJzb3JDb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICBub2RlQWZ0ZXJDdXJzb3IgPSBjdXJzb3JDb250YWluZXIuY2hpbGROb2Rlc1sgY3Vyc29yT2Zmc2V0IF07XG4gICAgICAgICAgICAgICAgaWYgKCBub2RlQWZ0ZXJDdXJzb3IgJiYgbm9kZUFmdGVyQ3Vyc29yLm5vZGVOYW1lID09PSAnSU1HJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWNoKCBub2RlQWZ0ZXJDdXJzb3IgKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuICAgICAgICAgICAgICAgICAgICBhZnRlckRlbGV0ZSggc2VsZiwgcmFuZ2UgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKCBvcmlnaW5hbFJhbmdlICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7IGFmdGVyRGVsZXRlKCBzZWxmICk7IH0sIDAgKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFiOiBmdW5jdGlvbiAoIHNlbGYsIGV2ZW50LCByYW5nZSApIHtcbiAgICAgICAgdmFyIHJvb3QgPSBzZWxmLl9yb290O1xuICAgICAgICB2YXIgbm9kZSwgcGFyZW50O1xuICAgICAgICBzZWxmLl9yZW1vdmVaV1MoKTtcbiAgICAgICAgLy8gSWYgbm8gc2VsZWN0aW9uIGFuZCBhdCBzdGFydCBvZiBibG9ja1xuICAgICAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCAmJiByYW5nZURvZXNTdGFydEF0QmxvY2tCb3VuZGFyeSggcmFuZ2UsIHJvb3QgKSApIHtcbiAgICAgICAgICAgIG5vZGUgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgYmxvY2sncyBwYXJlbnRzXG4gICAgICAgICAgICB3aGlsZSAoICggcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlICkgKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIFVMIG9yIE9MIChzbyBhcmUgaW4gYSBsaXN0LCBub2RlIG11c3QgYmUgYW4gTEkpXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQubm9kZU5hbWUgPT09ICdVTCcgfHwgcGFyZW50Lm5vZGVOYW1lID09PSAnT0wnICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIGluY3JlYXNlIHRoZSBsaXN0IGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5jcmVhc2VMaXN0TGV2ZWwoIHJhbmdlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAnc2hpZnQtdGFiJzogZnVuY3Rpb24gKCBzZWxmLCBldmVudCwgcmFuZ2UgKSB7XG4gICAgICAgIHZhciByb290ID0gc2VsZi5fcm9vdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHNlbGYuX3JlbW92ZVpXUygpO1xuICAgICAgICAvLyBJZiBubyBzZWxlY3Rpb24gYW5kIGF0IHN0YXJ0IG9mIGJsb2NrXG4gICAgICAgIGlmICggcmFuZ2UuY29sbGFwc2VkICYmIHJhbmdlRG9lc1N0YXJ0QXRCbG9ja0JvdW5kYXJ5KCByYW5nZSwgcm9vdCApICkge1xuICAgICAgICAgICAgLy8gQnJlYWsgbGlzdFxuICAgICAgICAgICAgbm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKCBnZXROZWFyZXN0KCBub2RlLCByb290LCAnVUwnICkgfHxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TmVhcmVzdCggbm9kZSwgcm9vdCwgJ09MJyApICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kZWNyZWFzZUxpc3RMZXZlbCggcmFuZ2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3BhY2U6IGZ1bmN0aW9uICggc2VsZiwgXywgcmFuZ2UgKSB7XG4gICAgICAgIHZhciBub2RlLCBwYXJlbnQ7XG4gICAgICAgIHZhciByb290ID0gc2VsZi5fcm9vdDtcbiAgICAgICAgc2VsZi5fcmVjb3JkVW5kb1N0YXRlKCByYW5nZSApO1xuICAgICAgICBhZGRMaW5rcyggcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJvb3QsIHNlbGYgKTtcbiAgICAgICAgc2VsZi5fZ2V0UmFuZ2VBbmRSZW1vdmVCb29rbWFyayggcmFuZ2UgKTtcblxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSBsaW5rICg8YT5mb298PC9hPikgdGhlbiBtb3ZlIGl0XG4gICAgICAgIC8vIG91dHNpZGUgb2YgdGhlIGxpbmsgKDxhPmZvbzwvYT58KSBzbyB0aGF0IHRoZSBzcGFjZSBpcyBub3QgcGFydCBvZlxuICAgICAgICAvLyB0aGUgbGluayB0ZXh0LlxuICAgICAgICBub2RlID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCAmJiByYW5nZS5lbmRPZmZzZXQgPT09IGdldExlbmd0aCggbm9kZSApICkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICggbm9kZS5ub2RlTmFtZSA9PT0gJ0EnICkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKCBub2RlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKCAhbm9kZS5uZXh0U2libGluZyAmJlxuICAgICAgICAgICAgICAgICggbm9kZSA9IG5vZGUucGFyZW50Tm9kZSApICYmIG5vZGUgIT09IHJvb3QgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgdGhlIHNlbGVjdGlvbiBpZiBub3QgY29sbGFwc2VkXG4gICAgICAgIGlmICggIXJhbmdlLmNvbGxhcHNlZCApIHtcbiAgICAgICAgICAgIGRlbGV0ZUNvbnRlbnRzT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgICAgIHNlbGYuX2Vuc3VyZUJvdHRvbUxpbmUoKTtcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIH0sXG4gICAgbGVmdDogZnVuY3Rpb24gKCBzZWxmICkge1xuICAgICAgICBzZWxmLl9yZW1vdmVaV1MoKTtcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbiAoIHNlbGYgKSB7XG4gICAgICAgIHNlbGYuX3JlbW92ZVpXUygpO1xuICAgIH1cbn07XG5cbi8vIEZpcmVmb3ggcHJlIHYyOSBpbmNvcnJlY3RseSBoYW5kbGVzIENtZC1sZWZ0L0NtZC1yaWdodCBvbiBNYWM6XG4vLyBpdCBnb2VzIGJhY2svZm9yd2FyZCBpbiBoaXN0b3J5ISBPdmVycmlkZSB0byBkbyB0aGUgcmlnaHRcbi8vIHRoaW5nLlxuLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjg5Mzg0XG5pZiAoIGlzTWFjICYmIGlzR2Vja28gKSB7XG4gICAga2V5SGFuZGxlcnNbICdtZXRhLWxlZnQnIF0gPSBmdW5jdGlvbiAoIHNlbGYsIGV2ZW50ICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgc2VsID0gZ2V0V2luZG93U2VsZWN0aW9uKCBzZWxmICk7XG4gICAgICAgIGlmICggc2VsICYmIHNlbC5tb2RpZnkgKSB7XG4gICAgICAgICAgICBzZWwubW9kaWZ5KCAnbW92ZScsICdiYWNrd2FyZCcsICdsaW5lYm91bmRhcnknICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGtleUhhbmRsZXJzWyAnbWV0YS1yaWdodCcgXSA9IGZ1bmN0aW9uICggc2VsZiwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBzZWwgPSBnZXRXaW5kb3dTZWxlY3Rpb24oIHNlbGYgKTtcbiAgICAgICAgaWYgKCBzZWwgJiYgc2VsLm1vZGlmeSApIHtcbiAgICAgICAgICAgIHNlbC5tb2RpZnkoICdtb3ZlJywgJ2ZvcndhcmQnLCAnbGluZWJvdW5kYXJ5JyApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gU3lzdGVtIHN0YW5kYXJkIGZvciBwYWdlIHVwL2Rvd24gb24gTWFjIGlzIHRvIGp1c3Qgc2Nyb2xsLCBub3QgbW92ZSB0aGVcbi8vIGN1cnNvci4gT24gTGludXgvV2luZG93cywgaXQgc2hvdWxkIG1vdmUgdGhlIGN1cnNvciwgYnV0IHNvbWUgYnJvd3NlcnMgZG9uJ3Rcbi8vIGltcGxlbWVudCB0aGlzIG5hdGl2ZWx5LiBPdmVycmlkZSB0byBzdXBwb3J0IGl0LlxuaWYgKCAhaXNNYWMgKSB7XG4gICAga2V5SGFuZGxlcnMucGFnZXVwID0gZnVuY3Rpb24gKCBzZWxmICkge1xuICAgICAgICBzZWxmLm1vdmVDdXJzb3JUb1N0YXJ0KCk7XG4gICAgfTtcbiAgICBrZXlIYW5kbGVycy5wYWdlZG93biA9IGZ1bmN0aW9uICggc2VsZiApIHtcbiAgICAgICAgc2VsZi5tb3ZlQ3Vyc29yVG9FbmQoKTtcbiAgICB9O1xufVxuXG5rZXlIYW5kbGVyc1sgY3RybEtleSArICdiJyBdID0gbWFwS2V5VG9Gb3JtYXQoICdCJyApO1xua2V5SGFuZGxlcnNbIGN0cmxLZXkgKyAnaScgXSA9IG1hcEtleVRvRm9ybWF0KCAnSScgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ3UnIF0gPSBtYXBLZXlUb0Zvcm1hdCggJ1UnICk7XG5rZXlIYW5kbGVyc1sgY3RybEtleSArICdzaGlmdC03JyBdID0gbWFwS2V5VG9Gb3JtYXQoICdTJyApO1xua2V5SGFuZGxlcnNbIGN0cmxLZXkgKyAnc2hpZnQtNScgXSA9IG1hcEtleVRvRm9ybWF0KCAnU1VCJywgeyB0YWc6ICdTVVAnIH0gKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ3NoaWZ0LTYnIF0gPSBtYXBLZXlUb0Zvcm1hdCggJ1NVUCcsIHsgdGFnOiAnU1VCJyB9ICk7XG5rZXlIYW5kbGVyc1sgY3RybEtleSArICdzaGlmdC04JyBdID0gbWFwS2V5VG8oICdtYWtlVW5vcmRlcmVkTGlzdCcgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ3NoaWZ0LTknIF0gPSBtYXBLZXlUbyggJ21ha2VPcmRlcmVkTGlzdCcgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ1snIF0gPSBtYXBLZXlUbyggJ2RlY3JlYXNlUXVvdGVMZXZlbCcgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ10nIF0gPSBtYXBLZXlUbyggJ2luY3JlYXNlUXVvdGVMZXZlbCcgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ2QnIF0gPSBtYXBLZXlUbyggJ3RvZ2dsZUNvZGUnICk7XG5rZXlIYW5kbGVyc1sgY3RybEtleSArICd5JyBdID0gbWFwS2V5VG8oICdyZWRvJyApO1xua2V5SGFuZGxlcnNbIGN0cmxLZXkgKyAneicgXSA9IG1hcEtleVRvKCAndW5kbycgKTtcbmtleUhhbmRsZXJzWyBjdHJsS2V5ICsgJ3NoaWZ0LXonIF0gPSBtYXBLZXlUbyggJ3JlZG8nICk7XG5cbnZhciBmb250U2l6ZXMgPSB7XG4gICAgMTogMTAsXG4gICAgMjogMTMsXG4gICAgMzogMTYsXG4gICAgNDogMTgsXG4gICAgNTogMjQsXG4gICAgNjogMzIsXG4gICAgNzogNDhcbn07XG5cbnZhciBzdHlsZVRvU2VtYW50aWMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHJlZ2V4cDogbm90V1MsXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uICggZG9jLCBjbGFzc05hbWVzLCBjb2xvdXIgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggZG9jLCAnU1BBTicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc05hbWVzLmhpZ2hsaWdodCxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2JhY2tncm91bmQtY29sb3I6JyArIGNvbG91clxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICAgIHJlZ2V4cDogbm90V1MsXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uICggZG9jLCBjbGFzc05hbWVzLCBjb2xvdXIgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggZG9jLCAnU1BBTicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc05hbWVzLmNvbG91cixcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOicgKyBjb2xvdXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiB7XG4gICAgICAgIHJlZ2V4cDogL15ib2xkfF43MDAvaSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKCBkb2MgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggZG9jLCAnQicgKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZm9udFN0eWxlOiB7XG4gICAgICAgIHJlZ2V4cDogL15pdGFsaWMvaSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKCBkb2MgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggZG9jLCAnSScgKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZm9udEZhbWlseToge1xuICAgICAgICByZWdleHA6IG5vdFdTLFxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoIGRvYywgY2xhc3NOYW1lcywgZmFtaWx5ICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoIGRvYywgJ1NQQU4nLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3NOYW1lcy5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1mYW1pbHk6JyArIGZhbWlseVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvbnRTaXplOiB7XG4gICAgICAgIHJlZ2V4cDogbm90V1MsXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uICggZG9jLCBjbGFzc05hbWVzLCBzaXplICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoIGRvYywgJ1NQQU4nLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3NOYW1lcy5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtc2l6ZTonICsgc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICAgIHJlZ2V4cDogL151bmRlcmxpbmUvaSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKCBkb2MgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggZG9jLCAnVScgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciByZXBsYWNlV2l0aFRhZyA9IGZ1bmN0aW9uICggdGFnICkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoIG5vZGUsIHBhcmVudCApIHtcbiAgICAgICAgdmFyIGVsID0gY3JlYXRlRWxlbWVudCggbm9kZS5vd25lckRvY3VtZW50LCB0YWcgKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCggZWwsIG5vZGUgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoIGVtcHR5KCBub2RlICkgKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG59O1xuXG52YXIgcmVwbGFjZVN0eWxlcyA9IGZ1bmN0aW9uICggbm9kZSwgcGFyZW50LCBjb25maWcgKSB7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHZhciBhdHRyLCBjb252ZXJ0ZXIsIGNzcywgbmV3VHJlZUJvdHRvbSwgbmV3VHJlZVRvcCwgZWw7XG5cbiAgICBmb3IgKCBhdHRyIGluIHN0eWxlVG9TZW1hbnRpYyApIHtcbiAgICAgICAgY29udmVydGVyID0gc3R5bGVUb1NlbWFudGljWyBhdHRyIF07XG4gICAgICAgIGNzcyA9IHN0eWxlWyBhdHRyIF07XG4gICAgICAgIGlmICggY3NzICYmIGNvbnZlcnRlci5yZWdleHAudGVzdCggY3NzICkgKSB7XG4gICAgICAgICAgICBlbCA9IGNvbnZlcnRlci5yZXBsYWNlKCBkb2MsIGNvbmZpZy5jbGFzc05hbWVzLCBjc3MgKTtcbiAgICAgICAgICAgIGlmICggIW5ld1RyZWVUb3AgKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJlZVRvcCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBuZXdUcmVlQm90dG9tICkge1xuICAgICAgICAgICAgICAgIG5ld1RyZWVCb3R0b20uYXBwZW5kQ2hpbGQoIGVsICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUcmVlQm90dG9tID0gZWw7XG4gICAgICAgICAgICBub2RlLnN0eWxlWyBhdHRyIF0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggbmV3VHJlZVRvcCApIHtcbiAgICAgICAgbmV3VHJlZUJvdHRvbS5hcHBlbmRDaGlsZCggZW1wdHkoIG5vZGUgKSApO1xuICAgICAgICBpZiAoIG5vZGUubm9kZU5hbWUgPT09ICdTUEFOJyApIHtcbiAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoIG5ld1RyZWVUb3AsIG5vZGUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoIG5ld1RyZWVUb3AgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdUcmVlQm90dG9tIHx8IG5vZGU7XG59O1xuXG52YXIgc3R5bGVzUmV3cml0ZXJzID0ge1xuICAgIFA6IHJlcGxhY2VTdHlsZXMsXG4gICAgU1BBTjogcmVwbGFjZVN0eWxlcyxcbiAgICBTVFJPTkc6IHJlcGxhY2VXaXRoVGFnKCAnQicgKSxcbiAgICBFTTogcmVwbGFjZVdpdGhUYWcoICdJJyApLFxuICAgIElOUzogcmVwbGFjZVdpdGhUYWcoICdVJyApLFxuICAgIFNUUklLRTogcmVwbGFjZVdpdGhUYWcoICdTJyApLFxuICAgIEZPTlQ6IGZ1bmN0aW9uICggbm9kZSwgcGFyZW50LCBjb25maWcgKSB7XG4gICAgICAgIHZhciBmYWNlID0gbm9kZS5mYWNlO1xuICAgICAgICB2YXIgc2l6ZSA9IG5vZGUuc2l6ZTtcbiAgICAgICAgdmFyIGNvbG91ciA9IG5vZGUuY29sb3I7XG4gICAgICAgIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gY29uZmlnLmNsYXNzTmFtZXM7XG4gICAgICAgIHZhciBmb250U3Bhbiwgc2l6ZVNwYW4sIGNvbG91clNwYW47XG4gICAgICAgIHZhciBuZXdUcmVlQm90dG9tLCBuZXdUcmVlVG9wO1xuICAgICAgICBpZiAoIGZhY2UgKSB7XG4gICAgICAgICAgICBmb250U3BhbiA9IGNyZWF0ZUVsZW1lbnQoIGRvYywgJ1NQQU4nLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3NOYW1lcy5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1mYW1pbHk6JyArIGZhY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3VHJlZVRvcCA9IGZvbnRTcGFuO1xuICAgICAgICAgICAgbmV3VHJlZUJvdHRvbSA9IGZvbnRTcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICggc2l6ZSApIHtcbiAgICAgICAgICAgIHNpemVTcGFuID0gY3JlYXRlRWxlbWVudCggZG9jLCAnU1BBTicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc05hbWVzLmZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1zaXplOicgKyBmb250U2l6ZXNbIHNpemUgXSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCAhbmV3VHJlZVRvcCApIHtcbiAgICAgICAgICAgICAgICBuZXdUcmVlVG9wID0gc2l6ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG5ld1RyZWVCb3R0b20gKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJlZUJvdHRvbS5hcHBlbmRDaGlsZCggc2l6ZVNwYW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1RyZWVCb3R0b20gPSBzaXplU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGNvbG91ciAmJiAvXiM/KFtcXGRBLUZdezN9KXsxLDJ9JC9pLnRlc3QoIGNvbG91ciApICkge1xuICAgICAgICAgICAgaWYgKCBjb2xvdXIuY2hhckF0KCAwICkgIT09ICcjJyApIHtcbiAgICAgICAgICAgICAgICBjb2xvdXIgPSAnIycgKyBjb2xvdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xvdXJTcGFuID0gY3JlYXRlRWxlbWVudCggZG9jLCAnU1BBTicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc05hbWVzLmNvbG91cixcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOicgKyBjb2xvdXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCAhbmV3VHJlZVRvcCApIHtcbiAgICAgICAgICAgICAgICBuZXdUcmVlVG9wID0gY29sb3VyU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggbmV3VHJlZUJvdHRvbSApIHtcbiAgICAgICAgICAgICAgICBuZXdUcmVlQm90dG9tLmFwcGVuZENoaWxkKCBjb2xvdXJTcGFuICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUcmVlQm90dG9tID0gY29sb3VyU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICFuZXdUcmVlVG9wICkge1xuICAgICAgICAgICAgbmV3VHJlZVRvcCA9IG5ld1RyZWVCb3R0b20gPSBjcmVhdGVFbGVtZW50KCBkb2MsICdTUEFOJyApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoIG5ld1RyZWVUb3AsIG5vZGUgKTtcbiAgICAgICAgbmV3VHJlZUJvdHRvbS5hcHBlbmRDaGlsZCggZW1wdHkoIG5vZGUgKSApO1xuICAgICAgICByZXR1cm4gbmV3VHJlZUJvdHRvbTtcbiAgICB9LFxuICAgIFRUOiBmdW5jdGlvbiAoIG5vZGUsIHBhcmVudCwgY29uZmlnICkge1xuICAgICAgICB2YXIgZWwgPSBjcmVhdGVFbGVtZW50KCBub2RlLm93bmVyRG9jdW1lbnQsICdTUEFOJywge1xuICAgICAgICAgICAgJ2NsYXNzJzogY29uZmlnLmNsYXNzTmFtZXMuZm9udEZhbWlseSxcbiAgICAgICAgICAgIHN0eWxlOiAnZm9udC1mYW1pbHk6bWVubG8sY29uc29sYXMsXCJjb3VyaWVyIG5ld1wiLG1vbm9zcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsLCBub2RlICk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKCBlbXB0eSggbm9kZSApICk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59O1xuXG52YXIgYWxsb3dlZEJsb2NrID0gL14oPzpBKD86RERSRVNTfFJUSUNMRXxTSURFfFVESU8pfEJMT0NLUVVPVEV8Q0FQVElPTnxEKD86W0RMVF18SVYpfEYoPzpJR1VSRXxJR0NBUFRJT058T09URVIpfEhbMS02XXxIRUFERVJ8TCg/OkFCRUx8RUdFTkR8SSl8Tyg/Okx8VVRQVVQpfFAoPzpSRSk/fFNFQ1RJT058VCg/OkFCTEV8Qk9EWXxEfEZPT1R8SHxIRUFEfFIpfENPTCg/OkdST1VQKT98VUwpJC87XG5cbnZhciBibGFja2xpc3QgPSAvXig/OkhFQUR8TUVUQXxTVFlMRSkvO1xuXG52YXIgd2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoIG51bGwsIFNIT1dfVEVYVHxTSE9XX0VMRU1FTlQgKTtcblxuLypcbiAgICBUd28gcHVycG9zZXM6XG5cbiAgICAxLiBSZW1vdmUgbm9kZXMgd2UgZG9uJ3Qgd2FudCwgc3VjaCBhcyB3ZWlyZCA8bzpwPiB0YWdzLCBjb21tZW50IG5vZGVzXG4gICAgICAgYW5kIHdoaXRlc3BhY2Ugbm9kZXMuXG4gICAgMi4gQ29udmVydCBpbmxpbmUgdGFncyBpbnRvIG91ciBwcmVmZXJyZWQgZm9ybWF0LlxuKi9cbnZhciBjbGVhblRyZWUgPSBmdW5jdGlvbiBjbGVhblRyZWUgKCBub2RlLCBjb25maWcsIHByZXNlcnZlV1MgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICBub25JbmxpbmVQYXJlbnQsIGksIGwsIGNoaWxkLCBub2RlTmFtZSwgbm9kZVR5cGUsIHJld3JpdGVyLCBjaGlsZExlbmd0aCxcbiAgICAgICAgc3RhcnRzV2l0aFdTLCBlbmRzV2l0aFdTLCBkYXRhLCBzaWJsaW5nO1xuXG4gICAgbm9uSW5saW5lUGFyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAoIGlzSW5saW5lKCBub25JbmxpbmVQYXJlbnQgKSApIHtcbiAgICAgICAgbm9uSW5saW5lUGFyZW50ID0gbm9uSW5saW5lUGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdhbGtlci5yb290ID0gbm9uSW5saW5lUGFyZW50O1xuXG4gICAgZm9yICggaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICs9IDEgKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIG5vZGVOYW1lID0gY2hpbGQubm9kZU5hbWU7XG4gICAgICAgIG5vZGVUeXBlID0gY2hpbGQubm9kZVR5cGU7XG4gICAgICAgIHJld3JpdGVyID0gc3R5bGVzUmV3cml0ZXJzWyBub2RlTmFtZSBdO1xuICAgICAgICBpZiAoIG5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgKSB7XG4gICAgICAgICAgICBjaGlsZExlbmd0aCA9IGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCByZXdyaXRlciApIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHJld3JpdGVyKCBjaGlsZCwgbm9kZSwgY29uZmlnICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBibGFja2xpc3QudGVzdCggbm9kZU5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICBsIC09IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhYWxsb3dlZEJsb2NrLnRlc3QoIG5vZGVOYW1lICkgJiYgIWlzSW5saW5lKCBjaGlsZCApICkge1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICBsICs9IGNoaWxkTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBub2RlLnJlcGxhY2VDaGlsZCggZW1wdHkoIGNoaWxkICksIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGNoaWxkTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIGNsZWFuVHJlZSggY2hpbGQsIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXUyB8fCAoIG5vZGVOYW1lID09PSAnUFJFJyApICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIG5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgICAgICAgICAgICAgc3RhcnRzV2l0aFdTID0gIW5vdFdTLnRlc3QoIGRhdGEuY2hhckF0KCAwICkgKTtcbiAgICAgICAgICAgICAgICBlbmRzV2l0aFdTID0gIW5vdFdTLnRlc3QoIGRhdGEuY2hhckF0KCBkYXRhLmxlbmd0aCAtIDEgKSApO1xuICAgICAgICAgICAgICAgIGlmICggcHJlc2VydmVXUyB8fCAoICFzdGFydHNXaXRoV1MgJiYgIWVuZHNXaXRoV1MgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbm9kZXM7IGlmIHdlIGhpdCBzb21lIG90aGVyIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgbmV3IGJsb2NrIHdlIGRvbid0IHRyaW1cbiAgICAgICAgICAgICAgICBpZiAoIHN0YXJ0c1dpdGhXUyApIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggc2libGluZyA9IHdhbGtlci5wcmV2aW91c1BPTm9kZSgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBzaWJsaW5nLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlTmFtZSA9PT0gJ0lNRycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBub2RlTmFtZSA9PT0gJyN0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90V1MudGVzdCggc2libGluZy5kYXRhICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWlzSW5saW5lKCBzaWJsaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSggL15bIFxcdFxcclxcbl0rL2csIHNpYmxpbmcgPyAnICcgOiAnJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGVuZHNXaXRoV1MgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHNpYmxpbmcgPSB3YWxrZXIubmV4dE5vZGUoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZU5hbWUgPT09ICdJTUcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbm9kZU5hbWUgPT09ICcjdGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdFdTLnRlc3QoIHNpYmxpbmcuZGF0YSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0lubGluZSggc2libGluZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoIC9bIFxcdFxcclxcbl0rJC9nLCBzaWJsaW5nID8gJyAnIDogJycgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCggY2hpbGQgKTtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIGwgLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8vIC0tLVxuXG52YXIgcmVtb3ZlRW1wdHlJbmxpbmVzID0gZnVuY3Rpb24gcmVtb3ZlRW1wdHlJbmxpbmVzICggbm9kZSApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgIGwgPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIGNoaWxkO1xuICAgIHdoaWxlICggbC0tICkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2xdO1xuICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgIWlzTGVhZiggY2hpbGQgKSApIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5SW5saW5lcyggY2hpbGQgKTtcbiAgICAgICAgICAgIGlmICggaXNJbmxpbmUoIGNoaWxkICkgJiYgIWNoaWxkLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCggY2hpbGQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggY2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJiAhY2hpbGQuZGF0YSApIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoIGNoaWxkICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyAtLS1cblxudmFyIG5vdFdTVGV4dE5vZGUgPSBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSA/XG4gICAgICAgIG5vZGUubm9kZU5hbWUgPT09ICdCUicgOlxuICAgICAgICBub3RXUy50ZXN0KCBub2RlLmRhdGEgKTtcbn07XG52YXIgaXNMaW5lQnJlYWsgPSBmdW5jdGlvbiAoIGJyLCBpc0xCSWZFbXB0eUJsb2NrICkge1xuICAgIHZhciBibG9jayA9IGJyLnBhcmVudE5vZGU7XG4gICAgdmFyIHdhbGtlcjtcbiAgICB3aGlsZSAoIGlzSW5saW5lKCBibG9jayApICkge1xuICAgICAgICBibG9jayA9IGJsb2NrLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKFxuICAgICAgICBibG9jaywgU0hPV19FTEVNRU5UfFNIT1dfVEVYVCwgbm90V1NUZXh0Tm9kZSApO1xuICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGJyO1xuICAgIHJldHVybiAhIXdhbGtlci5uZXh0Tm9kZSgpIHx8XG4gICAgICAgICggaXNMQklmRW1wdHlCbG9jayAmJiAhd2Fsa2VyLnByZXZpb3VzTm9kZSgpICk7XG59O1xuXG4vLyA8YnI+IGVsZW1lbnRzIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgYW5kIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGVcbi8vIGJyb3dzZXIsIHdoZW4gaW4gcmljaCB0ZXh0IGVkaXRvciBtb2RlLiBXaGVuIGFkZGluZyBIVE1MIGZyb20gZXh0ZXJuYWxcbi8vIHNvdXJjZXMsIHdlIG11c3QgcmVtb3ZlIHRoZW0sIHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IGFjdHVhbGx5IGFmZmVjdFxuLy8gbGluZSBicmVha3MgYnkgd3JhcHBpbmcgdGhlIGlubGluZSB0ZXh0IGluIGEgPGRpdj4uIEJyb3dzZXJzIHRoYXQgd2FudCA8YnI+XG4vLyBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIGVhY2ggYmxvY2sgd2lsbCB0aGVuIGhhdmUgdGhlbSBhZGRlZCBiYWNrIGluIGEgbGF0ZXJcbi8vIGZpeEN1cnNvciBtZXRob2QgY2FsbC5cbnZhciBjbGVhbnVwQlJzID0gZnVuY3Rpb24gKCBub2RlLCByb290LCBrZWVwRm9yQmxhbmtMaW5lICkge1xuICAgIHZhciBicnMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoICdCUicgKTtcbiAgICB2YXIgYnJCcmVha3NMaW5lID0gW107XG4gICAgdmFyIGwgPSBicnMubGVuZ3RoO1xuICAgIHZhciBpLCBiciwgcGFyZW50O1xuXG4gICAgLy8gTXVzdCBjYWxjdWxhdGUgd2hldGhlciB0aGUgPGJyPiBicmVha3MgYSBsaW5lIGZpcnN0LCBiZWNhdXNlIGlmIHdlXG4gICAgLy8gaGF2ZSB0d28gPGJyPnMgbmV4dCB0byBlYWNoIG90aGVyLCBhZnRlciB0aGUgZmlyc3Qgb25lIGlzIGNvbnZlcnRlZFxuICAgIC8vIHRvIGEgYmxvY2sgc3BsaXQsIHRoZSBzZWNvbmQgd2lsbCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgYW5kXG4gICAgLy8gdGhlcmVmb3JlIHNlZW0gdG8gbm90IGJlIGEgbGluZSBicmVhay4gQnV0IGluIGl0cyBvcmlnaW5hbCBjb250ZXh0IGl0XG4gICAgLy8gd2FzLCBzbyB3ZSBzaG91bGQgYWxzbyBjb252ZXJ0IGl0IHRvIGEgYmxvY2sgc3BsaXQuXG4gICAgZm9yICggaSA9IDA7IGkgPCBsOyBpICs9IDEgKSB7XG4gICAgICAgIGJyQnJlYWtzTGluZVtpXSA9IGlzTGluZUJyZWFrKCBicnNbaV0sIGtlZXBGb3JCbGFua0xpbmUgKTtcbiAgICB9XG4gICAgd2hpbGUgKCBsLS0gKSB7XG4gICAgICAgIGJyID0gYnJzW2xdO1xuICAgICAgICAvLyBDbGVhbnVwIG1heSBoYXZlIHJlbW92ZWQgaXRcbiAgICAgICAgcGFyZW50ID0gYnIucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCAhcGFyZW50ICkgeyBjb250aW51ZTsgfVxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGJyZWFrIGEgbGluZSwganVzdCByZW1vdmUgaXQ7IGl0J3Mgbm90IGRvaW5nXG4gICAgICAgIC8vIGFueXRoaW5nIHVzZWZ1bC4gV2UnbGwgYWRkIGl0IGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWQgYnkgdGhlXG4gICAgICAgIC8vIGJyb3dzZXIuIElmIGl0IGJyZWFrcyBhIGxpbmUsIHdyYXAgdGhlIGNvbnRlbnQgaW4gZGl2IHRhZ3NcbiAgICAgICAgLy8gYW5kIHJlcGxhY2UgdGhlIGJycy5cbiAgICAgICAgaWYgKCAhYnJCcmVha3NMaW5lW2xdICkge1xuICAgICAgICAgICAgZGV0YWNoKCBiciApO1xuICAgICAgICB9IGVsc2UgaWYgKCAhaXNJbmxpbmUoIHBhcmVudCApICkge1xuICAgICAgICAgICAgZml4Q29udGFpbmVyKCBwYXJlbnQsIHJvb3QgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFRoZSAobm9uLXN0YW5kYXJkIGJ1dCBzdXBwb3J0ZWQgZW5vdWdoKSBpbm5lclRleHQgcHJvcGVydHkgaXMgYmFzZWQgb24gdGhlXG4vLyByZW5kZXIgdHJlZSBpbiBGaXJlZm94IGFuZCBwb3NzaWJseSBvdGhlciBicm93c2Vycywgc28gd2UgbXVzdCBpbnNlcnQgdGhlXG4vLyBET00gbm9kZSBpbnRvIHRoZSBkb2N1bWVudCB0byBlbnN1cmUgdGhlIHRleHQgcGFydCBpcyBjb3JyZWN0LlxudmFyIHNldENsaXBib2FyZERhdGEgPSBmdW5jdGlvbiAoIGNsaXBib2FyZERhdGEsIG5vZGUsIHJvb3QsIGNvbmZpZyApIHtcbiAgICB2YXIgYm9keSA9IG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIHZhciB3aWxsQ3V0Q29weSA9IGNvbmZpZy53aWxsQ3V0Q29weTtcbiAgICB2YXIgaHRtbCwgdGV4dDtcblxuICAgIC8vIEZpcmVmb3ggd2lsbCBhZGQgYW4gZXh0cmEgbmV3IGxpbmUgZm9yIEJScyBhdCB0aGUgZW5kIG9mIGJsb2NrIHdoZW5cbiAgICAvLyBjYWxjdWxhdGluZyBpbm5lclRleHQsIGV2ZW4gdGhvdWdoIHRoZXkgZG9uJ3QgYWN0dWFsbHkgYWZmZWN0IGRpc3BsYXkuXG4gICAgLy8gU28gd2UgbmVlZCB0byByZW1vdmUgdGhlbSBmaXJzdC5cbiAgICBjbGVhbnVwQlJzKCBub2RlLCByb290LCB0cnVlICk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJyxcbiAgICAgICAgJ3Bvc2l0aW9uOmZpeGVkO292ZXJmbG93OmhpZGRlbjtib3R0b206MTAwJTtyaWdodDoxMDAlOycgKTtcbiAgICBib2R5LmFwcGVuZENoaWxkKCBub2RlICk7XG4gICAgaHRtbCA9IG5vZGUuaW5uZXJIVE1MO1xuICAgIHRleHQgPSBub2RlLmlubmVyVGV4dCB8fCBub2RlLnRleHRDb250ZW50O1xuXG4gICAgaWYgKCB3aWxsQ3V0Q29weSApIHtcbiAgICAgICAgaHRtbCA9IHdpbGxDdXRDb3B5KCBodG1sICk7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCAoYW5kIG90aGVycz8pIHJldHVybnMgdW5peCBsaW5lIGVuZGluZ3MgKFxcbikgZXZlbiBvbiBXaW5kb3dzLlxuICAgIC8vIElmIG9uIFdpbmRvd3MsIG5vcm1hbGlzZSB0byBcXHJcXG4sIHNpbmNlIE5vdGVwYWQgYW5kIHNvbWUgb3RoZXIgY3JhcHB5XG4gICAgLy8gYXBwcyBkbyBub3QgdW5kZXJzdGFuZCBqdXN0IFxcbi5cbiAgICBpZiAoIGlzV2luICkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKCAvXFxyP1xcbi9nLCAnXFxyXFxuJyApO1xuICAgIH1cblxuICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSggJ3RleHQvaHRtbCcsIGh0bWwgKTtcbiAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoICd0ZXh0L3BsYWluJywgdGV4dCApO1xuXG4gICAgYm9keS5yZW1vdmVDaGlsZCggbm9kZSApO1xufTtcblxudmFyIG9uQ3V0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydEJsb2NrLCBlbmRCbG9jaywgY29weVJvb3QsIGNvbnRlbnRzLCBwYXJlbnQsIG5ld0NvbnRlbnRzLCBub2RlO1xuXG4gICAgLy8gTm90aGluZyB0byBkb1xuICAgIGlmICggcmFuZ2UuY29sbGFwc2VkICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB1bmRvIGNoZWNrcG9pbnRcbiAgICB0aGlzLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG5cbiAgICAvLyBFZGdlIG9ubHkgc2VlbXMgdG8gc3VwcG9ydCBzZXR0aW5nIHBsYWluIHRleHQgYXMgb2YgMjAxNi0wMy0xMS5cbiAgICAvLyBNb2JpbGUgU2FmYXJpIGZsYXQgb3V0IGRvZXNuJ3Qgd29yazpcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQzNzc2XG4gICAgaWYgKCAhaXNFZGdlICYmICFpc0lPUyAmJiBjbGlwYm9hcmREYXRhICkge1xuICAgICAgICAvLyBDbGlwYm9hcmQgY29udGVudCBzaG91bGQgaW5jbHVkZSBhbGwgcGFyZW50cyB3aXRoaW4gYmxvY2ssIG9yIGFsbFxuICAgICAgICAvLyBwYXJlbnRzIHVwIHRvIHJvb3QgaWYgc2VsZWN0aW9uIGFjcm9zcyBibG9ja3NcbiAgICAgICAgc3RhcnRCbG9jayA9IGdldFN0YXJ0QmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuICAgICAgICBlbmRCbG9jayA9IGdldEVuZEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICAgICAgY29weVJvb3QgPSAoICggc3RhcnRCbG9jayA9PT0gZW5kQmxvY2sgKSAmJiBzdGFydEJsb2NrICkgfHwgcm9vdDtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29udGVudHNcbiAgICAgICAgY29udGVudHMgPSBkZWxldGVDb250ZW50c09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgICAgIC8vIEFkZCBhbnkgb3RoZXIgcGFyZW50cyBub3QgaW4gZXh0cmFjdGVkIGNvbnRlbnQsIHVwIHRvIGNvcHkgcm9vdFxuICAgICAgICBwYXJlbnQgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCBwYXJlbnQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICggcGFyZW50ICYmIHBhcmVudCAhPT0gY29weVJvb3QgKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50cyA9IHBhcmVudC5jbG9uZU5vZGUoIGZhbHNlICk7XG4gICAgICAgICAgICBuZXdDb250ZW50cy5hcHBlbmRDaGlsZCggY29udGVudHMgKTtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gbmV3Q29udGVudHM7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgY2xpcGJvYXJkIGRhdGFcbiAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCggY29udGVudHMgKTtcbiAgICAgICAgc2V0Q2xpcGJvYXJkRGF0YSggY2xpcGJvYXJkRGF0YSwgbm9kZSwgcm9vdCwgdGhpcy5fY29uZmlnICk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbGwgY29udGVudCByZW1vdmVkLCBlbnN1cmUgZGl2IGF0IHN0YXJ0IG9mIHJvb3QuXG4gICAgICAgICAgICAgICAgc2VsZi5fZW5zdXJlQm90dG9tTGluZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGlkRXJyb3IoIGVycm9yICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbn07XG5cbnZhciBvbkNvcHkgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgIHZhciBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgc3RhcnRCbG9jaywgZW5kQmxvY2ssIGNvcHlSb290LCBjb250ZW50cywgcGFyZW50LCBuZXdDb250ZW50cywgbm9kZTtcblxuICAgIC8vIEVkZ2Ugb25seSBzZWVtcyB0byBzdXBwb3J0IHNldHRpbmcgcGxhaW4gdGV4dCBhcyBvZiAyMDE2LTAzLTExLlxuICAgIC8vIE1vYmlsZSBTYWZhcmkgZmxhdCBvdXQgZG9lc24ndCB3b3JrOlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDM3NzZcbiAgICBpZiAoICFpc0VkZ2UgJiYgIWlzSU9TICYmIGNsaXBib2FyZERhdGEgKSB7XG4gICAgICAgIC8vIENsaXBib2FyZCBjb250ZW50IHNob3VsZCBpbmNsdWRlIGFsbCBwYXJlbnRzIHdpdGhpbiBibG9jaywgb3IgYWxsXG4gICAgICAgIC8vIHBhcmVudHMgdXAgdG8gcm9vdCBpZiBzZWxlY3Rpb24gYWNyb3NzIGJsb2Nrc1xuICAgICAgICBzdGFydEJsb2NrID0gZ2V0U3RhcnRCbG9ja09mUmFuZ2UoIHJhbmdlLCByb290ICk7XG4gICAgICAgIGVuZEJsb2NrID0gZ2V0RW5kQmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuICAgICAgICBjb3B5Um9vdCA9ICggKCBzdGFydEJsb2NrID09PSBlbmRCbG9jayApICYmIHN0YXJ0QmxvY2sgKSB8fCByb290O1xuICAgICAgICAvLyBDbG9uZSByYW5nZSB0byBtdXRhdGUsIHRoZW4gbW92ZSB1cCBhcyBoaWdoIGFzIHBvc3NpYmxlIHdpdGhvdXRcbiAgICAgICAgLy8gcGFzc2luZyB0aGUgY29weSByb290IG5vZGUuXG4gICAgICAgIHJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzRG93blRyZWUoIHJhbmdlICk7XG4gICAgICAgIG1vdmVSYW5nZUJvdW5kYXJpZXNVcFRyZWUoIHJhbmdlLCBjb3B5Um9vdCwgY29weVJvb3QsIHJvb3QgKTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29udGVudHNcbiAgICAgICAgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgIC8vIEFkZCBhbnkgb3RoZXIgcGFyZW50cyBub3QgaW4gZXh0cmFjdGVkIGNvbnRlbnQsIHVwIHRvIGNvcHkgcm9vdFxuICAgICAgICBwYXJlbnQgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCBwYXJlbnQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICggcGFyZW50ICYmIHBhcmVudCAhPT0gY29weVJvb3QgKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50cyA9IHBhcmVudC5jbG9uZU5vZGUoIGZhbHNlICk7XG4gICAgICAgICAgICBuZXdDb250ZW50cy5hcHBlbmRDaGlsZCggY29udGVudHMgKTtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gbmV3Q29udGVudHM7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgY2xpcGJvYXJkIGRhdGFcbiAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCggY29udGVudHMgKTtcbiAgICAgICAgc2V0Q2xpcGJvYXJkRGF0YSggY2xpcGJvYXJkRGF0YSwgbm9kZSwgcm9vdCwgdGhpcy5fY29uZmlnICk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLy8gTmVlZCB0byBtb25pdG9yIGZvciBzaGlmdCBrZXkgbGlrZSB0aGlzLCBhcyBldmVudC5zaGlmdEtleSBpcyBub3QgYXZhaWxhYmxlXG4vLyBpbiBwYXN0ZSBldmVudC5cbmZ1bmN0aW9uIG1vbml0b3JTaGlmdEtleSAoIGV2ZW50ICkge1xuICAgIHRoaXMuaXNTaGlmdERvd24gPSBldmVudC5zaGlmdEtleTtcbn1cblxudmFyIG9uUGFzdGUgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgIHZhciBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICB2YXIgaXRlbXMgPSBjbGlwYm9hcmREYXRhICYmIGNsaXBib2FyZERhdGEuaXRlbXM7XG4gICAgdmFyIGNob29zZVBsYWluID0gdGhpcy5pc1NoaWZ0RG93bjtcbiAgICB2YXIgZmlyZURyb3AgPSBmYWxzZTtcbiAgICB2YXIgaGFzUlRGID0gZmFsc2U7XG4gICAgdmFyIGhhc0ltYWdlID0gZmFsc2U7XG4gICAgdmFyIHBsYWluSXRlbSA9IG51bGw7XG4gICAgdmFyIGh0bWxJdGVtID0gbnVsbDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGwsIGl0ZW0sIHR5cGUsIHR5cGVzLCBkYXRhO1xuXG4gICAgLy8gQ3VycmVudCBIVE1MNSBDbGlwYm9hcmQgaW50ZXJmYWNlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbFxuICAgIGlmICggaXRlbXMgKSB7XG4gICAgICAgIGwgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbC0tICkge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2xdO1xuICAgICAgICAgICAgdHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgICAgIGlmICggdHlwZSA9PT0gJ3RleHQvaHRtbCcgKSB7XG4gICAgICAgICAgICAgICAgaHRtbEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgLy8gaU9TIGNvcHkgVVJMIGdpdmVzIHlvdSB0eXBlIHRleHQvdXJpLWxpc3Qgd2hpY2ggaXMganVzdCBhIGxpc3RcbiAgICAgICAgICAgIC8vIG9mIDEgb3IgbW9yZSBVUkxzIHNlcGFyYXRlZCBieSBuZXcgbGluZXMuIENhbiBqdXN0IHRyZWF0IGFzXG4gICAgICAgICAgICAvLyBwbGFpbiB0ZXh0LlxuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8IHR5cGUgPT09ICd0ZXh0L3VyaS1saXN0JyApIHtcbiAgICAgICAgICAgICAgICBwbGFpbkl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ3RleHQvcnRmJyApIHtcbiAgICAgICAgICAgICAgICBoYXNSVEYgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggL15pbWFnZVxcLy4qLy50ZXN0KCB0eXBlICkgKSB7XG4gICAgICAgICAgICAgICAgaGFzSW1hZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJlYXQgaW1hZ2UgcGFzdGUgYXMgYSBkcm9wIG9mIGFuIGltYWdlIGZpbGUuIFdoZW4geW91IGNvcHlcbiAgICAgICAgLy8gYW4gaW1hZ2UgaW4gQ2hyb21lL0ZpcmVmb3ggKGF0IGxlYXN0KSwgaXQgY29waWVzIHRoZSBpbWFnZSBkYXRhXG4gICAgICAgIC8vIGJ1dCBhbHNvIGFuIEhUTUwgdmVyc2lvbiAocmVmZXJlbmNpbmcgdGhlIG9yaWdpbmFsIFVSTCBvZiB0aGUgaW1hZ2UpXG4gICAgICAgIC8vIGFuZCBhIHBsYWluIHRleHQgdmVyc2lvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgd2hlbiB5b3UgY29weSBpbiBFeGNlbCwgeW91IGdldCBodG1sLCBydGYsIHRleHQsIGltYWdlO1xuICAgICAgICAvLyBpbiB0aGlzIGluc3RhbmNlIHlvdSB3YW50IHRoZSBodG1sIHZlcnNpb24hIFNvIGxldCdzIHRyeSB1c2luZ1xuICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgdGV4dC9ydGYgYXMgYW4gaW5kaWNhdG9yIHRvIGNob29zZSB0aGUgaHRtbCB2ZXJzaW9uXG4gICAgICAgIC8vIG92ZXIgdGhlIGltYWdlLlxuICAgICAgICBpZiAoIGhhc0ltYWdlICYmICEoIGhhc1JURiAmJiBodG1sSXRlbSApICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCAnZHJhZ292ZXInLCB7XG4gICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBjbGlwYm9hcmREYXRhLFxuICAgICAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZURyb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzogZmFsc2UgKi9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCBmaXJlRHJvcCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFdmVudCggJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogY2xpcGJvYXJkRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWRnZSBvbmx5IHByb3ZpZGVzIGFjY2VzcyB0byBwbGFpbiB0ZXh0IGFzIG9mIDIwMTYtMDMtMTEgYW5kIGdpdmVzIG5vXG4gICAgICAgIC8vIGluZGljYXRpb24gdGhlcmUgc2hvdWxkIGJlIGFuIEhUTUwgcGFydC4gSG93ZXZlciwgaXQgZG9lcyBzdXBwb3J0XG4gICAgICAgIC8vIGFjY2VzcyB0byBpbWFnZSBkYXRhLCBzbyB3ZSBjaGVjayBmb3IgdGhhdCBmaXJzdC4gT3RoZXJ3aXNlIHRob3VnaCxcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIGZhbGxiYWNrIGNsaXBib2FyZCBoYW5kbGluZyBtZXRob2RzXG4gICAgICAgIGlmICggIWlzRWRnZSApIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoIGh0bWxJdGVtICYmICggIWNob29zZVBsYWluIHx8ICFwbGFpbkl0ZW0gKSApIHtcbiAgICAgICAgICAgICAgICBodG1sSXRlbS5nZXRBc1N0cmluZyggZnVuY3Rpb24gKCBodG1sICkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluc2VydEhUTUwoIGh0bWwsIHRydWUgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBsYWluSXRlbSApIHtcbiAgICAgICAgICAgICAgICBwbGFpbkl0ZW0uZ2V0QXNTdHJpbmcoIGZ1bmN0aW9uICggdGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnRQbGFpblRleHQoIHRleHQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9sZCBpbnRlcmZhY2VcbiAgICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBTYWZhcmkgKGFuZCBpbmRlZWQgbWFueSBvdGhlciBPUyBYIGFwcHMpIGNvcGllcyBzdHVmZiBhcyB0ZXh0L3J0ZlxuICAgIC8vIHJhdGhlciB0aGFuIHRleHQvaHRtbDsgZXZlbiBmcm9tIGEgd2VicGFnZSBpbiBTYWZhcmkuIFRoZSBvbmx5IHdheVxuICAgIC8vIHRvIGdldCBhbiBIVE1MIHZlcnNpb24gaXMgdG8gZmFsbGJhY2sgdG8gbGV0dGluZyB0aGUgYnJvd3NlciBpbnNlcnRcbiAgICAvLyB0aGUgY29udGVudC4gU2FtZSBmb3IgZ2V0dGluZyBpbWFnZSBkYXRhLiAqU2lnaCouXG4gICAgLy9cbiAgICAvLyBGaXJlZm94IGlzIGV2ZW4gd29yc2U6IGl0IGRvZXNuJ3QgZXZlbiBsZXQgeW91IGtub3cgdGhhdCB0aGVyZSBtaWdodCBiZVxuICAgIC8vIGFuIFJURiB2ZXJzaW9uIG9uIHRoZSBjbGlwYm9hcmQsIGJ1dCBpdCB3aWxsIGFsc28gY29udmVydCB0byBIVE1MIGlmIHlvdVxuICAgIC8vIGxldCB0aGUgYnJvd3NlciBpbnNlcnQgdGhlIGNvbnRlbnQuIEkndmUgZmlsZWRcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjU0MDI4XG4gICAgdHlwZXMgPSBjbGlwYm9hcmREYXRhICYmIGNsaXBib2FyZERhdGEudHlwZXM7XG4gICAgaWYgKCAhaXNFZGdlICYmIHR5cGVzICYmIChcbiAgICAgICAgICAgIGluZGV4T2YuY2FsbCggdHlwZXMsICd0ZXh0L2h0bWwnICkgPiAtMSB8fCAoXG4gICAgICAgICAgICAgICAgIWlzR2Vja28gJiZcbiAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwoIHR5cGVzLCAndGV4dC9wbGFpbicgKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKCB0eXBlcywgJ3RleHQvcnRmJyApIDwgMCApXG4gICAgICAgICAgICApKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEFiaXdvcmQgb24gTGludXggY29waWVzIGEgcGxhaW4gdGV4dCBhbmQgaHRtbCB2ZXJzaW9uLCBidXQgdGhlIEhUTUxcbiAgICAgICAgLy8gdmVyc2lvbiBpcyB0aGUgZW1wdHkgc3RyaW5nISBTbyBhbHdheXMgdHJ5IHRvIGdldCBIVE1MLCBidXQgaWYgbm9uZSxcbiAgICAgICAgLy8gaW5zZXJ0IHBsYWluIHRleHQgaW5zdGVhZC4gT24gaU9TLCBGYWNlYm9vayAoYW5kIHBvc3NpYmx5IG90aGVyXG4gICAgICAgIC8vIGFwcHM/KSBjb3B5IGxpbmtzIGFzIHR5cGUgdGV4dC91cmktbGlzdCwgYnV0IGFsc28gaW5zZXJ0IGEgKipibGFuayoqXG4gICAgICAgIC8vIHRleHQvcGxhaW4gaXRlbSBvbnRvIHRoZSBjbGlwYm9hcmQuIFdoeT8gV2hvIGtub3dzLlxuICAgICAgICBpZiAoICFjaG9vc2VQbGFpbiAmJiAoIGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoICd0ZXh0L2h0bWwnICkgKSApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0SFRNTCggZGF0YSwgdHJ1ZSApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICggZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YSggJ3RleHQvcGxhaW4nICkgKSB8fFxuICAgICAgICAgICAgICAgICggZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YSggJ3RleHQvdXJpLWxpc3QnICkgKSApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0UGxhaW5UZXh0KCBkYXRhLCB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vIGludGVyZmFjZS4gSW5jbHVkZXMgYWxsIHZlcnNpb25zIG9mIElFIDooXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRoaXMuX2F3YWl0aW5nUGFzdGUgPSB0cnVlO1xuXG4gICAgdmFyIGJvZHkgPSB0aGlzLl9kb2MuYm9keSxcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgICBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIsXG4gICAgICAgIGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcblxuICAgIC8vIFdlIG5lZWQgdG8gcG9zaXRpb24gdGhlIHBhc3RlQXJlYSBpbiB0aGUgdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBzY3JlZW5cbiAgICAvLyB0byBzdG9wIHRoZSBicm93c2VyIGF1dG8tc2Nyb2xsaW5nLlxuICAgIHZhciBwYXN0ZUFyZWEgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoICdESVYnLCB7XG4gICAgICAgIGNvbnRlbnRlZGl0YWJsZTogJ3RydWUnLFxuICAgICAgICBzdHlsZTogJ3Bvc2l0aW9uOmZpeGVkOyBvdmVyZmxvdzpoaWRkZW47IHRvcDowOyByaWdodDoxMDAlOyB3aWR0aDoxcHg7IGhlaWdodDoxcHg7J1xuICAgIH0pO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQoIHBhc3RlQXJlYSApO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyggcGFzdGVBcmVhICk7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb24oIHJhbmdlICk7XG5cbiAgICAvLyBBIHNldFRpbWVvdXQgb2YgMCBtZWFucyB0aGlzIGlzIGFkZGVkIHRvIHRoZSBiYWNrIG9mIHRoZVxuICAgIC8vIHNpbmdsZSBqYXZhc2NyaXB0IHRocmVhZCwgc28gaXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGVcbiAgICAvLyBwYXN0ZSBldmVudC5cbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJRSBzb21ldGltZXMgZmlyZXMgdGhlIGJlZm9yZXBhc3RlIGV2ZW50IHR3aWNlOyBtYWtlIHN1cmUgaXQgaXNcbiAgICAgICAgICAgIC8vIG5vdCBydW4gYWdhaW4gYmVmb3JlIG91ciBhZnRlciBwYXN0ZSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAgICAgICAgICBzZWxmLl9hd2FpdGluZ1Bhc3RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFzdGVkIGNvbnRlbnQgYW5kIGNsZWFuXG4gICAgICAgICAgICB2YXIgaHRtbCA9ICcnLFxuICAgICAgICAgICAgICAgIG5leHQgPSBwYXN0ZUFyZWEsXG4gICAgICAgICAgICAgICAgZmlyc3QsIHJhbmdlO1xuXG4gICAgICAgICAgICAvLyAjODg6IENocm9tZSBjYW4gYXBwYXJlbnRseSBzcGxpdCB0aGUgcGFzdGUgYXJlYSBpZiBjZXJ0YWluXG4gICAgICAgICAgICAvLyBjb250ZW50IGlzIGluc2VydGVkOyBnYXRoZXIgdGhlbSBhbGwgdXAuXG4gICAgICAgICAgICB3aGlsZSAoIHBhc3RlQXJlYSA9IG5leHQgKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHBhc3RlQXJlYS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBkZXRhY2goIHBhc3RlQXJlYSApO1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBhbmQgSUUgbGlrZSBwdXR0aW5nIGV4dHJhIGRpdnMgYXJvdW5kIHRoaW5ncy5cbiAgICAgICAgICAgICAgICBmaXJzdCA9IHBhc3RlQXJlYS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICggZmlyc3QgJiYgZmlyc3QgPT09IHBhc3RlQXJlYS5sYXN0Q2hpbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Lm5vZGVOYW1lID09PSAnRElWJyApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVBcmVhID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcGFzdGVBcmVhLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuZ2UgPSBzZWxmLmNyZWF0ZVJhbmdlKFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgKTtcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuXG4gICAgICAgICAgICBpZiAoIGh0bWwgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnRIVE1MKCBodG1sLCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgICAgIHNlbGYuZGlkRXJyb3IoIGVycm9yICk7XG4gICAgICAgIH1cbiAgICB9LCAwICk7XG59O1xuXG4vLyBPbiBXaW5kb3dzIHlvdSBjYW4gZHJhZyBhbiBkcm9wIHRleHQuIFdlIGNhbid0IGhhbmRsZSB0aGlzIG91cnNlbHZlcywgYmVjYXVzZVxuLy8gYXMgZmFyIGFzIEkgY2FuIHNlZSwgdGhlcmUncyBubyB3YXkgdG8gZ2V0IHRoZSBkcm9wIGluc2VydGlvbiBwb2ludC4gU28ganVzdFxuLy8gc2F2ZSBhbiB1bmRvIHN0YXRlIGFuZCBob3BlIGZvciB0aGUgYmVzdC5cbnZhciBvbkRyb3AgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgIHZhciB0eXBlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci50eXBlcztcbiAgICB2YXIgbCA9IHR5cGVzLmxlbmd0aDtcbiAgICB2YXIgaGFzUGxhaW4gPSBmYWxzZTtcbiAgICB2YXIgaGFzSFRNTCA9IGZhbHNlO1xuICAgIHdoaWxlICggbC0tICkge1xuICAgICAgICBzd2l0Y2ggKCB0eXBlc1tsXSApIHtcbiAgICAgICAgY2FzZSAndGV4dC9wbGFpbic6XG4gICAgICAgICAgICBoYXNQbGFpbiA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGV4dC9odG1sJzpcbiAgICAgICAgICAgIGhhc0hUTUwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCBoYXNIVE1MIHx8IGhhc1BsYWluICkge1xuICAgICAgICB0aGlzLnNhdmVVbmRvU3RhdGUoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMgKCBiYXNlLCBleHRyYXMsIG1heU92ZXJyaWRlICkge1xuICAgIHZhciBwcm9wLCB2YWx1ZTtcbiAgICBpZiAoICFiYXNlICkge1xuICAgICAgICBiYXNlID0ge307XG4gICAgfVxuICAgIGlmICggZXh0cmFzICkge1xuICAgICAgICBmb3IgKCBwcm9wIGluIGV4dHJhcyApIHtcbiAgICAgICAgICAgIGlmICggbWF5T3ZlcnJpZGUgfHwgISggcHJvcCBpbiBiYXNlICkgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBleHRyYXNbIHByb3AgXTtcbiAgICAgICAgICAgICAgICBiYXNlWyBwcm9wIF0gPSAoIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgKSA/XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlT2JqZWN0cyggYmFzZVsgcHJvcCBdLCB2YWx1ZSwgbWF5T3ZlcnJpZGUgKSA6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5mdW5jdGlvbiBTcXVpcmUgKCByb290LCBjb25maWcgKSB7XG4gICAgaWYgKCByb290Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFICkge1xuICAgICAgICByb290ID0gcm9vdC5ib2R5O1xuICAgIH1cbiAgICB2YXIgZG9jID0gcm9vdC5vd25lckRvY3VtZW50O1xuICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgdmFyIG11dGF0aW9uO1xuXG4gICAgdGhpcy5fd2luID0gd2luO1xuICAgIHRoaXMuX2RvYyA9IGRvYztcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcblxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IG51bGw7XG5cbiAgICAvLyBJRSBsb3NlcyBzZWxlY3Rpb24gc3RhdGUgb2YgaWZyYW1lIG9uIGJsdXIsIHNvIG1ha2Ugc3VyZSB3ZVxuICAgIC8vIGNhY2hlIGl0IGp1c3QgYmVmb3JlIGl0IGxvc2VzIGZvY3VzLlxuICAgIGlmICggbG9zZXNTZWxlY3Rpb25PbkJsdXIgKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2JlZm9yZWRlYWN0aXZhdGUnLCB0aGlzLmdldFNlbGVjdGlvbiApO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc1pXUyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fbGFzdEFuY2hvck5vZGUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RGb2N1c05vZGUgPSBudWxsO1xuICAgIHRoaXMuX3BhdGggPSAnJztcbiAgICB0aGlzLl93aWxsVXBkYXRlUGF0aCA9IGZhbHNlO1xuXG4gICAgaWYgKCAnb25zZWxlY3Rpb25jaGFuZ2UnIGluIGRvYyApIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCAnc2VsZWN0aW9uY2hhbmdlJywgdGhpcy5fdXBkYXRlUGF0aE9uRXZlbnQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIHRoaXMuX3VwZGF0ZVBhdGhPbkV2ZW50ICk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCB0aGlzLl91cGRhdGVQYXRoT25FdmVudCApO1xuICAgIH1cblxuICAgIHRoaXMuX3VuZG9JbmRleCA9IC0xO1xuICAgIHRoaXMuX3VuZG9TdGFjayA9IFtdO1xuICAgIHRoaXMuX3VuZG9TdGFja0xlbmd0aCA9IDA7XG4gICAgdGhpcy5faXNJblVuZG9TdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2lnbm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuX2lnbm9yZUFsbENoYW5nZXMgPSBmYWxzZTtcblxuICAgIGlmICggY2FuT2JzZXJ2ZU11dGF0aW9ucyApIHtcbiAgICAgICAgbXV0YXRpb24gPSBuZXcgTXV0YXRpb25PYnNlcnZlciggdGhpcy5fZG9jV2FzQ2hhbmdlZC5iaW5kKCB0aGlzICkgKTtcbiAgICAgICAgbXV0YXRpb24ub2JzZXJ2ZSggcm9vdCwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5fa2V5VXBEZXRlY3RDaGFuZ2UgKTtcbiAgICB9XG5cbiAgICAvLyBPbiBibHVyLCByZXN0b3JlIGZvY3VzIGV4Y2VwdCBpZiB0aGUgdXNlciB0YXBzIG9yIGNsaWNrcyB0byBmb2N1cyBhXG4gICAgLy8gc3BlY2lmaWMgcG9pbnQuIENhbid0IGFjdHVhbGx5IHVzZSBjbGljayBldmVudCBiZWNhdXNlIGZvY3VzIGhhcHBlbnNcbiAgICAvLyBiZWZvcmUgY2xpY2ssIHNvIHVzZSBtb3VzZWRvd24vdG91Y2hzdGFydFxuICAgIHRoaXMuX3Jlc3RvcmVTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgZW5hYmxlUmVzdG9yZVNlbGVjdGlvbiApO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIGRpc2FibGVSZXN0b3JlU2VsZWN0aW9uICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIGRpc2FibGVSZXN0b3JlU2VsZWN0aW9uICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCByZXN0b3JlU2VsZWN0aW9uICk7XG5cbiAgICAvLyBJRSBzb21ldGltZXMgZmlyZXMgdGhlIGJlZm9yZXBhc3RlIGV2ZW50IHR3aWNlOyBtYWtlIHN1cmUgaXQgaXMgbm90IHJ1blxuICAgIC8vIGFnYWluIGJlZm9yZSBvdXIgYWZ0ZXIgcGFzdGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgIHRoaXMuX2F3YWl0aW5nUGFzdGUgPSBmYWxzZTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGlzSUVsdDExID8gJ2JlZm9yZWN1dCcgOiAnY3V0Jywgb25DdXQgKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoICdjb3B5Jywgb25Db3B5ICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG1vbml0b3JTaGlmdEtleSApO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgbW9uaXRvclNoaWZ0S2V5ICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCBpc0lFbHQxMSA/ICdiZWZvcmVwYXN0ZScgOiAncGFzdGUnLCBvblBhc3RlICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCAnZHJvcCcsIG9uRHJvcCApO1xuXG4gICAgLy8gT3BlcmEgZG9lcyBub3QgZmlyZSBrZXlkb3duIHJlcGVhdGVkbHkuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCBpc1ByZXN0byA/ICdrZXlwcmVzcycgOiAna2V5ZG93bicsIG9uS2V5ICk7XG5cbiAgICAvLyBBZGQga2V5IGhhbmRsZXJzXG4gICAgdGhpcy5fa2V5SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKCBrZXlIYW5kbGVycyApO1xuXG4gICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5zZXRDb25maWcoIGNvbmZpZyApO1xuXG4gICAgLy8gRml4IElFPDEwJ3MgYnVnZ3kgaW1wbGVtZW50YXRpb24gb2YgVGV4dCNzcGxpdFRleHQuXG4gICAgLy8gSWYgdGhlIHNwbGl0IGlzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUsIGl0IGRvZXNuJ3QgaW5zZXJ0IHRoZSBuZXdseSBzcGxpdFxuICAgIC8vIG5vZGUgaW50byB0aGUgZG9jdW1lbnQsIGFuZCBzZXRzIGl0cyB2YWx1ZSB0byB1bmRlZmluZWQgcmF0aGVyIHRoYW4gJycuXG4gICAgLy8gQW5kIGV2ZW4gaWYgdGhlIHNwbGl0IGlzIG5vdCBhdCB0aGUgZW5kLCB0aGUgb3JpZ2luYWwgbm9kZSBpcyByZW1vdmVkXG4gICAgLy8gZnJvbSB0aGUgZG9jdW1lbnQgYW5kIHJlcGxhY2VkIGJ5IGFub3RoZXIsIHJhdGhlciB0aGFuIGp1c3QgaGF2aW5nIGl0c1xuICAgIC8vIGRhdGEgc2hvcnRlbmVkLlxuICAgIC8vIFdlIHVzZWQgdG8gZmVhdHVyZSB0ZXN0IGZvciB0aGlzLCBidXQgdGhlbiBmb3VuZCB0aGUgZmVhdHVyZSB0ZXN0IHdvdWxkXG4gICAgLy8gc29tZXRpbWVzIHBhc3MsIGJ1dCBsYXRlciBvbiB0aGUgYnVnZ3kgYmVoYXZpb3VyIHdvdWxkIHN0aWxsIGFwcGVhci5cbiAgICAvLyBJIHRoaW5rIElFMTAgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBidWcsIGJ1dCBpdCBkb2Vzbid0IGh1cnQgdG8gcmVwbGFjZVxuICAgIC8vIGl0cyBuYXRpdmUgZm4gdG9vIGFuZCB0aGVuIHdlIGRvbid0IG5lZWQgeWV0IGFub3RoZXIgVUEgY2F0ZWdvcnkuXG4gICAgaWYgKCBpc0lFbHQxMSApIHtcbiAgICAgICAgd2luLlRleHQucHJvdG90eXBlLnNwbGl0VGV4dCA9IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuICAgICAgICAgICAgdmFyIGFmdGVyU3BsaXQgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zbGljZSggb2Zmc2V0ICkgKSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdG9EZWxldGUgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmICggbmV4dCApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBhZnRlclNwbGl0LCBuZXh0ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCggYWZ0ZXJTcGxpdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB0b0RlbGV0ZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZURhdGEoIG9mZnNldCwgdG9EZWxldGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZnRlclNwbGl0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJvb3Quc2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJywgJ3RydWUnICk7XG5cbiAgICAvLyBSZW1vdmUgRmlyZWZveCdzIGJ1aWx0LWluIGNvbnRyb2xzXG4gICAgdHJ5IHtcbiAgICAgICAgZG9jLmV4ZWNDb21tYW5kKCAnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgJ2ZhbHNlJyApO1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoICdlbmFibGVJbmxpbmVUYWJsZUVkaXRpbmcnLCBmYWxzZSwgJ2ZhbHNlJyApO1xuICAgIH0gY2F0Y2ggKCBlcnJvciApIHt9XG5cbiAgICByb290Ll9fc3F1aXJlX18gPSB0aGlzO1xuXG4gICAgLy8gTmVlZCB0byByZWdpc3RlciBpbnN0YW5jZSBiZWZvcmUgY2FsbGluZyBzZXRIVE1MLCBzbyB0aGF0IHRoZSBmaXhDdXJzb3JcbiAgICAvLyBmdW5jdGlvbiBjYW4gbG9va3VwIGFueSBkZWZhdWx0IGJsb2NrIHRhZyBvcHRpb25zIHNldC5cbiAgICB0aGlzLnNldEhUTUwoICcnICk7XG59XG5cbnZhciBwcm90byA9IFNxdWlyZS5wcm90b3R5cGU7XG5cbnZhciBzYW5pdGl6ZVRvRE9NRnJhZ21lbnQgPSBmdW5jdGlvbiAoIGh0bWwsIGlzUGFzdGUsIHNlbGYgKSB7XG4gICAgdmFyIGRvYyA9IHNlbGYuX2RvYztcbiAgICB2YXIgZnJhZyA9IGh0bWwgPyBET01QdXJpZnkuc2FuaXRpemUoIGh0bWwsIHtcbiAgICAgICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFM6IHRydWUsXG4gICAgICAgIFdIT0xFX0RPQ1VNRU5UOiBmYWxzZSxcbiAgICAgICAgUkVUVVJOX0RPTTogdHJ1ZSxcbiAgICAgICAgUkVUVVJOX0RPTV9GUkFHTUVOVDogdHJ1ZVxuICAgIH0pIDogbnVsbDtcbiAgICByZXR1cm4gZnJhZyA/IGRvYy5pbXBvcnROb2RlKCBmcmFnLCB0cnVlICkgOiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufTtcblxucHJvdG8uc2V0Q29uZmlnID0gZnVuY3Rpb24gKCBjb25maWcgKSB7XG4gICAgY29uZmlnID0gbWVyZ2VPYmplY3RzKHtcbiAgICAgICAgYmxvY2tUYWc6ICdESVYnLFxuICAgICAgICBibG9ja0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgIHRhZ0F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGJsb2NrcXVvdGU6IG51bGwsXG4gICAgICAgICAgICB1bDogbnVsbCxcbiAgICAgICAgICAgIG9sOiBudWxsLFxuICAgICAgICAgICAgbGk6IG51bGwsXG4gICAgICAgICAgICBhOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICAgIGNvbG91cjogJ2NvbG91cicsXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnZm9udCcsXG4gICAgICAgICAgICBmb250U2l6ZTogJ3NpemUnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0OiAnaGlnaGxpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBsZWFmTm9kZU5hbWVzOiBsZWFmTm9kZU5hbWVzLFxuICAgICAgICB1bmRvOiB7XG4gICAgICAgICAgICBkb2N1bWVudFNpemVUaHJlc2hvbGQ6IC0xLCAvLyAtMSBtZWFucyBubyB0aHJlc2hvbGRcbiAgICAgICAgICAgIHVuZG9MaW1pdDogLTEgLy8gLTEgbWVhbnMgbm8gbGltaXRcbiAgICAgICAgfSxcbiAgICAgICAgaXNJbnNlcnRlZEhUTUxTYW5pdGl6ZWQ6IHRydWUsXG4gICAgICAgIGlzU2V0SFRNTFNhbml0aXplZDogdHJ1ZSxcbiAgICAgICAgc2FuaXRpemVUb0RPTUZyYWdtZW50OlxuICAgICAgICAgICAgdHlwZW9mIERPTVB1cmlmeSAhPT0gJ3VuZGVmaW5lZCcgJiYgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID9cbiAgICAgICAgICAgIHNhbml0aXplVG9ET01GcmFnbWVudCA6IG51bGwsXG4gICAgICAgIHdpbGxDdXRDb3B5OiBudWxsXG4gICAgfSwgY29uZmlnLCB0cnVlICk7XG5cbiAgICAvLyBVc2VycyBtYXkgc3BlY2lmeSBibG9jayB0YWcgaW4gbG93ZXIgY2FzZVxuICAgIGNvbmZpZy5ibG9ja1RhZyA9IGNvbmZpZy5ibG9ja1RhZy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCB0YWcsIHByb3BzLCBjaGlsZHJlbiApIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCggdGhpcy5fZG9jLCB0YWcsIHByb3BzLCBjaGlsZHJlbiApO1xufTtcblxucHJvdG8uY3JlYXRlRGVmYXVsdEJsb2NrID0gZnVuY3Rpb24gKCBjaGlsZHJlbiApIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiBmaXhDdXJzb3IoXG4gICAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCggY29uZmlnLmJsb2NrVGFnLCBjb25maWcuYmxvY2tBdHRyaWJ1dGVzLCBjaGlsZHJlbiApLFxuICAgICAgICB0aGlzLl9yb290XG4gICAgKTtcbn07XG5cbnByb3RvLmRpZEVycm9yID0gZnVuY3Rpb24gKCBlcnJvciApIHtcbiAgICBjb25zb2xlLmxvZyggZXJyb3IgKTtcbn07XG5cbnByb3RvLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kb2M7XG59O1xucHJvdG8uZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbn07XG5cbnByb3RvLm1vZGlmeURvY3VtZW50ID0gZnVuY3Rpb24gKCBtb2RpZmljYXRpb25DYWxsYmFjayApIHtcbiAgICB2YXIgbXV0YXRpb24gPSB0aGlzLl9tdXRhdGlvbjtcbiAgICBpZiAoIG11dGF0aW9uICkge1xuICAgICAgICBpZiAoIG11dGF0aW9uLnRha2VSZWNvcmRzKCkubGVuZ3RoICkge1xuICAgICAgICAgICAgdGhpcy5fZG9jV2FzQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pZ25vcmVBbGxDaGFuZ2VzID0gdHJ1ZTtcbiAgICBtb2RpZmljYXRpb25DYWxsYmFjaygpO1xuICAgIHRoaXMuX2lnbm9yZUFsbENoYW5nZXMgPSBmYWxzZTtcblxuICAgIGlmICggbXV0YXRpb24gKSB7XG4gICAgICAgIG11dGF0aW9uLm9ic2VydmUoIHRoaXMuX3Jvb3QsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faWdub3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gLS0tIEV2ZW50cyAtLS1cblxuLy8gU3Vic2NyaWJpbmcgdG8gdGhlc2UgZXZlbnRzIHdvbid0IGF1dG9tYXRpY2FsbHkgYWRkIGEgbGlzdGVuZXIgdG8gdGhlXG4vLyBkb2N1bWVudCBub2RlLCBzaW5jZSB0aGVzZSBldmVudHMgYXJlIGZpcmVkIGluIGEgY3VzdG9tIG1hbm5lciBieSB0aGVcbi8vIGVkaXRvciBjb2RlLlxudmFyIGN1c3RvbUV2ZW50cyA9IHtcbiAgICBwYXRoQ2hhbmdlOiAxLCBzZWxlY3Q6IDEsIGlucHV0OiAxLCB1bmRvU3RhdGVDaGFuZ2U6IDFcbn07XG5cbnByb3RvLmZpcmVFdmVudCA9IGZ1bmN0aW9uICggdHlwZSwgZXZlbnQgKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzWyB0eXBlIF07XG4gICAgdmFyIGlzRm9jdXNlZCwgbCwgb2JqO1xuICAgIC8vIFVJIGNvZGUsIGVzcGVjaWFsbHkgbW9kYWwgdmlld3MsIG1heSBiZSBtb25pdG9yaW5nIGZvciBmb2N1cyBldmVudHMgYW5kXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVtb3ZpbmcgZm9jdXMuIEluIGNlcnRhaW4gY29uZGl0aW9ucywgdGhpcyBjYW4gY2F1c2UgdGhlXG4gICAgLy8gZm9jdXMgZXZlbnQgdG8gZmlyZSBhZnRlciB0aGUgYmx1ciBldmVudCwgd2hpY2ggY2FuIGNhdXNlIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC4gU28gd2UgZGV0ZWN0IHdoZXRoZXIgd2UncmUgYWN0dWFsbHkgZm9jdXNlZC9ibHVycmVkIGJlZm9yZSBmaXJpbmcuXG4gICAgaWYgKCAvXig/OmZvY3VzfGJsdXIpLy50ZXN0KCB0eXBlICkgKSB7XG4gICAgICAgIGlzRm9jdXNlZCA9IHRoaXMuX3Jvb3QgPT09IHRoaXMuX2RvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoIHR5cGUgPT09ICdmb2N1cycgKSB7XG4gICAgICAgICAgICBpZiAoICFpc0ZvY3VzZWQgfHwgdGhpcy5faXNGb2N1c2VkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggaXNGb2N1c2VkIHx8ICF0aGlzLl9pc0ZvY3VzZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIGhhbmRsZXJzICkge1xuICAgICAgICBpZiAoICFldmVudCApIHtcbiAgICAgICAgICAgIGV2ZW50ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBldmVudC50eXBlICE9PSB0eXBlICkge1xuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmUgaGFuZGxlcnMgYXJyYXksIHNvIGFueSBoYW5kbGVycyBhZGRlZC9yZW1vdmVkIGRvIG5vdCBhZmZlY3QgaXQuXG4gICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoKTtcbiAgICAgICAgbCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsLS0gKSB7XG4gICAgICAgICAgICBvYmogPSBoYW5kbGVyc1tsXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCBvYmouaGFuZGxlRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5oYW5kbGVFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmouY2FsbCggdGhpcywgZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscyA9ICdTcXVpcmU6IGZpcmVFdmVudCBlcnJvci4gRXZlbnQgdHlwZTogJyArIHR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRFcnJvciggZXJyb3IgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICB2YXIgdHlwZTtcblxuICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUgKTtcbiAgICB9XG4gICAgaWYgKCB0aGlzLl9tdXRhdGlvbiApIHtcbiAgICAgICAgdGhpcy5fbXV0YXRpb24uZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fcm9vdC5fX3NxdWlyZV9fO1xuXG4gICAgLy8gRGVzdHJveSB1bmRvIHN0YWNrXG4gICAgdGhpcy5fdW5kb0luZGV4ID0gLTE7XG4gICAgdGhpcy5fdW5kb1N0YWNrID0gW107XG4gICAgdGhpcy5fdW5kb1N0YWNrTGVuZ3RoID0gMDtcbn07XG5cbnByb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICB0aGlzLmZpcmVFdmVudCggZXZlbnQudHlwZSwgZXZlbnQgKTtcbn07XG5cbnByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoIHR5cGUsIGZuICkge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1sgdHlwZSBdO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9yb290O1xuICAgIGlmICggIWZuICkge1xuICAgICAgICB0aGlzLmRpZEVycm9yKHtcbiAgICAgICAgICAgIG5hbWU6ICdTcXVpcmU6IGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCBmbicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXZlbnQgdHlwZTogJyArIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoICFoYW5kbGVycyApIHtcbiAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbIHR5cGUgXSA9IFtdO1xuICAgICAgICBpZiAoICFjdXN0b21FdmVudHNbIHR5cGUgXSApIHtcbiAgICAgICAgICAgIGlmICggdHlwZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZScgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fZG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHRoaXMsIHRydWUgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVycy5wdXNoKCBmbiApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICggdHlwZSwgZm4gKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzWyB0eXBlIF07XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIGw7XG4gICAgaWYgKCBoYW5kbGVycyApIHtcbiAgICAgICAgaWYgKCBmbiApIHtcbiAgICAgICAgICAgIGwgPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZXJzW2xdID09PSBmbiApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKCBsLCAxICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICFoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzWyB0eXBlIF07XG4gICAgICAgICAgICBpZiAoICFjdXN0b21FdmVudHNbIHR5cGUgXSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnICkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9kb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCB0aGlzLCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyAtLS0gU2VsZWN0aW9uIGFuZCBQYXRoIC0tLVxuXG5wcm90by5jcmVhdGVSYW5nZSA9XG4gICAgICAgIGZ1bmN0aW9uICggcmFuZ2UsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCApIHtcbiAgICBpZiAoIHJhbmdlIGluc3RhbmNlb2YgdGhpcy5fd2luLlJhbmdlICkge1xuICAgICAgICByZXR1cm4gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgIH1cbiAgICB2YXIgZG9tUmFuZ2UgPSB0aGlzLl9kb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydCggcmFuZ2UsIHN0YXJ0T2Zmc2V0ICk7XG4gICAgaWYgKCBlbmRDb250YWluZXIgKSB7XG4gICAgICAgIGRvbVJhbmdlLnNldEVuZCggZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQoIHJhbmdlLCBzdGFydE9mZnNldCApO1xuICAgIH1cbiAgICByZXR1cm4gZG9tUmFuZ2U7XG59O1xuXG5wcm90by5nZXRDdXJzb3JQb3NpdGlvbiA9IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG4gICAgaWYgKCAoICFyYW5nZSAmJiAhKCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkgKSApIHx8XG4gICAgICAgICAgICAhcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBib3VuZGluZyByZWN0XG4gICAgdmFyIHJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbm9kZSwgcGFyZW50O1xuICAgIGlmICggcmVjdCAmJiAhcmVjdC50b3AgKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIG5vZGUgPSB0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCggJ1NQQU4nICk7XG4gICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBaV1M7XG4gICAgICAgIGluc2VydE5vZGVJblJhbmdlKCByYW5nZSwgbm9kZSApO1xuICAgICAgICByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgbWVyZ2VJbmxpbmVzKCBwYXJlbnQsIHJhbmdlICk7XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufTtcblxucHJvdG8uX21vdmVDdXJzb3JUbyA9IGZ1bmN0aW9uICggdG9TdGFydCApIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSggcm9vdCwgdG9TdGFydCA/IDAgOiByb290LmNoaWxkTm9kZXMubGVuZ3RoICk7XG4gICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcbnByb3RvLm1vdmVDdXJzb3JUb1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlQ3Vyc29yVG8oIHRydWUgKTtcbn07XG5wcm90by5tb3ZlQ3Vyc29yVG9FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmVDdXJzb3JUbyggZmFsc2UgKTtcbn07XG5cbnZhciBnZXRXaW5kb3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoIHNlbGYgKSB7XG4gICAgcmV0dXJuIHNlbGYuX3dpbi5nZXRTZWxlY3Rpb24oKSB8fCBudWxsO1xufTtcblxucHJvdG8uc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCByYW5nZSApIHtcbiAgICBpZiAoIHJhbmdlICkge1xuICAgICAgICB0aGlzLl9sYXN0U2VsZWN0aW9uID0gcmFuZ2U7XG4gICAgICAgIC8vIElmIHdlJ3JlIHNldHRpbmcgc2VsZWN0aW9uLCB0aGF0IGF1dG9tYXRpY2FsbHksIGFuZCBzeW5jaHJvbm91c2x5LCAvLyB0cmlnZ2VycyBhIGZvY3VzIGV2ZW50LiBTbyBqdXN0IHN0b3JlIHRoZSBzZWxlY3Rpb24gYW5kIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gbmVlZGluZyByZXN0b3JlIG9uIGZvY3VzLlxuICAgICAgICBpZiAoICF0aGlzLl9pc0ZvY3VzZWQgKSB7XG4gICAgICAgICAgICBlbmFibGVSZXN0b3JlU2VsZWN0aW9uLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNBbmRyb2lkICYmICF0aGlzLl9yZXN0b3JlU2VsZWN0aW9uICkge1xuICAgICAgICAgICAgLy8gQW5kcm9pZCBjbG9zZXMgdGhlIGtleWJvYXJkIG9uIHJlbW92ZUFsbFJhbmdlcygpIGFuZCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBvcGVuIGl0IGFnYWluIHdoZW4gYWRkUmFuZ2UoKSBpcyBjYWxsZWQsIHNpZ2guXG4gICAgICAgICAgICAvLyBTaW5jZSBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlciBhIGZvY3VzIGV2ZW50IGluIHNldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgLy8gdXNlIGEgYmx1ci9mb2N1cyBkYW5jZSB0byB3b3JrIGFyb3VuZCB0aGlzIGJ5IGxldHRpbmcgdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gYmUgcmVzdG9yZWQgb24gZm9jdXMuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGZvciAhdGhpcy5fcmVzdG9yZVNlbGVjdGlvbiB0byBhdm9pZCBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICBlbmFibGVSZXN0b3JlU2VsZWN0aW9uLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaU9TIGJ1ZzogaWYgeW91IGRvbid0IGZvY3VzIHRoZSBpZnJhbWUgYmVmb3JlIHNldHRpbmcgdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24sIHlvdSBjYW4gZW5kIHVwIGluIGEgc3RhdGUgd2hlcmUgeW91IHR5cGUgYnV0IHRoZSBpbnB1dFxuICAgICAgICAgICAgLy8gZG9lc24ndCBnZXQgZGlyZWN0ZWQgaW50byB0aGUgY29udGVudGVkaXRhYmxlIGFyZWEgYnV0IGlzIGluc3RlYWRcbiAgICAgICAgICAgIC8vIGxvc3QgaW4gYSBibGFjayBob2xlLiBWZXJ5IHN0cmFuZ2UuXG4gICAgICAgICAgICBpZiAoIGlzSU9TICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpbi5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbCA9IGdldFdpbmRvd1NlbGVjdGlvbiggdGhpcyApO1xuICAgICAgICAgICAgaWYgKCBzZWwgKSB7XG4gICAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZSggcmFuZ2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gZ2V0V2luZG93U2VsZWN0aW9uKCB0aGlzICk7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBzZWxlY3Rpb24sIHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIsIG5vZGU7XG4gICAgLy8gSWYgbm90IGZvY3VzZWQsIGFsd2F5cyByZWx5IG9uIGNhY2hlZCBzZWxlY3Rpb247IGFub3RoZXIgZnVuY3Rpb24gbWF5XG4gICAgLy8gaGF2ZSBzZXQgaXQgYnV0IHRoZSBET00gaXMgbm90IG1vZGlmaWVkIHVudGlsIGZvY3VzIGFnYWluXG4gICAgaWYgKCB0aGlzLl9pc0ZvY3VzZWQgJiYgc2VsICYmIHNlbC5yYW5nZUNvdW50ICkge1xuICAgICAgICBzZWxlY3Rpb24gID0gc2VsLmdldFJhbmdlQXQoIDAgKS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc2VsZWN0aW9uLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBlbmRDb250YWluZXIgPSBzZWxlY3Rpb24uZW5kQ29udGFpbmVyO1xuICAgICAgICAvLyBGRiBjYW4gcmV0dXJuIHRoZSBzZWxlY3Rpb24gYXMgYmVpbmcgaW5zaWRlIGFuIDxpbWc+LiBXVEY/XG4gICAgICAgIGlmICggc3RhcnRDb250YWluZXIgJiYgaXNMZWFmKCBzdGFydENvbnRhaW5lciApICkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFN0YXJ0QmVmb3JlKCBzdGFydENvbnRhaW5lciApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggZW5kQ29udGFpbmVyICYmIGlzTGVhZiggZW5kQ29udGFpbmVyICkgKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2V0RW5kQmVmb3JlKCBlbmRDb250YWluZXIgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIHNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgaXNPckNvbnRhaW5zKCByb290LCBzZWxlY3Rpb24uY29tbW9uQW5jZXN0b3JDb250YWluZXIgKSApIHtcbiAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb24gPSB0aGlzLl9sYXN0U2VsZWN0aW9uO1xuICAgICAgICBub2RlID0gc2VsZWN0aW9uLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgICAvLyBDaGVjayB0aGUgZWRpdG9yIGlzIGluIHRoZSBsaXZlIGRvY3VtZW50OyBpZiBub3QsIHRoZSByYW5nZSBoYXNcbiAgICAgICAgLy8gcHJvYmFibHkgYmVlbiByZXdyaXR0ZW4gYnkgdGhlIGJyb3dzZXIgYW5kIGlzIGJvZ3VzXG4gICAgICAgIGlmICggIWlzT3JDb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICggIXNlbGVjdGlvbiApIHtcbiAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5jcmVhdGVSYW5nZSggcm9vdC5maXJzdENoaWxkLCAwICk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59O1xuXG5mdW5jdGlvbiBlbmFibGVSZXN0b3JlU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLl9yZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVSZXN0b3JlU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLl9yZXN0b3JlU2VsZWN0aW9uID0gZmFsc2U7XG59XG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uICgpIHtcbiAgICBpZiAoIHRoaXMuX3Jlc3RvcmVTZWxlY3Rpb24gKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKCB0aGlzLl9sYXN0U2VsZWN0aW9uICk7XG4gICAgfVxufVxuXG5wcm90by5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoICFyYW5nZSB8fCByYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKFxuICAgICAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcixcbiAgICAgICAgU0hPV19URVhUfFNIT1dfRUxFTUVOVCxcbiAgICAgICAgZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm9kZUNvbnRhaW5lZEluUmFuZ2UoIHJhbmdlLCBub2RlLCB0cnVlICk7XG4gICAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgdmFyIG5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGUgPSBzdGFydENvbnRhaW5lcjtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcbiAgICB2YXIgYWRkZWRUZXh0SW5CbG9jayA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmICggIXdhbGtlci5maWx0ZXIoIG5vZGUgKSApIHtcbiAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgIH1cblxuICAgIHdoaWxlICggbm9kZSApIHtcbiAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmICggdmFsdWUgJiYgKCAvXFxTLy50ZXN0KCB2YWx1ZSApICkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbmRDb250YWluZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoIDAsIHJhbmdlLmVuZE9mZnNldCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIG5vZGUgPT09IHN0YXJ0Q29udGFpbmVyICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCByYW5nZS5zdGFydE9mZnNldCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhZGRlZFRleHRJbkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggbm9kZS5ub2RlTmFtZSA9PT0gJ0JSJyB8fFxuICAgICAgICAgICAgICAgIGFkZGVkVGV4dEluQmxvY2sgJiYgIWlzSW5saW5lKCBub2RlICkgKSB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudCArPSAnXFxuJztcbiAgICAgICAgICAgIGFkZGVkVGV4dEluQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xufTtcblxucHJvdG8uZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbn07XG5cbi8vIC0tLSBXb3JrYXJvdW5kIGZvciBicm93c2VycyB0aGF0IGNhbid0IGZvY3VzIGVtcHR5IHRleHQgbm9kZXMgLS0tXG5cbi8vIFdlYktpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTI1NlxuXG4vLyBXYWxrIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIHJlbW92ZSBhbnkgWldTLiBJZiB0aGUgbm9kZSBvbmx5XG4vLyBjb250YWluZWQgWldTIHNwYWNlIHRoZW4gcmVtb3ZlIGl0IHRvby4gV2UgbWF5IHdhbnQgdG8ga2VlcCBvbmUgWldTIG5vZGUgYXRcbi8vIHRoZSBib3R0b20gb2YgdGhlIHRyZWUgc28gdGhlIGJsb2NrIGNhbiBiZSBzZWxlY3RlZC4gRGVmaW5lIHRoYXQgbm9kZSBhcyB0aGVcbi8vIGtlZXBOb2RlLlxudmFyIHJlbW92ZVpXUyA9IGZ1bmN0aW9uICggcm9vdCwga2VlcE5vZGUgKSB7XG4gICAgdmFyIHdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKCByb290LCBTSE9XX1RFWFQgKTtcbiAgICB2YXIgcGFyZW50LCBub2RlLCBpbmRleDtcbiAgICB3aGlsZSAoIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSApIHtcbiAgICAgICAgd2hpbGUgKCAoIGluZGV4ID0gbm9kZS5kYXRhLmluZGV4T2YoIFpXUyApICkgPiAtMSAgJiZcbiAgICAgICAgICAgICAgICAoICFrZWVwTm9kZSB8fCBub2RlLnBhcmVudE5vZGUgIT09IGtlZXBOb2RlICkgKSB7XG4gICAgICAgICAgICBpZiAoIG5vZGUubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCBpc0lubGluZSggbm9kZSApICYmICFnZXRMZW5ndGgoIG5vZGUgKSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmRlbGV0ZURhdGEoIGluZGV4LCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5wcm90by5fZGlkQWRkWldTID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2hhc1pXUyA9IHRydWU7XG59O1xucHJvdG8uX3JlbW92ZVpXUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLl9oYXNaV1MgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVtb3ZlWldTKCB0aGlzLl9yb290ICk7XG4gICAgdGhpcy5faGFzWldTID0gZmFsc2U7XG59O1xuXG4vLyAtLS0gUGF0aCBjaGFuZ2UgZXZlbnRzIC0tLVxuXG5wcm90by5fdXBkYXRlUGF0aCA9IGZ1bmN0aW9uICggcmFuZ2UsIGZvcmNlICkge1xuICAgIGlmICggIXJhbmdlICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgZm9jdXMgPSByYW5nZS5lbmRDb250YWluZXIsXG4gICAgICAgIG5ld1BhdGg7XG4gICAgaWYgKCBmb3JjZSB8fCBhbmNob3IgIT09IHRoaXMuX2xhc3RBbmNob3JOb2RlIHx8XG4gICAgICAgICAgICBmb2N1cyAhPT0gdGhpcy5fbGFzdEZvY3VzTm9kZSApIHtcbiAgICAgICAgdGhpcy5fbGFzdEFuY2hvck5vZGUgPSBhbmNob3I7XG4gICAgICAgIHRoaXMuX2xhc3RGb2N1c05vZGUgPSBmb2N1cztcbiAgICAgICAgbmV3UGF0aCA9ICggYW5jaG9yICYmIGZvY3VzICkgPyAoIGFuY2hvciA9PT0gZm9jdXMgKSA/XG4gICAgICAgICAgICBnZXRQYXRoKCBmb2N1cywgdGhpcy5fcm9vdCwgdGhpcy5fY29uZmlnICkgOiAnKHNlbGVjdGlvbiknIDogJyc7XG4gICAgICAgIGlmICggdGhpcy5fcGF0aCAhPT0gbmV3UGF0aCApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGggPSBuZXdQYXRoO1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoICdwYXRoQ2hhbmdlJywgeyBwYXRoOiBuZXdQYXRoIH0gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZpcmVFdmVudCggcmFuZ2UuY29sbGFwc2VkID8gJ2N1cnNvcicgOiAnc2VsZWN0Jywge1xuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICB9KTtcbn07XG5cbi8vIHNlbGVjdGlvbmNoYW5nZSBpcyBmaXJlZCBzeW5jaHJvbm91c2x5IGluIElFIHdoZW4gcmVtb3ZpbmcgY3VycmVudCBzZWxlY3Rpb25cbi8vIGFuZCB3aGVuIHNldHRpbmcgbmV3IHNlbGVjdGlvbjsga2V5dXAvbW91c2V1cCBtYXkgaGF2ZSBwcm9jZXNzaW5nIHdlIHdhbnRcbi8vIHRvIGRvIGZpcnN0LiBFaXRoZXIgd2F5LCBzZW5kIHRvIG5leHQgZXZlbnQgbG9vcC5cbnByb3RvLl91cGRhdGVQYXRoT25FdmVudCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICggc2VsZi5faXNGb2N1c2VkICYmICFzZWxmLl93aWxsVXBkYXRlUGF0aCApIHtcbiAgICAgICAgc2VsZi5fd2lsbFVwZGF0ZVBhdGggPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLl93aWxsVXBkYXRlUGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGF0aCggc2VsZi5nZXRTZWxlY3Rpb24oKSApO1xuICAgICAgICB9LCAwICk7XG4gICAgfVxufTtcblxuLy8gLS0tIEZvY3VzIC0tLVxuXG5wcm90by5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcblxuICAgIGlmICggaXNJRSApIHtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoICdmb2N1cycgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdC5ibHVyKCk7XG5cbiAgICBpZiAoIGlzSUUgKSB7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCAnYmx1cicgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIC0tLSBCb29rbWFya2luZyAtLS1cblxudmFyIHN0YXJ0U2VsZWN0aW9uSWQgPSAnc3F1aXJlLXNlbGVjdGlvbi1zdGFydCc7XG52YXIgZW5kU2VsZWN0aW9uSWQgPSAnc3F1aXJlLXNlbGVjdGlvbi1lbmQnO1xuXG5wcm90by5fc2F2ZVJhbmdlVG9Cb29rbWFyayA9IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ0lOUFVUJywge1xuICAgICAgICAgICAgaWQ6IHN0YXJ0U2VsZWN0aW9uSWQsXG4gICAgICAgICAgICB0eXBlOiAnaGlkZGVuJ1xuICAgICAgICB9KSxcbiAgICAgICAgZW5kTm9kZSA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ0lOUFVUJywge1xuICAgICAgICAgICAgaWQ6IGVuZFNlbGVjdGlvbklkLFxuICAgICAgICAgICAgdHlwZTogJ2hpZGRlbidcbiAgICAgICAgfSksXG4gICAgICAgIHRlbXA7XG5cbiAgICBpbnNlcnROb2RlSW5SYW5nZSggcmFuZ2UsIHN0YXJ0Tm9kZSApO1xuICAgIHJhbmdlLmNvbGxhcHNlKCBmYWxzZSApO1xuICAgIGluc2VydE5vZGVJblJhbmdlKCByYW5nZSwgZW5kTm9kZSApO1xuXG4gICAgLy8gSW4gYSBjb2xsYXBzZWQgcmFuZ2UsIHRoZSBzdGFydCBpcyBzb21ldGltZXMgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIGVuZCFcbiAgICBpZiAoIHN0YXJ0Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZW5kTm9kZSApICZcbiAgICAgICAgICAgIERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyApIHtcbiAgICAgICAgc3RhcnROb2RlLmlkID0gZW5kU2VsZWN0aW9uSWQ7XG4gICAgICAgIGVuZE5vZGUuaWQgPSBzdGFydFNlbGVjdGlvbklkO1xuICAgICAgICB0ZW1wID0gc3RhcnROb2RlO1xuICAgICAgICBzdGFydE5vZGUgPSBlbmROb2RlO1xuICAgICAgICBlbmROb2RlID0gdGVtcDtcbiAgICB9XG5cbiAgICByYW5nZS5zZXRTdGFydEFmdGVyKCBzdGFydE5vZGUgKTtcbiAgICByYW5nZS5zZXRFbmRCZWZvcmUoIGVuZE5vZGUgKTtcbn07XG5cbnByb3RvLl9nZXRSYW5nZUFuZFJlbW92ZUJvb2ttYXJrID0gZnVuY3Rpb24gKCByYW5nZSApIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHN0YXJ0ID0gcm9vdC5xdWVyeVNlbGVjdG9yKCAnIycgKyBzdGFydFNlbGVjdGlvbklkICksXG4gICAgICAgIGVuZCA9IHJvb3QucXVlcnlTZWxlY3RvciggJyMnICsgZW5kU2VsZWN0aW9uSWQgKTtcblxuICAgIGlmICggc3RhcnQgJiYgZW5kICkge1xuICAgICAgICB2YXIgc3RhcnRDb250YWluZXIgPSBzdGFydC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kLnBhcmVudE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IGluZGV4T2YuY2FsbCggc3RhcnRDb250YWluZXIuY2hpbGROb2Rlcywgc3RhcnQgKSxcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IGluZGV4T2YuY2FsbCggZW5kQ29udGFpbmVyLmNoaWxkTm9kZXMsIGVuZCApO1xuXG4gICAgICAgIGlmICggc3RhcnRDb250YWluZXIgPT09IGVuZENvbnRhaW5lciApIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoKCBzdGFydCApO1xuICAgICAgICBkZXRhY2goIGVuZCApO1xuXG4gICAgICAgIGlmICggIXJhbmdlICkge1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLl9kb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5zZXRTdGFydCggc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0ICk7XG4gICAgICAgIHJhbmdlLnNldEVuZCggZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgKTtcblxuICAgICAgICAvLyBNZXJnZSBhbnkgdGV4dCBub2RlcyB3ZSBzcGxpdFxuICAgICAgICBtZXJnZUlubGluZXMoIHN0YXJ0Q29udGFpbmVyLCByYW5nZSApO1xuICAgICAgICBpZiAoIHN0YXJ0Q29udGFpbmVyICE9PSBlbmRDb250YWluZXIgKSB7XG4gICAgICAgICAgICBtZXJnZUlubGluZXMoIGVuZENvbnRhaW5lciwgcmFuZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBzcGxpdCBhIHRleHQgbm9kZSwgd2Ugc2hvdWxkIG1vdmUgaW50byBhbnkgYWRqYWNlbnRcbiAgICAgICAgLy8gdGV4dCBub2RlIHRvIGN1cnJlbnQgc2VsZWN0aW9uIHBvaW50XG4gICAgICAgIGlmICggcmFuZ2UuY29sbGFwc2VkICkge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmICggc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzWyByYW5nZS5zdGFydE9mZnNldCBdO1xuICAgICAgICAgICAgICAgIGlmICggIWVuZENvbnRhaW5lciB8fCBlbmRDb250YWluZXIubm9kZVR5cGUgIT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbIHJhbmdlLnN0YXJ0T2Zmc2V0IC0gMSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGVuZENvbnRhaW5lciAmJiBlbmRDb250YWluZXIubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIGVuZENvbnRhaW5lciwgMCApO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSggdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2UgfHwgbnVsbDtcbn07XG5cbi8vIC0tLSBVbmRvIC0tLVxuXG5wcm90by5fa2V5VXBEZXRlY3RDaGFuZ2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgIHZhciBjb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAvLyBQcmVzdW1lIGRvY3VtZW50IHdhcyBjaGFuZ2VkIGlmOlxuICAgIC8vIDEuIEEgbW9kaWZpZXIga2V5IChvdGhlciB0aGFuIHNoaWZ0KSB3YXNuJ3QgaGVsZCBkb3duXG4gICAgLy8gMi4gVGhlIGtleSBwcmVzc2VkIGlzIG5vdCBpbiByYW5nZSAxNjw9eDw9MjAgKGNvbnRyb2wga2V5cylcbiAgICAvLyAzLiBUaGUga2V5IHByZXNzZWQgaXMgbm90IGluIHJhbmdlIDMzPD14PD00NSAobmF2aWdhdGlvbiBrZXlzKVxuICAgIGlmICggIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmFsdEtleSAmJlxuICAgICAgICAgICAgKCBjb2RlIDwgMTYgfHwgY29kZSA+IDIwICkgJiZcbiAgICAgICAgICAgICggY29kZSA8IDMzIHx8IGNvZGUgPiA0NSApICkge1xuICAgICAgICB0aGlzLl9kb2NXYXNDaGFuZ2VkKCk7XG4gICAgfVxufTtcblxucHJvdG8uX2RvY1dhc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCBjYW5XZWFrTWFwICkge1xuICAgICAgICBub2RlQ2F0ZWdvcnlDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIGlmICggdGhpcy5faWdub3JlQWxsQ2hhbmdlcyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggY2FuT2JzZXJ2ZU11dGF0aW9ucyAmJiB0aGlzLl9pZ25vcmVDaGFuZ2UgKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICggdGhpcy5faXNJblVuZG9TdGF0ZSApIHtcbiAgICAgICAgdGhpcy5faXNJblVuZG9TdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCggJ3VuZG9TdGF0ZUNoYW5nZScsIHtcbiAgICAgICAgICAgIGNhblVuZG86IHRydWUsXG4gICAgICAgICAgICBjYW5SZWRvOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maXJlRXZlbnQoICdpbnB1dCcgKTtcbn07XG5cbi8vIExlYXZlcyBib29rbWFya1xucHJvdG8uX3JlY29yZFVuZG9TdGF0ZSA9IGZ1bmN0aW9uICggcmFuZ2UsIHJlcGxhY2UgKSB7XG4gICAgLy8gRG9uJ3QgcmVjb3JkIGlmIHdlJ3JlIGFscmVhZHkgaW4gYW4gdW5kbyBzdGF0ZVxuICAgIGlmICggIXRoaXMuX2lzSW5VbmRvU3RhdGV8fCByZXBsYWNlICkge1xuICAgICAgICAvLyBBZHZhbmNlIHBvaW50ZXIgdG8gbmV3IHBvc2l0aW9uXG4gICAgICAgIHZhciB1bmRvSW5kZXggPSB0aGlzLl91bmRvSW5kZXg7XG4gICAgICAgIHZhciB1bmRvU3RhY2sgPSB0aGlzLl91bmRvU3RhY2s7XG4gICAgICAgIHZhciB1bmRvQ29uZmlnID0gdGhpcy5fY29uZmlnLnVuZG87XG4gICAgICAgIHZhciB1bmRvVGhyZXNob2xkID0gdW5kb0NvbmZpZy5kb2N1bWVudFNpemVUaHJlc2hvbGQ7XG4gICAgICAgIHZhciB1bmRvTGltaXQgPSB1bmRvQ29uZmlnLnVuZG9MaW1pdDtcbiAgICAgICAgdmFyIGh0bWw7XG5cbiAgICAgICAgaWYgKCAhcmVwbGFjZSApIHtcbiAgICAgICAgICAgIHVuZG9JbmRleCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ1bmNhdGUgc3RhY2sgaWYgbG9uZ2VyIChpLmUuIGlmIGhhcyBiZWVuIHByZXZpb3VzbHkgdW5kb25lKVxuICAgICAgICBpZiAoIHVuZG9JbmRleCA8IHRoaXMuX3VuZG9TdGFja0xlbmd0aCApIHtcbiAgICAgICAgICAgIHVuZG9TdGFjay5sZW5ndGggPSB0aGlzLl91bmRvU3RhY2tMZW5ndGggPSB1bmRvSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgZGF0YVxuICAgICAgICBpZiAoIHJhbmdlICkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZVJhbmdlVG9Cb29rbWFyayggcmFuZ2UgKTtcbiAgICAgICAgfVxuICAgICAgICBodG1sID0gdGhpcy5fZ2V0SFRNTCgpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgZG9jdW1lbnQgaXMgYWJvdmUgdGhlIGNvbmZpZ3VyZWQgc2l6ZSB0aHJlc2hvbGQsXG4gICAgICAgIC8vIGxpbWl0IHRoZSBudW1iZXIgb2Ygc2F2ZWQgdW5kbyBzdGF0ZXMuXG4gICAgICAgIC8vIFRocmVzaG9sZCBpcyBpbiBieXRlcywgSlMgdXNlcyAyIGJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKCB1bmRvVGhyZXNob2xkID4gLTEgJiYgaHRtbC5sZW5ndGggKiAyID4gdW5kb1RocmVzaG9sZCApIHtcbiAgICAgICAgICAgIGlmICggdW5kb0xpbWl0ID4gLTEgJiYgdW5kb0luZGV4ID4gdW5kb0xpbWl0ICkge1xuICAgICAgICAgICAgICAgIHVuZG9TdGFjay5zcGxpY2UoIDAsIHVuZG9JbmRleCAtIHVuZG9MaW1pdCApO1xuICAgICAgICAgICAgICAgIHVuZG9JbmRleCA9IHVuZG9MaW1pdDtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmRvU3RhY2tMZW5ndGggPSB1bmRvTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGRhdGFcbiAgICAgICAgdW5kb1N0YWNrWyB1bmRvSW5kZXggXSA9IGh0bWw7XG4gICAgICAgIHRoaXMuX3VuZG9JbmRleCA9IHVuZG9JbmRleDtcbiAgICAgICAgdGhpcy5fdW5kb1N0YWNrTGVuZ3RoICs9IDE7XG4gICAgICAgIHRoaXMuX2lzSW5VbmRvU3RhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbnByb3RvLnNhdmVVbmRvU3RhdGUgPSBmdW5jdGlvbiAoIHJhbmdlICkge1xuICAgIGlmICggcmFuZ2UgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9yZWNvcmRVbmRvU3RhdGUoIHJhbmdlLCB0aGlzLl9pc0luVW5kb1N0YXRlICk7XG4gICAgdGhpcy5fZ2V0UmFuZ2VBbmRSZW1vdmVCb29rbWFyayggcmFuZ2UgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTYW5pdHkgY2hlY2s6IG11c3Qgbm90IGJlIGF0IGJlZ2lubmluZyBvZiB0aGUgaGlzdG9yeSBzdGFja1xuICAgIGlmICggdGhpcy5fdW5kb0luZGV4ICE9PSAwIHx8ICF0aGlzLl9pc0luVW5kb1N0YXRlICkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW55IGNoYW5nZXMgc2luY2UgbGFzdCBjaGVja3BvaW50IGFyZSBzYXZlZC5cbiAgICAgICAgdGhpcy5fcmVjb3JkVW5kb1N0YXRlKCB0aGlzLmdldFNlbGVjdGlvbigpLCBmYWxzZSApO1xuXG4gICAgICAgIHRoaXMuX3VuZG9JbmRleCAtPSAxO1xuICAgICAgICB0aGlzLl9zZXRIVE1MKCB0aGlzLl91bmRvU3RhY2tbIHRoaXMuX3VuZG9JbmRleCBdICk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX2dldFJhbmdlQW5kUmVtb3ZlQm9va21hcmsoKTtcbiAgICAgICAgaWYgKCByYW5nZSApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzSW5VbmRvU3RhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCggJ3VuZG9TdGF0ZUNoYW5nZScsIHtcbiAgICAgICAgICAgIGNhblVuZG86IHRoaXMuX3VuZG9JbmRleCAhPT0gMCxcbiAgICAgICAgICAgIGNhblJlZG86IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCAnaW5wdXQnICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTYW5pdHkgY2hlY2s6IG11c3Qgbm90IGJlIGF0IGVuZCBvZiBzdGFjayBhbmQgbXVzdCBiZSBpbiBhbiB1bmRvXG4gICAgLy8gc3RhdGUuXG4gICAgdmFyIHVuZG9JbmRleCA9IHRoaXMuX3VuZG9JbmRleCxcbiAgICAgICAgdW5kb1N0YWNrTGVuZ3RoID0gdGhpcy5fdW5kb1N0YWNrTGVuZ3RoO1xuICAgIGlmICggdW5kb0luZGV4ICsgMSA8IHVuZG9TdGFja0xlbmd0aCAmJiB0aGlzLl9pc0luVW5kb1N0YXRlICkge1xuICAgICAgICB0aGlzLl91bmRvSW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5fc2V0SFRNTCggdGhpcy5fdW5kb1N0YWNrWyB0aGlzLl91bmRvSW5kZXggXSApO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9nZXRSYW5nZUFuZFJlbW92ZUJvb2ttYXJrKCk7XG4gICAgICAgIGlmICggcmFuZ2UgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcmVFdmVudCggJ3VuZG9TdGF0ZUNoYW5nZScsIHtcbiAgICAgICAgICAgIGNhblVuZG86IHRydWUsXG4gICAgICAgICAgICBjYW5SZWRvOiB1bmRvSW5kZXggKyAyIDwgdW5kb1N0YWNrTGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCggJ2lucHV0JyApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIC0tLSBJbmxpbmUgZm9ybWF0dGluZyAtLS1cblxuLy8gTG9va3MgZm9yIG1hdGNoaW5nIHRhZyBhbmQgYXR0cmlidXRlcywgc28gd29uJ3Qgd29ya1xuLy8gaWYgPHN0cm9uZz4gaW5zdGVhZCBvZiA8Yj4gZXRjLlxucHJvdG8uaGFzRm9ybWF0ID0gZnVuY3Rpb24gKCB0YWcsIGF0dHJpYnV0ZXMsIHJhbmdlICkge1xuICAgIC8vIDEuIE5vcm1hbGlzZSB0aGUgYXJndW1lbnRzIGFuZCBnZXQgc2VsZWN0aW9uXG4gICAgdGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCAhYXR0cmlidXRlcyApIHsgYXR0cmlidXRlcyA9IHt9OyB9XG4gICAgaWYgKCAhcmFuZ2UgJiYgISggcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpICkgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTYW5pdGl6ZSByYW5nZSB0byBwcmV2ZW50IHdlaXJkIElFIGFydGlmYWN0c1xuICAgIGlmICggIXJhbmdlLmNvbGxhcHNlZCAmJlxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKCByYW5nZS5zdGFydENvbnRhaW5lci5uZXh0U2libGluZyApO1xuICAgIH1cbiAgICBpZiAoICFyYW5nZS5jb2xsYXBzZWQgJiZcbiAgICAgICAgICAgIHJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICYmXG4gICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQgPT09IDAgJiZcbiAgICAgICAgICAgIHJhbmdlLmVuZENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcgKSB7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKCByYW5nZS5lbmRDb250YWluZXIucHJldmlvdXNTaWJsaW5nICk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGNvbW1vbiBhbmNlc3RvciBpcyBpbnNpZGUgdGhlIHRhZyB3ZSByZXF1aXJlLCB3ZSBkZWZpbml0ZWx5XG4gICAgLy8gaGF2ZSB0aGUgZm9ybWF0LlxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tbW9uID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgdmFyIHdhbGtlciwgbm9kZTtcbiAgICBpZiAoIGdldE5lYXJlc3QoIGNvbW1vbiwgcm9vdCwgdGFnLCBhdHRyaWJ1dGVzICkgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIElmIGNvbW1vbiBhbmNlc3RvciBpcyBhIHRleHQgbm9kZSBhbmQgZG9lc24ndCBoYXZlIHRoZSBmb3JtYXQsIHdlXG4gICAgLy8gZGVmaW5pdGVseSBkb24ndCBoYXZlIGl0LlxuICAgIGlmICggY29tbW9uLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGVhY2ggdGV4dCBub2RlIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluXG4gICAgLy8gdGhlIHNlbGVjdGlvbiBhbmQgbWFrZSBzdXJlIGFsbCBvZiB0aGVtIGhhdmUgdGhlIGZvcm1hdCB3ZSB3YW50LlxuICAgIHdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKCBjb21tb24sIFNIT1dfVEVYVCwgZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICByZXR1cm4gaXNOb2RlQ29udGFpbmVkSW5SYW5nZSggcmFuZ2UsIG5vZGUsIHRydWUgKTtcbiAgICB9KTtcblxuICAgIHZhciBzZWVuTm9kZSA9IGZhbHNlO1xuICAgIHdoaWxlICggbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpICkge1xuICAgICAgICBpZiAoICFnZXROZWFyZXN0KCBub2RlLCByb290LCB0YWcsIGF0dHJpYnV0ZXMgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuTm9kZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZW5Ob2RlO1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIGZvbnQtZmFtaWx5IGFuZCBmb250LXNpemUgKGlmIGFueSkgb2YgdGhlIGVsZW1lbnRcbi8vIGhvbGRpbmcgdGhlIGN1cnNvci4gSWYgdGhlcmUncyBhIHNlbGVjdGlvbiwgcmV0dXJucyBhbiBlbXB0eSBvYmplY3QuXG5wcm90by5nZXRGb250SW5mbyA9IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG4gICAgdmFyIGZvbnRJbmZvID0ge1xuICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdmFyIHNlZW5BdHRyaWJ1dGVzID0gMDtcbiAgICB2YXIgZWxlbWVudCwgc3R5bGUsIGF0dHI7XG5cbiAgICBpZiAoICFyYW5nZSAmJiAhKCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkgKSApIHtcbiAgICAgICAgcmV0dXJuIGZvbnRJbmZvO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgIGlmICggZWxlbWVudC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIHNlZW5BdHRyaWJ1dGVzIDwgNCAmJiBlbGVtZW50ICkge1xuICAgICAgICAgICAgaWYgKCBzdHlsZSA9IGVsZW1lbnQuc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhZm9udEluZm8uY29sb3IgJiYgKCBhdHRyID0gc3R5bGUuY29sb3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udEluZm8uY29sb3IgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICBzZWVuQXR0cmlidXRlcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoICFmb250SW5mby5iYWNrZ3JvdW5kQ29sb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggYXR0ciA9IHN0eWxlLmJhY2tncm91bmRDb2xvciApICkge1xuICAgICAgICAgICAgICAgICAgICBmb250SW5mby5iYWNrZ3JvdW5kQ29sb3IgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICBzZWVuQXR0cmlidXRlcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoICFmb250SW5mby5mYW1pbHkgJiYgKCBhdHRyID0gc3R5bGUuZm9udEZhbWlseSApICkge1xuICAgICAgICAgICAgICAgICAgICBmb250SW5mby5mYW1pbHkgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICBzZWVuQXR0cmlidXRlcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoICFmb250SW5mby5zaXplICYmICggYXR0ciA9IHN0eWxlLmZvbnRTaXplICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRJbmZvLnNpemUgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICBzZWVuQXR0cmlidXRlcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvbnRJbmZvO1xufTtcblxucHJvdG8uX2FkZEZvcm1hdCA9IGZ1bmN0aW9uICggdGFnLCBhdHRyaWJ1dGVzLCByYW5nZSApIHtcbiAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIHdlIHNpbXBseSBpbnNlcnQgdGhlIG5vZGUgYnkgd3JhcHBpbmdcbiAgICAvLyBpdCByb3VuZCB0aGUgcmFuZ2UgYW5kIGZvY3VzIGl0LlxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgZWwsIHdhbGtlciwgc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCxcbiAgICAgICAgbm9kZSwgbmVlZHNGb3JtYXQsIGJsb2NrO1xuXG4gICAgaWYgKCByYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgIGVsID0gZml4Q3Vyc29yKCB0aGlzLmNyZWF0ZUVsZW1lbnQoIHRhZywgYXR0cmlidXRlcyApLCByb290ICk7XG4gICAgICAgIGluc2VydE5vZGVJblJhbmdlKCByYW5nZSwgZWwgKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoIGVsLmZpcnN0Q2hpbGQsIGVsLmZpcnN0Q2hpbGQubGVuZ3RoICk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKCB0cnVlICk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgYW55IHByZXZpb3VzIGZvcm1hdHMgdGhhdCBtYXkgaGF2ZSBiZWVuIHNldCBvbiB0aGlzIGJsb2NrXG4gICAgICAgIC8vIHRoYXQgYXJlIHVudXNlZC5cbiAgICAgICAgYmxvY2sgPSBlbDtcbiAgICAgICAgd2hpbGUgKCBpc0lubGluZSggYmxvY2sgKSApIHtcbiAgICAgICAgICAgIGJsb2NrID0gYmxvY2sucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVaV1MoIGJsb2NrLCBlbCApO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2Ugd2UgZmluZCBhbGwgdGhlIHRleHRub2RlcyBpbiB0aGUgcmFuZ2UgKHNwbGl0dGluZ1xuICAgIC8vIHBhcnRpYWxseSBzZWxlY3RlZCBub2RlcykgYW5kIGlmIHRoZXkncmUgbm90IGFscmVhZHkgZm9ybWF0dGVkXG4gICAgLy8gY29ycmVjdGx5IHdlIHdyYXAgdGhlbSBpbiB0aGUgYXBwcm9wcmlhdGUgdGFnLlxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYW4gaXRlcmF0b3IgdG8gd2FsayBvdmVyIGFsbCB0aGUgdGV4dCBub2RlcyB1bmRlciB0aGlzXG4gICAgICAgIC8vIGFuY2VzdG9yIHdoaWNoIGFyZSBpbiB0aGUgcmFuZ2UgYW5kIG5vdCBhbHJlYWR5IGZvcm1hdHRlZFxuICAgICAgICAvLyBjb3JyZWN0bHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIEJsaW5rL1dlYktpdCwgZW1wdHkgYmxvY2tzIG1heSBoYXZlIG5vIHRleHQgbm9kZXMsIGp1c3QgYSA8YnI+LlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2Ugd3JhcCB0aGlzIGluIHRoZSB0YWcgYXMgd2VsbCwgYXMgdGhpcyB3aWxsIHRoZW4gY2F1c2UgaXRcbiAgICAgICAgLy8gdG8gYXBwbHkgd2hlbiB0aGUgdXNlciB0eXBlcyBzb21ldGhpbmcgaW4gdGhlIGJsb2NrLCB3aGljaCBpc1xuICAgICAgICAvLyBwcmVzdW1hYmx5IHdoYXQgd2FzIGludGVuZGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJTUcgdGFncyBhcmUgaW5jbHVkZWQgYmVjYXVzZSB3ZSBtYXkgd2FudCB0byBjcmVhdGUgYSBsaW5rIGFyb3VuZFxuICAgICAgICAvLyB0aGVtLCBhbmQgYWRkaW5nIG90aGVyIHN0eWxlcyBpcyBoYXJtbGVzcy5cbiAgICAgICAgd2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoXG4gICAgICAgICAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcixcbiAgICAgICAgICAgIFNIT1dfVEVYVHxTSE9XX0VMRU1FTlQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lID09PSAnQlInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lID09PSAnSU1HJ1xuICAgICAgICAgICAgICAgICAgICApICYmIGlzTm9kZUNvbnRhaW5lZEluUmFuZ2UoIHJhbmdlLCBub2RlLCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3RhcnQgYXQgdGhlIGJlZ2lubmluZyBub2RlIG9mIHRoZSByYW5nZSBhbmQgaXRlcmF0ZSB0aHJvdWdoXG4gICAgICAgIC8vIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHJhbmdlIHRoYXQgbmVlZCBmb3JtYXR0aW5nLlxuICAgICAgICBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc3RhcnQgd2l0aCBhIHZhbGlkIG5vZGUuXG4gICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBpZiAoICF3YWxrZXIuZmlsdGVyKCBzdGFydENvbnRhaW5lciApICkge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBpbnRlcmVzdGluZyBub2RlcyBpbiB0aGUgc2VsZWN0aW9uLCBhYm9ydFxuICAgICAgICBpZiAoICFzdGFydENvbnRhaW5lciApIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICBuZWVkc0Zvcm1hdCA9ICFnZXROZWFyZXN0KCBub2RlLCByb290LCB0YWcsIGF0dHJpYnV0ZXMgKTtcbiAgICAgICAgICAgIGlmICggbmVlZHNGb3JtYXQgKSB7XG4gICAgICAgICAgICAgICAgLy8gPGJyPiBjYW4gbmV2ZXIgYmUgYSBjb250YWluZXIgbm9kZSwgc28gbXVzdCBoYXZlIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgLy8gaWYgbm9kZSA9PSAoZW5kfHN0YXJ0KUNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGlmICggbm9kZSA9PT0gZW5kQ29udGFpbmVyICYmIG5vZGUubGVuZ3RoID4gZW5kT2Zmc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNwbGl0VGV4dCggZW5kT2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggbm9kZSA9PT0gc3RhcnRDb250YWluZXIgJiYgc3RhcnRPZmZzZXQgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnNwbGl0VGV4dCggc3RhcnRPZmZzZXQgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmRDb250YWluZXIgPT09IHN0YXJ0Q29udGFpbmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldCAtPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoIHRhZywgYXR0cmlidXRlcyApO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VXaXRoKCBub2RlLCBlbCApO1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKCBub2RlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCB3YWxrZXIubmV4dE5vZGUoKSApO1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmlzaCBpbnNpZGUgYSB0ZXh0IG5vZGUsIG9mZnNldCBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICBpZiAoIGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICkge1xuICAgICAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgKSB7XG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgPGJyPiwgd2UgbXVzdCBoYXZlIGp1c3Qgd3JhcHBlZCBpdCwgc28gaXQgbXVzdCBoYXZlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBvbmUgY2hpbGRcbiAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBzZXQgdGhlIHNlbGVjdGlvbiB0byBhcyBpdCB3YXMgYmVmb3JlXG4gICAgICAgIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZShcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxucHJvdG8uX3JlbW92ZUZvcm1hdCA9IGZ1bmN0aW9uICggdGFnLCBhdHRyaWJ1dGVzLCByYW5nZSwgcGFydGlhbCApIHtcbiAgICAvLyBBZGQgYm9va21hcmtcbiAgICB0aGlzLl9zYXZlUmFuZ2VUb0Jvb2ttYXJrKCByYW5nZSApO1xuXG4gICAgLy8gV2UgbmVlZCBhIG5vZGUgaW4gdGhlIHNlbGVjdGlvbiB0byBicmVhayB0aGUgc3Vycm91bmRpbmdcbiAgICAvLyBmb3JtYXR0ZWQgdGV4dC5cbiAgICB2YXIgZG9jID0gdGhpcy5fZG9jLFxuICAgICAgICBmaXhlcjtcbiAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCApIHtcbiAgICAgICAgaWYgKCBjYW50Rm9jdXNFbXB0eVRleHROb2RlcyApIHtcbiAgICAgICAgICAgIGZpeGVyID0gZG9jLmNyZWF0ZVRleHROb2RlKCBaV1MgKTtcbiAgICAgICAgICAgIHRoaXMuX2RpZEFkZFpXUygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZml4ZXIgPSBkb2MuY3JlYXRlVGV4dE5vZGUoICcnICk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0Tm9kZUluUmFuZ2UoIHJhbmdlLCBmaXhlciApO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYmxvY2stbGV2ZWwgYW5jZXN0b3Igb2Ygc2VsZWN0aW9uXG4gICAgdmFyIHJvb3QgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB3aGlsZSAoIGlzSW5saW5lKCByb290ICkgKSB7XG4gICAgICAgIHJvb3QgPSByb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0ZXh0IG5vZGVzIGluc2lkZSBmb3JtYXRUYWdzIHRoYXQgYXJlIG5vdCBpbiBzZWxlY3Rpb24gYW5kXG4gICAgLy8gYWRkIGFuIGV4dHJhIHRhZyB3aXRoIHRoZSBzYW1lIGZvcm1hdHRpbmcuXG4gICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgICB0b1dyYXAgPSBbXSxcbiAgICAgICAgZXhhbWluZU5vZGUgPSBmdW5jdGlvbiAoIG5vZGUsIGV4ZW1wbGFyICkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgY29tcGxldGVseSBjb250YWluZWQgYnkgdGhlIHJhbmdlIHRoZW5cbiAgICAgICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJlbW92ZSBhbGwgZm9ybWF0dGluZyBzbyBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAoIGlzTm9kZUNvbnRhaW5lZEluUmFuZ2UoIHJhbmdlLCBub2RlLCBmYWxzZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzVGV4dCA9ICggbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICksXG4gICAgICAgICAgICAgICAgY2hpbGQsIG5leHQ7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdCBhdCBsZWFzdCBwYXJ0aWFsbHkgY29udGFpbmVkLCB3cmFwIGVudGlyZSBjb250ZW50c1xuICAgICAgICAgICAgLy8gaW4gYSBjbG9uZSBvZiB0aGUgdGFnIHdlJ3JlIHJlbW92aW5nIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKCAhaXNOb2RlQ29udGFpbmVkSW5SYW5nZSggcmFuZ2UsIG5vZGUsIHRydWUgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYm9va21hcmtzIGFuZCBlbXB0eSB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKCBub2RlLm5vZGVOYW1lICE9PSAnSU5QVVQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICFpc1RleHQgfHwgbm9kZS5kYXRhICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvV3JhcC5wdXNoKFsgZXhlbXBsYXIsIG5vZGUgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BsaXQgYW55IHBhcnRpYWxseSBzZWxlY3RlZCB0ZXh0IG5vZGVzLlxuICAgICAgICAgICAgaWYgKCBpc1RleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbmRDb250YWluZXIgJiYgZW5kT2Zmc2V0ICE9PSBub2RlLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9XcmFwLnB1c2goWyBleGVtcGxhciwgbm9kZS5zcGxpdFRleHQoIGVuZE9mZnNldCApIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIG5vZGUgPT09IHN0YXJ0Q29udGFpbmVyICYmIHN0YXJ0T2Zmc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNwbGl0VGV4dCggc3RhcnRPZmZzZXQgKTtcbiAgICAgICAgICAgICAgICAgICAgdG9XcmFwLnB1c2goWyBleGVtcGxhciwgbm9kZSBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBub3QgYSB0ZXh0IG5vZGUsIHJlY3Vyc2Ugb250byBhbGwgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBCZXdhcmUsIHRoZSB0cmVlIG1heSBiZSByZXdyaXR0ZW4gd2l0aCBlYWNoIGNhbGxcbiAgICAgICAgICAgIC8vIHRvIGV4YW1pbmVOb2RlLCBoZW5jZSBmaW5kIHRoZSBuZXh0IHNpYmxpbmcgZmlyc3QuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gbmV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBleGFtaW5lTm9kZSggY2hpbGQsIGV4ZW1wbGFyICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXRUYWdzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKFxuICAgICAgICAgICAgcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICksIGZ1bmN0aW9uICggZWwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm9kZUNvbnRhaW5lZEluUmFuZ2UoIHJhbmdlLCBlbCwgdHJ1ZSApICYmXG4gICAgICAgICAgICAgICAgICAgIGhhc1RhZ0F0dHJpYnV0ZXMoIGVsLCB0YWcsIGF0dHJpYnV0ZXMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIGlmICggIXBhcnRpYWwgKSB7XG4gICAgICAgIGZvcm1hdFRhZ3MuZm9yRWFjaCggZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgZXhhbWluZU5vZGUoIG5vZGUsIG5vZGUgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdyYXAgdW5zZWxlY3RlZCBub2RlcyBpbiB0aGUgdGFnXG4gICAgdG9XcmFwLmZvckVhY2goIGZ1bmN0aW9uICggaXRlbSApIHtcbiAgICAgICAgLy8gWyBleGVtcGxhciwgbm9kZSBdIHR1cGxlXG4gICAgICAgIHZhciBlbCA9IGl0ZW1bMF0uY2xvbmVOb2RlKCBmYWxzZSApLFxuICAgICAgICAgICAgbm9kZSA9IGl0ZW1bMV07XG4gICAgICAgIHJlcGxhY2VXaXRoKCBub2RlLCBlbCApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCggbm9kZSApO1xuICAgIH0pO1xuICAgIC8vIGFuZCByZW1vdmUgb2xkIGZvcm1hdHRpbmcgdGFncy5cbiAgICBmb3JtYXRUYWdzLmZvckVhY2goIGZ1bmN0aW9uICggZWwgKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoKCBlbCwgZW1wdHkoIGVsICkgKTtcbiAgICB9KTtcblxuICAgIC8vIE1lcmdlIGFkamFjZW50IGlubGluZXM6XG4gICAgdGhpcy5fZ2V0UmFuZ2VBbmRSZW1vdmVCb29rbWFyayggcmFuZ2UgKTtcbiAgICBpZiAoIGZpeGVyICkge1xuICAgICAgICByYW5nZS5jb2xsYXBzZSggZmFsc2UgKTtcbiAgICB9XG4gICAgbWVyZ2VJbmxpbmVzKCByb290LCByYW5nZSApO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxucHJvdG8uY2hhbmdlRm9ybWF0ID0gZnVuY3Rpb24gKCBhZGQsIHJlbW92ZSwgcmFuZ2UsIHBhcnRpYWwgKSB7XG4gICAgLy8gTm9ybWFsaXNlIHRoZSBhcmd1bWVudHMgYW5kIGdldCBzZWxlY3Rpb25cbiAgICBpZiAoICFyYW5nZSAmJiAhKCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB1bmRvIGNoZWNrcG9pbnRcbiAgICB0aGlzLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG5cbiAgICBpZiAoIHJlbW92ZSApIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl9yZW1vdmVGb3JtYXQoIHJlbW92ZS50YWcudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHJlbW92ZS5hdHRyaWJ1dGVzIHx8IHt9LCByYW5nZSwgcGFydGlhbCApO1xuICAgIH1cbiAgICBpZiAoIGFkZCApIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl9hZGRGb3JtYXQoIGFkZC50YWcudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGFkZC5hdHRyaWJ1dGVzIHx8IHt9LCByYW5nZSApO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIHRoaXMuX3VwZGF0ZVBhdGgoIHJhbmdlLCB0cnVlICk7XG5cbiAgICAvLyBXZSdyZSBub3Qgc3RpbGwgaW4gYW4gdW5kbyBzdGF0ZVxuICAgIGlmICggIWNhbk9ic2VydmVNdXRhdGlvbnMgKSB7XG4gICAgICAgIHRoaXMuX2RvY1dhc0NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIC0tLSBCbG9jayBmb3JtYXR0aW5nIC0tLVxuXG52YXIgdGFnQWZ0ZXJTcGxpdCA9IHtcbiAgICBEVDogICdERCcsXG4gICAgREQ6ICAnRFQnLFxuICAgIExJOiAgJ0xJJyxcbiAgICBQUkU6ICdQUkUnXG59O1xuXG52YXIgc3BsaXRCbG9jayA9IGZ1bmN0aW9uICggc2VsZiwgYmxvY2ssIG5vZGUsIG9mZnNldCApIHtcbiAgICB2YXIgc3BsaXRUYWcgPSB0YWdBZnRlclNwbGl0WyBibG9jay5ub2RlTmFtZSBdLFxuICAgICAgICBzcGxpdFByb3BlcnRpZXMgPSBudWxsLFxuICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IHNwbGl0KCBub2RlLCBvZmZzZXQsIGJsb2NrLnBhcmVudE5vZGUsIHNlbGYuX3Jvb3QgKSxcbiAgICAgICAgY29uZmlnID0gc2VsZi5fY29uZmlnO1xuXG4gICAgaWYgKCAhc3BsaXRUYWcgKSB7XG4gICAgICAgIHNwbGl0VGFnID0gY29uZmlnLmJsb2NrVGFnO1xuICAgICAgICBzcGxpdFByb3BlcnRpZXMgPSBjb25maWcuYmxvY2tBdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IG5vZGUgaXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAgICBpZiAoICFoYXNUYWdBdHRyaWJ1dGVzKCBub2RlQWZ0ZXJTcGxpdCwgc3BsaXRUYWcsIHNwbGl0UHJvcGVydGllcyApICkge1xuICAgICAgICBibG9jayA9IGNyZWF0ZUVsZW1lbnQoIG5vZGVBZnRlclNwbGl0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBzcGxpdFRhZywgc3BsaXRQcm9wZXJ0aWVzICk7XG4gICAgICAgIGlmICggbm9kZUFmdGVyU3BsaXQuZGlyICkge1xuICAgICAgICAgICAgYmxvY2suZGlyID0gbm9kZUFmdGVyU3BsaXQuZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VXaXRoKCBub2RlQWZ0ZXJTcGxpdCwgYmxvY2sgKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoIGVtcHR5KCBub2RlQWZ0ZXJTcGxpdCApICk7XG4gICAgICAgIG5vZGVBZnRlclNwbGl0ID0gYmxvY2s7XG4gICAgfVxuICAgIHJldHVybiBub2RlQWZ0ZXJTcGxpdDtcbn07XG5cbnByb3RvLmZvckVhY2hCbG9jayA9IGZ1bmN0aW9uICggZm4sIG11dGF0ZXMsIHJhbmdlICkge1xuICAgIGlmICggIXJhbmdlICYmICEoIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSApICkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTYXZlIHVuZG8gY2hlY2twb2ludFxuICAgIGlmICggbXV0YXRlcyApIHtcbiAgICAgICAgdGhpcy5zYXZlVW5kb1N0YXRlKCByYW5nZSApO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgc3RhcnQgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZSggcmFuZ2UsIHJvb3QgKTtcbiAgICB2YXIgZW5kID0gZ2V0RW5kQmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApO1xuICAgIGlmICggc3RhcnQgJiYgZW5kICkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIGZuKCBzdGFydCApIHx8IHN0YXJ0ID09PSBlbmQgKSB7IGJyZWFrOyB9XG4gICAgICAgIH0gd2hpbGUgKCBzdGFydCA9IGdldE5leHRCbG9jayggc3RhcnQsIHJvb3QgKSApO1xuICAgIH1cblxuICAgIGlmICggbXV0YXRlcyApIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oIHJhbmdlICk7XG5cbiAgICAgICAgLy8gUGF0aCBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhdGgoIHJhbmdlLCB0cnVlICk7XG5cbiAgICAgICAgLy8gV2UncmUgbm90IHN0aWxsIGluIGFuIHVuZG8gc3RhdGVcbiAgICAgICAgaWYgKCAhY2FuT2JzZXJ2ZU11dGF0aW9ucyApIHtcbiAgICAgICAgICAgIHRoaXMuX2RvY1dhc0NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm1vZGlmeUJsb2NrcyA9IGZ1bmN0aW9uICggbW9kaWZ5LCByYW5nZSApIHtcbiAgICBpZiAoICFyYW5nZSAmJiAhKCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gMS4gU2F2ZSB1bmRvIGNoZWNrcG9pbnQgYW5kIGJvb2ttYXJrIHNlbGVjdGlvblxuICAgIHRoaXMuX3JlY29yZFVuZG9TdGF0ZSggcmFuZ2UsIHRoaXMuX2lzSW5VbmRvU3RhdGUgKTtcblxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgZnJhZztcblxuICAgIC8vIDIuIEV4cGFuZCByYW5nZSB0byBibG9jayBib3VuZGFyaWVzXG4gICAgZXhwYW5kUmFuZ2VUb0Jsb2NrQm91bmRhcmllcyggcmFuZ2UsIHJvb3QgKTtcblxuICAgIC8vIDMuIFJlbW92ZSByYW5nZS5cbiAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzVXBUcmVlKCByYW5nZSwgcm9vdCwgcm9vdCwgcm9vdCApO1xuICAgIGZyYWcgPSBleHRyYWN0Q29udGVudHNPZlJhbmdlKCByYW5nZSwgcm9vdCwgcm9vdCApO1xuXG4gICAgLy8gNC4gTW9kaWZ5IHRyZWUgb2YgZnJhZ21lbnQgYW5kIHJlaW5zZXJ0LlxuICAgIGluc2VydE5vZGVJblJhbmdlKCByYW5nZSwgbW9kaWZ5LmNhbGwoIHRoaXMsIGZyYWcgKSApO1xuXG4gICAgLy8gNS4gTWVyZ2UgY29udGFpbmVycyBhdCBlZGdlc1xuICAgIGlmICggcmFuZ2UuZW5kT2Zmc2V0IDwgcmFuZ2UuZW5kQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuICAgICAgICBtZXJnZUNvbnRhaW5lcnMoIHJhbmdlLmVuZENvbnRhaW5lci5jaGlsZE5vZGVzWyByYW5nZS5lbmRPZmZzZXQgXSwgcm9vdCApO1xuICAgIH1cbiAgICBtZXJnZUNvbnRhaW5lcnMoIHJhbmdlLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbIHJhbmdlLnN0YXJ0T2Zmc2V0IF0sIHJvb3QgKTtcblxuICAgIC8vIDYuIFJlc3RvcmUgc2VsZWN0aW9uXG4gICAgdGhpcy5fZ2V0UmFuZ2VBbmRSZW1vdmVCb29rbWFyayggcmFuZ2UgKTtcbiAgICB0aGlzLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICB0aGlzLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuXG4gICAgLy8gNy4gV2UncmUgbm90IHN0aWxsIGluIGFuIHVuZG8gc3RhdGVcbiAgICBpZiAoICFjYW5PYnNlcnZlTXV0YXRpb25zICkge1xuICAgICAgICB0aGlzLl9kb2NXYXNDaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgaW5jcmVhc2VCbG9ja1F1b3RlTGV2ZWwgPSBmdW5jdGlvbiAoIGZyYWcgKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudCggJ0JMT0NLUVVPVEUnLFxuICAgICAgICB0aGlzLl9jb25maWcudGFnQXR0cmlidXRlcy5ibG9ja3F1b3RlLCBbXG4gICAgICAgICAgICBmcmFnXG4gICAgICAgIF0pO1xufTtcblxudmFyIGRlY3JlYXNlQmxvY2tRdW90ZUxldmVsID0gZnVuY3Rpb24gKCBmcmFnICkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgYmxvY2txdW90ZXMgPSBmcmFnLnF1ZXJ5U2VsZWN0b3JBbGwoICdibG9ja3F1b3RlJyApO1xuICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCggYmxvY2txdW90ZXMsIGZ1bmN0aW9uICggZWwgKSB7XG4gICAgICAgIHJldHVybiAhZ2V0TmVhcmVzdCggZWwucGFyZW50Tm9kZSwgcm9vdCwgJ0JMT0NLUVVPVEUnICk7XG4gICAgfSkuZm9yRWFjaCggZnVuY3Rpb24gKCBlbCApIHtcbiAgICAgICAgcmVwbGFjZVdpdGgoIGVsLCBlbXB0eSggZWwgKSApO1xuICAgIH0pO1xuICAgIHJldHVybiBmcmFnO1xufTtcblxudmFyIHJlbW92ZUJsb2NrUXVvdGUgPSBmdW5jdGlvbiAoLyogZnJhZyAqLykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZURlZmF1bHRCbG9jayhbXG4gICAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCggJ0lOUFVUJywge1xuICAgICAgICAgICAgaWQ6IHN0YXJ0U2VsZWN0aW9uSWQsXG4gICAgICAgICAgICB0eXBlOiAnaGlkZGVuJ1xuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KCAnSU5QVVQnLCB7XG4gICAgICAgICAgICBpZDogZW5kU2VsZWN0aW9uSWQsXG4gICAgICAgICAgICB0eXBlOiAnaGlkZGVuJ1xuICAgICAgICB9KVxuICAgIF0pO1xufTtcblxudmFyIG1ha2VMaXN0ID0gZnVuY3Rpb24gKCBzZWxmLCBmcmFnLCB0eXBlICkge1xuICAgIHZhciB3YWxrZXIgPSBnZXRCbG9ja1dhbGtlciggZnJhZywgc2VsZi5fcm9vdCApLFxuICAgICAgICBub2RlLCB0YWcsIHByZXYsIG5ld0xpLFxuICAgICAgICB0YWdBdHRyaWJ1dGVzID0gc2VsZi5fY29uZmlnLnRhZ0F0dHJpYnV0ZXMsXG4gICAgICAgIGxpc3RBdHRycyA9IHRhZ0F0dHJpYnV0ZXNbIHR5cGUudG9Mb3dlckNhc2UoKSBdLFxuICAgICAgICBsaXN0SXRlbUF0dHJzID0gdGFnQXR0cmlidXRlcy5saTtcblxuICAgIHdoaWxlICggbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpICkge1xuICAgICAgICBpZiAoIG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ0xJJyApIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIG5vZGUubm9kZU5hbWUgIT09ICdMSScgKSB7XG4gICAgICAgICAgICBuZXdMaSA9IHNlbGYuY3JlYXRlRWxlbWVudCggJ0xJJywgbGlzdEl0ZW1BdHRycyApO1xuICAgICAgICAgICAgaWYgKCBub2RlLmRpciApIHtcbiAgICAgICAgICAgICAgICBuZXdMaS5kaXIgPSBub2RlLmRpcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGF2ZSB3ZSByZXBsYWNlZCB0aGUgcHJldmlvdXMgYmxvY2sgd2l0aCBhIG5ldyA8dWw+LzxvbD4/XG4gICAgICAgICAgICBpZiAoICggcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nICkgJiYgcHJldi5ub2RlTmFtZSA9PT0gdHlwZSApIHtcbiAgICAgICAgICAgICAgICBwcmV2LmFwcGVuZENoaWxkKCBuZXdMaSApO1xuICAgICAgICAgICAgICAgIGRldGFjaCggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXBsYWNlIHRoaXMgYmxvY2sgd2l0aCB0aGUgPHVsPi88b2w+XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlV2l0aChcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVFbGVtZW50KCB0eXBlLCBsaXN0QXR0cnMsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0xpLmFwcGVuZENoaWxkKCBlbXB0eSggbm9kZSApICk7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBuZXdMaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB0YWcgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgaWYgKCB0YWcgIT09IHR5cGUgJiYgKCAvXltPVV1MJC8udGVzdCggdGFnICkgKSApIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlV2l0aCggbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVFbGVtZW50KCB0eXBlLCBsaXN0QXR0cnMsIFsgZW1wdHkoIG5vZGUgKSBdIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG1ha2VVbm9yZGVyZWRMaXN0ID0gZnVuY3Rpb24gKCBmcmFnICkge1xuICAgIG1ha2VMaXN0KCB0aGlzLCBmcmFnLCAnVUwnICk7XG4gICAgcmV0dXJuIGZyYWc7XG59O1xuXG52YXIgbWFrZU9yZGVyZWRMaXN0ID0gZnVuY3Rpb24gKCBmcmFnICkge1xuICAgIG1ha2VMaXN0KCB0aGlzLCBmcmFnLCAnT0wnICk7XG4gICAgcmV0dXJuIGZyYWc7XG59O1xuXG52YXIgcmVtb3ZlTGlzdCA9IGZ1bmN0aW9uICggZnJhZyApIHtcbiAgICB2YXIgbGlzdHMgPSBmcmFnLnF1ZXJ5U2VsZWN0b3JBbGwoICdVTCwgT0wnICksXG4gICAgICAgIGl0ZW1zID0gIGZyYWcucXVlcnlTZWxlY3RvckFsbCggJ0xJJyApLFxuICAgICAgICByb290ID0gdGhpcy5fcm9vdCxcbiAgICAgICAgaSwgbCwgbGlzdCwgbGlzdEZyYWcsIGl0ZW07XG4gICAgZm9yICggaSA9IDAsIGwgPSBsaXN0cy5sZW5ndGg7IGkgPCBsOyBpICs9IDEgKSB7XG4gICAgICAgIGxpc3QgPSBsaXN0c1tpXTtcbiAgICAgICAgbGlzdEZyYWcgPSBlbXB0eSggbGlzdCApO1xuICAgICAgICBmaXhDb250YWluZXIoIGxpc3RGcmFnLCByb290ICk7XG4gICAgICAgIHJlcGxhY2VXaXRoKCBsaXN0LCBsaXN0RnJhZyApO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSArPSAxICkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmICggaXNCbG9jayggaXRlbSApICkge1xuICAgICAgICAgICAgcmVwbGFjZVdpdGgoIGl0ZW0sXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0QmxvY2soWyBlbXB0eSggaXRlbSApIF0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZml4Q29udGFpbmVyKCBpdGVtLCByb290ICk7XG4gICAgICAgICAgICByZXBsYWNlV2l0aCggaXRlbSwgZW1wdHkoIGl0ZW0gKSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xufTtcblxudmFyIGdldExpc3RTZWxlY3Rpb24gPSBmdW5jdGlvbiAoIHJhbmdlLCByb290ICkge1xuICAgIC8vIEdldCBzdGFydCtlbmQgbGkgaW4gc2luZ2xlIGNvbW1vbiBhbmNlc3RvclxuICAgIHZhciBsaXN0ID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgdmFyIHN0YXJ0TGkgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgZW5kTGkgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgd2hpbGUgKCBsaXN0ICYmIGxpc3QgIT09IHJvb3QgJiYgIS9eW09VXUwkLy50ZXN0KCBsaXN0Lm5vZGVOYW1lICkgKSB7XG4gICAgICAgIGxpc3QgPSBsaXN0LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmICggIWxpc3QgfHwgbGlzdCA9PT0gcm9vdCApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICggc3RhcnRMaSA9PT0gbGlzdCApIHtcbiAgICAgICAgc3RhcnRMaSA9IHN0YXJ0TGkuY2hpbGROb2Rlc1sgcmFuZ2Uuc3RhcnRPZmZzZXQgXTtcbiAgICB9XG4gICAgaWYgKCBlbmRMaSA9PT0gbGlzdCApIHtcbiAgICAgICAgZW5kTGkgPSBlbmRMaS5jaGlsZE5vZGVzWyByYW5nZS5lbmRPZmZzZXQgXTtcbiAgICB9XG4gICAgd2hpbGUgKCBzdGFydExpICYmIHN0YXJ0TGkucGFyZW50Tm9kZSAhPT0gbGlzdCApIHtcbiAgICAgICAgc3RhcnRMaSA9IHN0YXJ0TGkucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKCBlbmRMaSAmJiBlbmRMaS5wYXJlbnROb2RlICE9PSBsaXN0ICkge1xuICAgICAgICBlbmRMaSA9IGVuZExpLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBbIGxpc3QsIHN0YXJ0TGksIGVuZExpIF07XG59O1xuXG5wcm90by5pbmNyZWFzZUxpc3RMZXZlbCA9IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG4gICAgaWYgKCAhcmFuZ2UgJiYgISggcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpICkgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBsaXN0U2VsZWN0aW9uID0gZ2V0TGlzdFNlbGVjdGlvbiggcmFuZ2UsIHJvb3QgKTtcbiAgICBpZiAoICFsaXN0U2VsZWN0aW9uICkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIHZhciBsaXN0ID0gbGlzdFNlbGVjdGlvblswXTtcbiAgICB2YXIgc3RhcnRMaSA9IGxpc3RTZWxlY3Rpb25bMV07XG4gICAgdmFyIGVuZExpID0gbGlzdFNlbGVjdGlvblsyXTtcbiAgICBpZiAoICFzdGFydExpIHx8IHN0YXJ0TGkgPT09IGxpc3QuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHVuZG8gY2hlY2twb2ludCBhbmQgYm9va21hcmsgc2VsZWN0aW9uXG4gICAgdGhpcy5fcmVjb3JkVW5kb1N0YXRlKCByYW5nZSwgdGhpcy5faXNJblVuZG9TdGF0ZSApO1xuXG4gICAgLy8gSW5jcmVhc2UgbGlzdCBkZXB0aFxuICAgIHZhciB0eXBlID0gbGlzdC5ub2RlTmFtZTtcbiAgICB2YXIgbmV3UGFyZW50ID0gc3RhcnRMaS5wcmV2aW91c1NpYmxpbmc7XG4gICAgdmFyIGxpc3RBdHRycywgbmV4dDtcbiAgICBpZiAoIG5ld1BhcmVudC5ub2RlTmFtZSAhPT0gdHlwZSApIHtcbiAgICAgICAgbGlzdEF0dHJzID0gdGhpcy5fY29uZmlnLnRhZ0F0dHJpYnV0ZXNbIHR5cGUudG9Mb3dlckNhc2UoKSBdO1xuICAgICAgICBuZXdQYXJlbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoIHR5cGUsIGxpc3RBdHRycyApO1xuICAgICAgICBsaXN0Lmluc2VydEJlZm9yZSggbmV3UGFyZW50LCBzdGFydExpICk7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgbmV4dCA9IHN0YXJ0TGkgPT09IGVuZExpID8gbnVsbCA6IHN0YXJ0TGkubmV4dFNpYmxpbmc7XG4gICAgICAgIG5ld1BhcmVudC5hcHBlbmRDaGlsZCggc3RhcnRMaSApO1xuICAgIH0gd2hpbGUgKCAoIHN0YXJ0TGkgPSBuZXh0ICkgKTtcbiAgICBuZXh0ID0gbmV3UGFyZW50Lm5leHRTaWJsaW5nO1xuICAgIGlmICggbmV4dCApIHtcbiAgICAgICAgbWVyZ2VDb250YWluZXJzKCBuZXh0LCByb290ICk7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgICB0aGlzLl9nZXRSYW5nZUFuZFJlbW92ZUJvb2ttYXJrKCByYW5nZSApO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIHRoaXMuX3VwZGF0ZVBhdGgoIHJhbmdlLCB0cnVlICk7XG5cbiAgICAvLyBXZSdyZSBub3Qgc3RpbGwgaW4gYW4gdW5kbyBzdGF0ZVxuICAgIGlmICggIWNhbk9ic2VydmVNdXRhdGlvbnMgKSB7XG4gICAgICAgIHRoaXMuX2RvY1dhc0NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb2N1cygpO1xufTtcblxucHJvdG8uZGVjcmVhc2VMaXN0TGV2ZWwgPSBmdW5jdGlvbiAoIHJhbmdlICkge1xuICAgIGlmICggIXJhbmdlICYmICEoIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSApICkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgbGlzdFNlbGVjdGlvbiA9IGdldExpc3RTZWxlY3Rpb24oIHJhbmdlLCByb290ICk7XG4gICAgaWYgKCAhbGlzdFNlbGVjdGlvbiApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdCA9IGxpc3RTZWxlY3Rpb25bMF07XG4gICAgdmFyIHN0YXJ0TGkgPSBsaXN0U2VsZWN0aW9uWzFdO1xuICAgIHZhciBlbmRMaSA9IGxpc3RTZWxlY3Rpb25bMl07XG4gICAgdmFyIG5ld1BhcmVudCwgbmV4dCwgaW5zZXJ0QmVmb3JlLCBtYWtlTm90TGlzdDtcbiAgICBpZiAoICFzdGFydExpICkge1xuICAgICAgICBzdGFydExpID0gbGlzdC5maXJzdENoaWxkO1xuICAgIH1cbiAgICBpZiAoICFlbmRMaSApIHtcbiAgICAgICAgZW5kTGkgPSBsaXN0Lmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHVuZG8gY2hlY2twb2ludCBhbmQgYm9va21hcmsgc2VsZWN0aW9uXG4gICAgdGhpcy5fcmVjb3JkVW5kb1N0YXRlKCByYW5nZSwgdGhpcy5faXNJblVuZG9TdGF0ZSApO1xuXG4gICAgaWYgKCBzdGFydExpICkge1xuICAgICAgICAvLyBGaW5kIHRoZSBuZXcgcGFyZW50IGxpc3Qgbm9kZVxuICAgICAgICBuZXdQYXJlbnQgPSBsaXN0LnBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gU3BsaXQgbGlzdCBpZiBuZWNlc2FyeVxuICAgICAgICBpbnNlcnRCZWZvcmUgPSAhZW5kTGkubmV4dFNpYmxpbmcgP1xuICAgICAgICAgICAgbGlzdC5uZXh0U2libGluZyA6XG4gICAgICAgICAgICBzcGxpdCggbGlzdCwgZW5kTGkubmV4dFNpYmxpbmcsIG5ld1BhcmVudCwgcm9vdCApO1xuXG4gICAgICAgIGlmICggbmV3UGFyZW50ICE9PSByb290ICYmIG5ld1BhcmVudC5ub2RlTmFtZSA9PT0gJ0xJJyApIHtcbiAgICAgICAgICAgIG5ld1BhcmVudCA9IG5ld1BhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKCBpbnNlcnRCZWZvcmUgKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGluc2VydEJlZm9yZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbmRMaS5hcHBlbmRDaGlsZCggaW5zZXJ0QmVmb3JlICk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydEJlZm9yZSA9IGxpc3QucGFyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIG1ha2VOb3RMaXN0ID0gIS9eW09VXUwkLy50ZXN0KCBuZXdQYXJlbnQubm9kZU5hbWUgKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmV4dCA9IHN0YXJ0TGkgPT09IGVuZExpID8gbnVsbCA6IHN0YXJ0TGkubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBsaXN0LnJlbW92ZUNoaWxkKCBzdGFydExpICk7XG4gICAgICAgICAgICBpZiAoIG1ha2VOb3RMaXN0ICYmIHN0YXJ0TGkubm9kZU5hbWUgPT09ICdMSScgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaSA9IHRoaXMuY3JlYXRlRGVmYXVsdEJsb2NrKFsgZW1wdHkoIHN0YXJ0TGkgKSBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1BhcmVudC5pbnNlcnRCZWZvcmUoIHN0YXJ0TGksIGluc2VydEJlZm9yZSApO1xuICAgICAgICB9IHdoaWxlICgoIHN0YXJ0TGkgPSBuZXh0ICkpO1xuICAgIH1cblxuICAgIGlmICggIWxpc3QuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgZGV0YWNoKCBsaXN0ICk7XG4gICAgfVxuXG4gICAgaWYgKCBpbnNlcnRCZWZvcmUgKSB7XG4gICAgICAgIG1lcmdlQ29udGFpbmVycyggaW5zZXJ0QmVmb3JlLCByb290ICk7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgICB0aGlzLl9nZXRSYW5nZUFuZFJlbW92ZUJvb2ttYXJrKCByYW5nZSApO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIHRoaXMuX3VwZGF0ZVBhdGgoIHJhbmdlLCB0cnVlICk7XG5cbiAgICAvLyBXZSdyZSBub3Qgc3RpbGwgaW4gYW4gdW5kbyBzdGF0ZVxuICAgIGlmICggIWNhbk9ic2VydmVNdXRhdGlvbnMgKSB7XG4gICAgICAgIHRoaXMuX2RvY1dhc0NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb2N1cygpO1xufTtcblxucHJvdG8uX2Vuc3VyZUJvdHRvbUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBsYXN0ID0gcm9vdC5sYXN0RWxlbWVudENoaWxkO1xuICAgIGlmICggIWxhc3QgfHxcbiAgICAgICAgICAgIGxhc3Qubm9kZU5hbWUgIT09IHRoaXMuX2NvbmZpZy5ibG9ja1RhZyB8fCAhaXNCbG9jayggbGFzdCApICkge1xuICAgICAgICByb290LmFwcGVuZENoaWxkKCB0aGlzLmNyZWF0ZURlZmF1bHRCbG9jaygpICk7XG4gICAgfVxufTtcblxuLy8gLS0tIEtleWJvYXJkIGludGVyYWN0aW9uIC0tLVxuXG5wcm90by5zZXRLZXlIYW5kbGVyID0gZnVuY3Rpb24gKCBrZXksIGZuICkge1xuICAgIHRoaXMuX2tleUhhbmRsZXJzWyBrZXkgXSA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gLS0tIEdldC9TZXQgZGF0YSAtLS1cblxucHJvdG8uX2dldEhUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QuaW5uZXJIVE1MO1xufTtcblxucHJvdG8uX3NldEhUTUwgPSBmdW5jdGlvbiAoIGh0bWwgKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgZG8ge1xuICAgICAgICBmaXhDdXJzb3IoIG5vZGUsIHJvb3QgKTtcbiAgICB9IHdoaWxlICggbm9kZSA9IGdldE5leHRCbG9jayggbm9kZSwgcm9vdCApICk7XG4gICAgdGhpcy5faWdub3JlQ2hhbmdlID0gdHJ1ZTtcbn07XG5cbnByb3RvLmdldEhUTUwgPSBmdW5jdGlvbiAoIHdpdGhCb29rTWFyayApIHtcbiAgICB2YXIgYnJzID0gW10sXG4gICAgICAgIHJvb3QsIG5vZGUsIGZpeGVyLCBodG1sLCBsLCByYW5nZTtcbiAgICBpZiAoIHdpdGhCb29rTWFyayAmJiAoIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSApICkge1xuICAgICAgICB0aGlzLl9zYXZlUmFuZ2VUb0Jvb2ttYXJrKCByYW5nZSApO1xuICAgIH1cbiAgICBpZiAoIHVzZVRleHRGaXhlciApIHtcbiAgICAgICAgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIG5vZGUgPSByb290O1xuICAgICAgICB3aGlsZSAoIG5vZGUgPSBnZXROZXh0QmxvY2soIG5vZGUsIHJvb3QgKSApIHtcbiAgICAgICAgICAgIGlmICggIW5vZGUudGV4dENvbnRlbnQgJiYgIW5vZGUucXVlcnlTZWxlY3RvciggJ0JSJyApICkge1xuICAgICAgICAgICAgICAgIGZpeGVyID0gdGhpcy5jcmVhdGVFbGVtZW50KCAnQlInICk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCggZml4ZXIgKTtcbiAgICAgICAgICAgICAgICBicnMucHVzaCggZml4ZXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBodG1sID0gdGhpcy5fZ2V0SFRNTCgpLnJlcGxhY2UoIC9cXHUyMDBCL2csICcnICk7XG4gICAgaWYgKCB1c2VUZXh0Rml4ZXIgKSB7XG4gICAgICAgIGwgPSBicnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgICAgIGRldGFjaCggYnJzW2xdICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCByYW5nZSApIHtcbiAgICAgICAgdGhpcy5fZ2V0UmFuZ2VBbmRSZW1vdmVCb29rbWFyayggcmFuZ2UgKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59O1xuXG5wcm90by5zZXRIVE1MID0gZnVuY3Rpb24gKCBodG1sICkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdmFyIHNhbml0aXplVG9ET01GcmFnbWVudCA9IGNvbmZpZy5pc1NldEhUTUxTYW5pdGl6ZWQgP1xuICAgICAgICAgICAgY29uZmlnLnNhbml0aXplVG9ET01GcmFnbWVudCA6IG51bGw7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBkaXYsIGZyYWcsIGNoaWxkO1xuXG4gICAgLy8gUGFyc2UgSFRNTCBpbnRvIERPTSB0cmVlXG4gICAgaWYgKCB0eXBlb2Ygc2FuaXRpemVUb0RPTUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBmcmFnID0gc2FuaXRpemVUb0RPTUZyYWdtZW50KCBodG1sLCBmYWxzZSwgdGhpcyApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdiA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ0RJVicgKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIGZyYWcgPSB0aGlzLl9kb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKCBlbXB0eSggZGl2ICkgKTtcbiAgICB9XG5cbiAgICBjbGVhblRyZWUoIGZyYWcsIGNvbmZpZyApO1xuICAgIGNsZWFudXBCUnMoIGZyYWcsIHJvb3QsIGZhbHNlICk7XG5cbiAgICBmaXhDb250YWluZXIoIGZyYWcsIHJvb3QgKTtcblxuICAgIC8vIEZpeCBjdXJzb3JcbiAgICB2YXIgbm9kZSA9IGZyYWc7XG4gICAgd2hpbGUgKCBub2RlID0gZ2V0TmV4dEJsb2NrKCBub2RlLCByb290ICkgKSB7XG4gICAgICAgIGZpeEN1cnNvciggbm9kZSwgcm9vdCApO1xuICAgIH1cblxuICAgIC8vIERvbid0IGZpcmUgYW4gaW5wdXQgZXZlbnRcbiAgICB0aGlzLl9pZ25vcmVDaGFuZ2UgPSB0cnVlO1xuXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHJvb3QgY2hpbGRyZW5cbiAgICB3aGlsZSAoIGNoaWxkID0gcm9vdC5sYXN0Q2hpbGQgKSB7XG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoIGNoaWxkICk7XG4gICAgfVxuXG4gICAgLy8gQW5kIGluc2VydCBuZXcgY29udGVudFxuICAgIHJvb3QuYXBwZW5kQ2hpbGQoIGZyYWcgKTtcbiAgICBmaXhDdXJzb3IoIHJvb3QsIHJvb3QgKTtcblxuICAgIC8vIFJlc2V0IHRoZSB1bmRvIHN0YWNrXG4gICAgdGhpcy5fdW5kb0luZGV4ID0gLTE7XG4gICAgdGhpcy5fdW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdW5kb1N0YWNrTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9pc0luVW5kb1N0YXRlID0gZmFsc2U7XG5cbiAgICAvLyBSZWNvcmQgdW5kbyBzdGF0ZVxuICAgIHZhciByYW5nZSA9IHRoaXMuX2dldFJhbmdlQW5kUmVtb3ZlQm9va21hcmsoKSB8fFxuICAgICAgICB0aGlzLmNyZWF0ZVJhbmdlKCByb290LmZpcnN0Q2hpbGQsIDAgKTtcbiAgICB0aGlzLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG4gICAgLy8gSUUgd2lsbCBhbHNvIHNldCBmb2N1cyB3aGVuIHNlbGVjdGluZyB0ZXh0IHNvIGRvbid0IHVzZVxuICAgIC8vIHNldFNlbGVjdGlvbi4gSW5zdGVhZCwganVzdCBzdG9yZSBpdCBpbiBsYXN0U2VsZWN0aW9uLCBzbyBpZlxuICAgIC8vIGFueXRoaW5nIGNhbGxzIGdldFNlbGVjdGlvbiBiZWZvcmUgZmlyc3QgZm9jdXMsIHdlIGhhdmUgYSByYW5nZVxuICAgIC8vIHRvIHJldHVybi5cbiAgICB0aGlzLl9sYXN0U2VsZWN0aW9uID0gcmFuZ2U7XG4gICAgZW5hYmxlUmVzdG9yZVNlbGVjdGlvbi5jYWxsKCB0aGlzICk7XG4gICAgdGhpcy5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uaW5zZXJ0RWxlbWVudCA9IGZ1bmN0aW9uICggZWwsIHJhbmdlICkge1xuICAgIGlmICggIXJhbmdlICkge1xuICAgICAgICByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJhbmdlLmNvbGxhcHNlKCB0cnVlICk7XG4gICAgaWYgKCBpc0lubGluZSggZWwgKSApIHtcbiAgICAgICAgaW5zZXJ0Tm9kZUluUmFuZ2UoIHJhbmdlLCBlbCApO1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKCBlbCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBjb250YWluaW5nIGJsb2NrIG5vZGUuXG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICAgICAgdmFyIHNwbGl0Tm9kZSA9IGdldFN0YXJ0QmxvY2tPZlJhbmdlKCByYW5nZSwgcm9vdCApIHx8IHJvb3Q7XG4gICAgICAgIHZhciBwYXJlbnQsIG5vZGVBZnRlclNwbGl0O1xuICAgICAgICAvLyBXaGlsZSBhdCBlbmQgb2YgY29udGFpbmVyIG5vZGUsIG1vdmUgdXAgRE9NIHRyZWUuXG4gICAgICAgIHdoaWxlICggc3BsaXROb2RlICE9PSByb290ICYmICFzcGxpdE5vZGUubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICBzcGxpdE5vZGUgPSBzcGxpdE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpbiB0aGUgbWlkZGxlIG9mIGEgY29udGFpbmVyIG5vZGUsIHNwbGl0IHVwIHRvIHJvb3QuXG4gICAgICAgIGlmICggc3BsaXROb2RlICE9PSByb290ICkge1xuICAgICAgICAgICAgcGFyZW50ID0gc3BsaXROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IHNwbGl0KCBwYXJlbnQsIHNwbGl0Tm9kZS5uZXh0U2libGluZywgcm9vdCwgcm9vdCApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbm9kZUFmdGVyU3BsaXQgKSB7XG4gICAgICAgICAgICByb290Lmluc2VydEJlZm9yZSggZWwsIG5vZGVBZnRlclNwbGl0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKCBlbCApO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGJsYW5rIGxpbmUgYmVsb3cgYmxvY2suXG4gICAgICAgICAgICBub2RlQWZ0ZXJTcGxpdCA9IHRoaXMuY3JlYXRlRGVmYXVsdEJsb2NrKCk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKCBub2RlQWZ0ZXJTcGxpdCApO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KCBub2RlQWZ0ZXJTcGxpdCwgMCApO1xuICAgICAgICByYW5nZS5zZXRFbmQoIG5vZGVBZnRlclNwbGl0LCAwICk7XG4gICAgICAgIG1vdmVSYW5nZUJvdW5kYXJpZXNEb3duVHJlZSggcmFuZ2UgKTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cygpO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgIHRoaXMuX3VwZGF0ZVBhdGgoIHJhbmdlICk7XG5cbiAgICBpZiAoICFjYW5PYnNlcnZlTXV0YXRpb25zICkge1xuICAgICAgICB0aGlzLl9kb2NXYXNDaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5pbnNlcnRJbWFnZSA9IGZ1bmN0aW9uICggc3JjLCBhdHRyaWJ1dGVzICkge1xuICAgIHZhciBpbWcgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoICdJTUcnLCBtZXJnZU9iamVjdHMoe1xuICAgICAgICBzcmM6IHNyY1xuICAgIH0sIGF0dHJpYnV0ZXMsIHRydWUgKSk7XG4gICAgdGhpcy5pbnNlcnRFbGVtZW50KCBpbWcgKTtcbiAgICByZXR1cm4gaW1nO1xufTtcblxucHJvdG8ubGlua1JlZ0V4cCA9IC9cXGIoKD86KD86aHR8Zil0cHM/OlxcL1xcL3x3d3dcXGR7MCwzfVsuXXxbYS16MC05LlxcLV0rWy5dW2Etel17Mix9XFwvKSg/OlteXFxzKCk8Pl0rfFxcKFteXFxzKCk8Pl0rXFwpKSsoPzpcXCgoPzpbXlxccygpPD5dK3woPzpcXChbXlxccygpPD5dK1xcKSkpKlxcKXxbXlxcc2AhKClcXFtcXF17fTs6J1wiLiw8Pj/Cq8K74oCc4oCd4oCY4oCZXSkpfChbXFx3XFwtLiUrXStAKD86W1xcd1xcLV0rXFwuKStbQS1aXXsyLH1cXGIpKD86XFw/W14mP1xcc10rPVteJj9cXHNdKyg/OiZbXiY/XFxzXSs9W14mP1xcc10rKSopPy9pO1xuXG52YXIgYWRkTGlua3MgPSBmdW5jdGlvbiAoIGZyYWcsIHJvb3QsIHNlbGYgKSB7XG4gICAgdmFyIGRvYyA9IGZyYWcub3duZXJEb2N1bWVudDtcbiAgICB2YXIgd2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoIGZyYWcsIFNIT1dfVEVYVCwgZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICByZXR1cm4gIWdldE5lYXJlc3QoIG5vZGUsIHJvb3QsICdBJyApO1xuICAgIH0pO1xuICAgIHZhciBsaW5rUmVnRXhwID0gc2VsZi5saW5rUmVnRXhwO1xuICAgIHZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHNlbGYuX2NvbmZpZy50YWdBdHRyaWJ1dGVzLmE7XG4gICAgdmFyIG5vZGUsIGRhdGEsIHBhcmVudCwgbWF0Y2gsIGluZGV4LCBlbmRJbmRleCwgY2hpbGQ7XG4gICAgaWYgKCAhbGlua1JlZ0V4cCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAoKCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCkgKSkge1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlICgoIG1hdGNoID0gbGlua1JlZ0V4cC5leGVjKCBkYXRhICkgKSkge1xuICAgICAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIGluZGV4ICkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gZG9jLmNyZWF0ZVRleHROb2RlKCBkYXRhLnNsaWNlKCAwLCBpbmRleCApICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSggY2hpbGQsIG5vZGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gc2VsZi5jcmVhdGVFbGVtZW50KCAnQScsIG1lcmdlT2JqZWN0cyh7XG4gICAgICAgICAgICAgICAgaHJlZjogbWF0Y2hbMV0gP1xuICAgICAgICAgICAgICAgICAgICAvXig/Omh0fGYpdHBzPzovaS50ZXN0KCBtYXRjaFsxXSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwOi8vJyArIG1hdGNoWzFdIDpcbiAgICAgICAgICAgICAgICAgICAgJ21haWx0bzonICsgbWF0Y2hbMF1cbiAgICAgICAgICAgIH0sIGRlZmF1bHRBdHRyaWJ1dGVzLCBmYWxzZSApKTtcbiAgICAgICAgICAgIGNoaWxkLnRleHRDb250ZW50ID0gZGF0YS5zbGljZSggaW5kZXgsIGVuZEluZGV4ICk7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBjaGlsZCwgbm9kZSApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YSA9IGRhdGEuc2xpY2UoIGVuZEluZGV4ICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBJbnNlcnQgSFRNTCBhdCB0aGUgY3Vyc29yIGxvY2F0aW9uLiBJZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBjb2xsYXBzZWRcbi8vIGluc2VydFRyZWVGcmFnbWVudEludG9SYW5nZSB3aWxsIGRlbGV0ZSB0aGUgc2VsZWN0aW9uIHNvIHRoYXQgaXQgaXMgcmVwbGFjZWRcbi8vIGJ5IHRoZSBodG1sIGJlaW5nIGluc2VydGVkLlxucHJvdG8uaW5zZXJ0SFRNTCA9IGZ1bmN0aW9uICggaHRtbCwgaXNQYXN0ZSApIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHZhciBzYW5pdGl6ZVRvRE9NRnJhZ21lbnQgPSBjb25maWcuaXNJbnNlcnRlZEhUTUxTYW5pdGl6ZWQgP1xuICAgICAgICAgICAgY29uZmlnLnNhbml0aXplVG9ET01GcmFnbWVudCA6IG51bGw7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgZG9jID0gdGhpcy5fZG9jO1xuICAgIHZhciBzdGFydEZyYWdtZW50SW5kZXgsIGVuZEZyYWdtZW50SW5kZXg7XG4gICAgdmFyIGRpdiwgZnJhZywgcm9vdCwgbm9kZSwgZXZlbnQ7XG5cbiAgICAvLyBFZGdlIGRvZXNuJ3QganVzdCBjb3B5IHRoZSBmcmFnbWVudCwgYnV0IGluY2x1ZGVzIHRoZSBzdXJyb3VuZGluZyBndWZmXG4gICAgLy8gaW5jbHVkaW5nIHRoZSBmdWxsIDxoZWFkPiBvZiB0aGUgcGFnZS4gTmVlZCB0byBzdHJpcCB0aGlzIG91dC4gSWZcbiAgICAvLyBhdmFpbGFibGUgdXNlIERPTVB1cmlmeSB0byBwYXJzZSBhbmQgc2FuaXRpc2UuXG4gICAgaWYgKCB0eXBlb2Ygc2FuaXRpemVUb0RPTUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBmcmFnID0gc2FuaXRpemVUb0RPTUZyYWdtZW50KCBodG1sLCBpc1Bhc3RlLCB0aGlzICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCBpc1Bhc3RlICkge1xuICAgICAgICAgICAgc3RhcnRGcmFnbWVudEluZGV4ID0gaHRtbC5pbmRleE9mKCAnPCEtLVN0YXJ0RnJhZ21lbnQtLT4nICk7XG4gICAgICAgICAgICBlbmRGcmFnbWVudEluZGV4ID0gaHRtbC5sYXN0SW5kZXhPZiggJzwhLS1FbmRGcmFnbWVudC0tPicgKTtcbiAgICAgICAgICAgIGlmICggc3RhcnRGcmFnbWVudEluZGV4ID4gLTEgJiYgZW5kRnJhZ21lbnRJbmRleCA+IC0xICkge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLnNsaWNlKCBzdGFydEZyYWdtZW50SW5kZXggKyAyMCwgZW5kRnJhZ21lbnRJbmRleCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXAgd2l0aCA8dHI+IGlmIGh0bWwgY29udGFpbnMgZGFuZ2xpbmcgPHRkPiB0YWdzXG4gICAgICAgIGlmICggLzxcXC90ZD4oKD8hPFxcL3RyPilbXFxzXFxTXSkqJC9pLnRlc3QoIGh0bWwgKSApIHtcbiAgICAgICAgICAgIGh0bWwgPSAnPFRSPicgKyBodG1sICsgJzwvVFI+JztcbiAgICAgICAgfVxuICAgICAgICAvLyBXcmFwIHdpdGggPHRhYmxlPiBpZiBodG1sIGNvbnRhaW5zIGRhbmdsaW5nIDx0cj4gdGFnc1xuICAgICAgICBpZiAoIC88XFwvdHI+KCg/ITxcXC90YWJsZT4pW1xcc1xcU10pKiQvaS50ZXN0KCBodG1sICkgKSB7XG4gICAgICAgICAgICBodG1sID0gJzxUQUJMRT4nICsgaHRtbCArICc8L1RBQkxFPic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgSFRNTCBpbnRvIERPTSB0cmVlXG4gICAgICAgIGRpdiA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ0RJVicgKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIGZyYWcgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKCBlbXB0eSggZGl2ICkgKTtcbiAgICB9XG5cbiAgICAvLyBSZWNvcmQgdW5kbyBjaGVja3BvaW50XG4gICAgdGhpcy5zYXZlVW5kb1N0YXRlKCByYW5nZSApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIG5vZGUgPSBmcmFnO1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlua3MoIGZyYWcsIGZyYWcsIHRoaXMgKTtcbiAgICAgICAgY2xlYW5UcmVlKCBmcmFnLCBjb25maWcgKTtcbiAgICAgICAgY2xlYW51cEJScyggZnJhZywgcm9vdCwgZmFsc2UgKTtcbiAgICAgICAgcmVtb3ZlRW1wdHlJbmxpbmVzKCBmcmFnICk7XG4gICAgICAgIGZyYWcubm9ybWFsaXplKCk7XG5cbiAgICAgICAgd2hpbGUgKCBub2RlID0gZ2V0TmV4dEJsb2NrKCBub2RlLCBmcmFnICkgKSB7XG4gICAgICAgICAgICBmaXhDdXJzb3IoIG5vZGUsIHJvb3QgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaXNQYXN0ZSApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCAnd2lsbFBhc3RlJywgZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7XG4gICAgICAgICAgICBpbnNlcnRUcmVlRnJhZ21lbnRJbnRvUmFuZ2UoIHJhbmdlLCBldmVudC5mcmFnbWVudCwgcm9vdCApO1xuICAgICAgICAgICAgaWYgKCAhY2FuT2JzZXJ2ZU11dGF0aW9ucyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2NXYXNDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSggZmFsc2UgKTtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUJvdHRvbUxpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKCByYW5nZSApO1xuICAgICAgICB0aGlzLl91cGRhdGVQYXRoKCByYW5nZSwgdHJ1ZSApO1xuICAgICAgICAvLyBTYWZhcmkgc29tZXRpbWVzIGxvc2VzIGZvY3VzIGFmdGVyIHBhc3RlLiBXZWlyZC5cbiAgICAgICAgaWYgKCBpc1Bhc3RlICkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xuICAgICAgICB0aGlzLmRpZEVycm9yKCBlcnJvciApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBlc2NhcGVIVE1MRnJhZ2VtZW50ID0gZnVuY3Rpb24gKCB0ZXh0ICkge1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCAnJicgKS5qb2luKCAnJmFtcDsnIClcbiAgICAgICAgICAgICAgIC5zcGxpdCggJzwnICkuam9pbiggJyZsdDsnICApXG4gICAgICAgICAgICAgICAuc3BsaXQoICc+JyApLmpvaW4oICcmZ3Q7JyAgKVxuICAgICAgICAgICAgICAgLnNwbGl0KCAnXCInICkuam9pbiggJyZxdW90OycgICk7XG59O1xuXG5wcm90by5pbnNlcnRQbGFpblRleHQgPSBmdW5jdGlvbiAoIHBsYWluVGV4dCwgaXNQYXN0ZSApIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICggcmFuZ2UuY29sbGFwc2VkICYmXG4gICAgICAgICAgICBnZXROZWFyZXN0KCByYW5nZS5zdGFydENvbnRhaW5lciwgdGhpcy5fcm9vdCwgJ1BSRScgKSApIHtcbiAgICAgICAgdmFyIG5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICB2YXIgdGV4dCwgZXZlbnQ7XG4gICAgICAgIGlmICggIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICkge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuX2RvYy5jcmVhdGVUZXh0Tm9kZSggJycgKTtcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKCB0ZXh0LCBub2RlLmNoaWxkTm9kZXNbIG9mZnNldCBdICk7XG4gICAgICAgICAgICBub2RlID0gdGV4dDtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICB0ZXh0OiBwbGFpblRleHQsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCBpc1Bhc3RlICkge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoICd3aWxsUGFzdGUnLCBldmVudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHtcbiAgICAgICAgICAgIHBsYWluVGV4dCA9IGV2ZW50LnRleHQ7XG4gICAgICAgICAgICBub2RlLmluc2VydERhdGEoIG9mZnNldCwgcGxhaW5UZXh0ICk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydCggbm9kZSwgb2Zmc2V0ICsgcGxhaW5UZXh0Lmxlbmd0aCApO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoIHRydWUgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbiggcmFuZ2UgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBsaW5lcyA9IHBsYWluVGV4dC5zcGxpdCggJ1xcbicgKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHZhciB0YWcgPSBjb25maWcuYmxvY2tUYWc7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBjb25maWcuYmxvY2tBdHRyaWJ1dGVzO1xuICAgIHZhciBjbG9zZUJsb2NrICA9ICc8LycgKyB0YWcgKyAnPic7XG4gICAgdmFyIG9wZW5CbG9jayA9ICc8JyArIHRhZztcbiAgICB2YXIgYXR0ciwgaSwgbCwgbGluZTtcblxuICAgIGZvciAoIGF0dHIgaW4gYXR0cmlidXRlcyApIHtcbiAgICAgICAgb3BlbkJsb2NrICs9ICcgJyArIGF0dHIgKyAnPVwiJyArXG4gICAgICAgICAgICBlc2NhcGVIVE1MRnJhZ2VtZW50KCBhdHRyaWJ1dGVzWyBhdHRyIF0gKSArXG4gICAgICAgICdcIic7XG4gICAgfVxuICAgIG9wZW5CbG9jayArPSAnPic7XG5cbiAgICBmb3IgKCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSApIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBsaW5lID0gZXNjYXBlSFRNTEZyYWdlbWVudCggbGluZSApLnJlcGxhY2UoIC8gKD89ICkvZywgJyZuYnNwOycgKTtcbiAgICAgICAgLy8gV3JhcCBlYWNoIGxpbmUgaW4gPGRpdj48L2Rpdj5cbiAgICAgICAgbGluZXNbaV0gPSBvcGVuQmxvY2sgKyAoIGxpbmUgfHwgJzxCUj4nICkgKyBjbG9zZUJsb2NrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnNlcnRIVE1MKCBsaW5lcy5qb2luKCAnJyApLCBpc1Bhc3RlICk7XG59O1xuXG4vLyAtLS0gRm9ybWF0dGluZyAtLS1cblxudmFyIGNvbW1hbmQgPSBmdW5jdGlvbiAoIG1ldGhvZCwgYXJnLCBhcmcyICkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNbIG1ldGhvZCBdKCBhcmcsIGFyZzIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbiAgICB9O1xufTtcblxucHJvdG8uYWRkU3R5bGVzID0gZnVuY3Rpb24gKCBzdHlsZXMgKSB7XG4gICAgaWYgKCBzdHlsZXMgKSB7XG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5fZG9jLmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoICdTVFlMRScsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dC9jc3MnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoIHRoaXMuX2RvYy5jcmVhdGVUZXh0Tm9kZSggc3R5bGVzICkgKTtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZCggc3R5bGUgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5ib2xkID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIHsgdGFnOiAnQicgfSApO1xucHJvdG8uaXRhbGljID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIHsgdGFnOiAnSScgfSApO1xucHJvdG8udW5kZXJsaW5lID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIHsgdGFnOiAnVScgfSApO1xucHJvdG8uc3RyaWtldGhyb3VnaCA9IGNvbW1hbmQoICdjaGFuZ2VGb3JtYXQnLCB7IHRhZzogJ1MnIH0gKTtcbnByb3RvLnN1YnNjcmlwdCA9IGNvbW1hbmQoICdjaGFuZ2VGb3JtYXQnLCB7IHRhZzogJ1NVQicgfSwgeyB0YWc6ICdTVVAnIH0gKTtcbnByb3RvLnN1cGVyc2NyaXB0ID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIHsgdGFnOiAnU1VQJyB9LCB7IHRhZzogJ1NVQicgfSApO1xuXG5wcm90by5yZW1vdmVCb2xkID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIG51bGwsIHsgdGFnOiAnQicgfSApO1xucHJvdG8ucmVtb3ZlSXRhbGljID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIG51bGwsIHsgdGFnOiAnSScgfSApO1xucHJvdG8ucmVtb3ZlVW5kZXJsaW5lID0gY29tbWFuZCggJ2NoYW5nZUZvcm1hdCcsIG51bGwsIHsgdGFnOiAnVScgfSApO1xucHJvdG8ucmVtb3ZlU3RyaWtldGhyb3VnaCA9IGNvbW1hbmQoICdjaGFuZ2VGb3JtYXQnLCBudWxsLCB7IHRhZzogJ1MnIH0gKTtcbnByb3RvLnJlbW92ZVN1YnNjcmlwdCA9IGNvbW1hbmQoICdjaGFuZ2VGb3JtYXQnLCBudWxsLCB7IHRhZzogJ1NVQicgfSApO1xucHJvdG8ucmVtb3ZlU3VwZXJzY3JpcHQgPSBjb21tYW5kKCAnY2hhbmdlRm9ybWF0JywgbnVsbCwgeyB0YWc6ICdTVVAnIH0gKTtcblxucHJvdG8ubWFrZUxpbmsgPSBmdW5jdGlvbiAoIHVybCwgYXR0cmlidXRlcyApIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICggcmFuZ2UuY29sbGFwc2VkICkge1xuICAgICAgICB2YXIgcHJvdG9jb2xFbmQgPSB1cmwuaW5kZXhPZiggJzonICkgKyAxO1xuICAgICAgICBpZiAoIHByb3RvY29sRW5kICkge1xuICAgICAgICAgICAgd2hpbGUgKCB1cmxbIHByb3RvY29sRW5kIF0gPT09ICcvJyApIHsgcHJvdG9jb2xFbmQgKz0gMTsgfVxuICAgICAgICB9XG4gICAgICAgIGluc2VydE5vZGVJblJhbmdlKFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICB0aGlzLl9kb2MuY3JlYXRlVGV4dE5vZGUoIHVybC5zbGljZSggcHJvdG9jb2xFbmQgKSApXG4gICAgICAgICk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSBtZXJnZU9iamVjdHMoXG4gICAgICAgIG1lcmdlT2JqZWN0cyh7XG4gICAgICAgICAgICBocmVmOiB1cmxcbiAgICAgICAgfSwgYXR0cmlidXRlcywgdHJ1ZSApLFxuICAgICAgICB0aGlzLl9jb25maWcudGFnQXR0cmlidXRlcy5hLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICB0aGlzLmNoYW5nZUZvcm1hdCh7XG4gICAgICAgIHRhZzogJ0EnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgfSwge1xuICAgICAgICB0YWc6ICdBJ1xuICAgIH0sIHJhbmdlICk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5wcm90by5yZW1vdmVMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2hhbmdlRm9ybWF0KCBudWxsLCB7XG4gICAgICAgIHRhZzogJ0EnXG4gICAgfSwgdGhpcy5nZXRTZWxlY3Rpb24oKSwgdHJ1ZSApO1xuICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG59O1xuXG5wcm90by5zZXRGb250RmFjZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZXMuZm9udEZhbWlseTtcbiAgICB0aGlzLmNoYW5nZUZvcm1hdCggbmFtZSA/IHtcbiAgICAgICAgdGFnOiAnU1BBTicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiAnZm9udC1mYW1pbHk6ICcgKyBuYW1lICsgJywgc2Fucy1zZXJpZjsnXG4gICAgICAgIH1cbiAgICB9IDogbnVsbCwge1xuICAgICAgICB0YWc6ICdTUEFOJyxcbiAgICAgICAgYXR0cmlidXRlczogeyAnY2xhc3MnOiBjbGFzc05hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG59O1xucHJvdG8uc2V0Rm9udFNpemUgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWVzLmZvbnRTaXplO1xuICAgIHRoaXMuY2hhbmdlRm9ybWF0KCBzaXplID8ge1xuICAgICAgICB0YWc6ICdTUEFOJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU6ICdmb250LXNpemU6ICcgK1xuICAgICAgICAgICAgICAgICggdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSArICdweCcgOiBzaXplIClcbiAgICAgICAgfVxuICAgIH0gOiBudWxsLCB7XG4gICAgICAgIHRhZzogJ1NQQU4nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7ICdjbGFzcyc6IGNsYXNzTmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbnByb3RvLnNldFRleHRDb2xvdXIgPSBmdW5jdGlvbiAoIGNvbG91ciApIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZXMuY29sb3VyO1xuICAgIHRoaXMuY2hhbmdlRm9ybWF0KCBjb2xvdXIgPyB7XG4gICAgICAgIHRhZzogJ1NQQU4nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnY2xhc3MnOiBjbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogJ2NvbG9yOicgKyBjb2xvdXJcbiAgICAgICAgfVxuICAgIH0gOiBudWxsLCB7XG4gICAgICAgIHRhZzogJ1NQQU4nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7ICdjbGFzcyc6IGNsYXNzTmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbnByb3RvLnNldEhpZ2hsaWdodENvbG91ciA9IGZ1bmN0aW9uICggY29sb3VyICkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHQ7XG4gICAgdGhpcy5jaGFuZ2VGb3JtYXQoIGNvbG91ciA/IHtcbiAgICAgICAgdGFnOiAnU1BBTicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiAnYmFja2dyb3VuZC1jb2xvcjonICsgY29sb3VyXG4gICAgICAgIH1cbiAgICB9IDogY29sb3VyLCB7XG4gICAgICAgIHRhZzogJ1NQQU4nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7ICdjbGFzcyc6IGNsYXNzTmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbnByb3RvLnNldFRleHRBbGlnbm1lbnQgPSBmdW5jdGlvbiAoIGFsaWdubWVudCApIHtcbiAgICB0aGlzLmZvckVhY2hCbG9jayggZnVuY3Rpb24gKCBibG9jayApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJsb2NrLmNsYXNzTmFtZVxuICAgICAgICAgICAgLnNwbGl0KCAvXFxzKy8gKVxuICAgICAgICAgICAgLmZpbHRlciggZnVuY3Rpb24gKCBrbGFzcyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFrbGFzcyAmJiAhL15hbGlnbi8udGVzdCgga2xhc3MgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbiggJyAnICk7XG4gICAgICAgIGlmICggYWxpZ25tZW50ICkge1xuICAgICAgICAgICAgYmxvY2suY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJyBhbGlnbi0nICsgYWxpZ25tZW50O1xuICAgICAgICAgICAgYmxvY2suc3R5bGUudGV4dEFsaWduID0gYWxpZ25tZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgYmxvY2suc3R5bGUudGV4dEFsaWduID0gJyc7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlICk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbnByb3RvLnNldFRleHREaXJlY3Rpb24gPSBmdW5jdGlvbiAoIGRpcmVjdGlvbiApIHtcbiAgICB0aGlzLmZvckVhY2hCbG9jayggZnVuY3Rpb24gKCBibG9jayApIHtcbiAgICAgICAgaWYgKCBkaXJlY3Rpb24gKSB7XG4gICAgICAgICAgICBibG9jay5kaXIgPSBkaXJlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9jay5yZW1vdmVBdHRyaWJ1dGUoICdkaXInICk7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlICk7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbi8vIC0tLVxuXG52YXIgYWRkUHJlID0gZnVuY3Rpb24gKCBmcmFnICkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLl9kb2M7XG4gICAgdmFyIG91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgd2Fsa2VyID0gZ2V0QmxvY2tXYWxrZXIoIGZyYWcsIHJvb3QgKTtcbiAgICB2YXIgbm9kZTtcbiAgICAvLyAxLiBFeHRyYWN0IGlubGluZSBjb250ZW50OyBkcm9wIGFsbCBibG9ja3MgYW5kIGNvbnRhaW5zLlxuICAgIHdoaWxlICgoIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSApKSB7XG4gICAgICAgIC8vIDIuIFJlcGxhY2UgPGJyPiB3aXRoIFxcbiBpbiBjb250ZW50XG4gICAgICAgIHZhciBub2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCggJ0JSJyApO1xuICAgICAgICB2YXIgYnJCcmVha3NMaW5lID0gW107XG4gICAgICAgIHZhciBsID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaSwgYnI7XG5cbiAgICAgICAgLy8gTXVzdCBjYWxjdWxhdGUgd2hldGhlciB0aGUgPGJyPiBicmVha3MgYSBsaW5lIGZpcnN0LCBiZWNhdXNlIGlmIHdlXG4gICAgICAgIC8vIGhhdmUgdHdvIDxicj5zIG5leHQgdG8gZWFjaCBvdGhlciwgYWZ0ZXIgdGhlIGZpcnN0IG9uZSBpcyBjb252ZXJ0ZWRcbiAgICAgICAgLy8gdG8gYSBibG9jayBzcGxpdCwgdGhlIHNlY29uZCB3aWxsIGJlIGF0IHRoZSBlbmQgb2YgYSBibG9jayBhbmRcbiAgICAgICAgLy8gdGhlcmVmb3JlIHNlZW0gdG8gbm90IGJlIGEgbGluZSBicmVhay4gQnV0IGluIGl0cyBvcmlnaW5hbCBjb250ZXh0IGl0XG4gICAgICAgIC8vIHdhcywgc28gd2Ugc2hvdWxkIGFsc28gY29udmVydCBpdCB0byBhIGJsb2NrIHNwbGl0LlxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGw7IGkgKz0gMSApIHtcbiAgICAgICAgICAgIGJyQnJlYWtzTGluZVtpXSA9IGlzTGluZUJyZWFrKCBub2Rlc1tpXSwgZmFsc2UgKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgICAgIGJyID0gbm9kZXNbbF07XG4gICAgICAgICAgICBpZiAoICFickJyZWFrc0xpbmVbbF0gKSB7XG4gICAgICAgICAgICAgICAgZGV0YWNoKCBiciApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlV2l0aCggYnIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCAnXFxuJyApICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gUmVtb3ZlIDxjb2RlPjsgaXRzIGZvcm1hdCBjbGFzaGVzIHdpdGggPHByZT5cbiAgICAgICAgbm9kZXMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoICdDT0RFJyApO1xuICAgICAgICBsID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgICAgIGRldGFjaCggbm9kZXNbbF0gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIG91dHB1dC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIG91dHB1dC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoICdcXG4nICkgKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoIGVtcHR5KCBub2RlICkgKTtcbiAgICB9XG4gICAgLy8gNC4gUmVwbGFjZSBuYnNwIHdpdGggcmVndWxhciBzcFxuICAgIHdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKCBvdXRwdXQsIFNIT1dfVEVYVCApO1xuICAgIHdoaWxlICgoIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSApKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5yZXBsYWNlKCAvIC9nLCAnICcgKTsgLy8gbmJzcCAtPiBzcFxuICAgIH1cbiAgICBvdXRwdXQubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIGZpeEN1cnNvciggdGhpcy5jcmVhdGVFbGVtZW50KCAnUFJFJyxcbiAgICAgICAgdGhpcy5fY29uZmlnLnRhZ0F0dHJpYnV0ZXMucHJlLCBbXG4gICAgICAgICAgICBvdXRwdXRcbiAgICAgICAgXSksIHJvb3QgKTtcbn07XG5cbnZhciByZW1vdmVQcmUgPSBmdW5jdGlvbiAoIGZyYWcgKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5fZG9jO1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcHJlcyA9IGZyYWcucXVlcnlTZWxlY3RvckFsbCggJ1BSRScgKTtcbiAgICB2YXIgbCA9IHByZXMubGVuZ3RoO1xuICAgIHZhciBwcmUsIHdhbGtlciwgbm9kZSwgdmFsdWUsIGNvbnRlbnRzLCBpbmRleDtcbiAgICB3aGlsZSAoIGwtLSApIHtcbiAgICAgICAgcHJlID0gcHJlc1tsXTtcbiAgICAgICAgd2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIoIHByZSwgU0hPV19URVhUICk7XG4gICAgICAgIHdoaWxlICgoIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSggLyAoPz0gKS9nLCAnICcgKTsgLy8gc3AgLT4gbmJzcFxuICAgICAgICAgICAgY29udGVudHMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAoKCBpbmRleCA9IHZhbHVlLmluZGV4T2YoICdcXG4nICkgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdmFsdWUuc2xpY2UoIDAsIGluZGV4ICkgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdCUicgKSApO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoIGluZGV4ICsgMSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggY29udGVudHMsIG5vZGUgKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZpeENvbnRhaW5lciggcHJlLCByb290ICk7XG4gICAgICAgIHJlcGxhY2VXaXRoKCBwcmUsIGVtcHR5KCBwcmUgKSApO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbn07XG5cbnByb3RvLmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIHJhbmdlLmNvbGxhcHNlZCB8fCBpc0NvbnRhaW5lciggcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgKSApIHtcbiAgICAgICAgdGhpcy5tb2RpZnlCbG9ja3MoIGFkZFByZSwgcmFuZ2UgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoYW5nZUZvcm1hdCh7XG4gICAgICAgICAgICB0YWc6ICdDT0RFJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2NvbmZpZy50YWdBdHRyaWJ1dGVzLmNvZGVcbiAgICAgICAgfSwgbnVsbCwgcmFuZ2UgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbn07XG5cbnByb3RvLnJlbW92ZUNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgYW5jZXN0b3IgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB2YXIgaW5QcmUgPSBnZXROZWFyZXN0KCBhbmNlc3RvciwgdGhpcy5fcm9vdCwgJ1BSRScgKTtcbiAgICBpZiAoIGluUHJlICkge1xuICAgICAgICB0aGlzLm1vZGlmeUJsb2NrcyggcmVtb3ZlUHJlLCByYW5nZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRm9ybWF0KCBudWxsLCB7IHRhZzogJ0NPREUnIH0sIHJhbmdlICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG59O1xuXG5wcm90by50b2dnbGVDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggdGhpcy5oYXNGb3JtYXQoICdQUkUnICkgfHwgdGhpcy5oYXNGb3JtYXQoICdDT0RFJyApICkge1xuICAgICAgICB0aGlzLnJlbW92ZUNvZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyAtLS1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZyAoIHNlbGYsIHJvb3QsIGNsZWFuICkge1xuICAgIHZhciBub2RlLCBuZXh0O1xuICAgIGZvciAoIG5vZGUgPSByb290LmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBuZXh0ICkge1xuICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCBpc0lubGluZSggbm9kZSApICkge1xuICAgICAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ0JSJyB8fCBub2RlLm5vZGVOYW1lID09PSAnSU1HJyApIHtcbiAgICAgICAgICAgICAgICBjbGVhbi5hcHBlbmRDaGlsZCggbm9kZSApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCBpc0Jsb2NrKCBub2RlICkgKSB7XG4gICAgICAgICAgICBjbGVhbi5hcHBlbmRDaGlsZCggc2VsZi5jcmVhdGVEZWZhdWx0QmxvY2soW1xuICAgICAgICAgICAgICAgIHJlbW92ZUZvcm1hdHRpbmcoXG4gICAgICAgICAgICAgICAgICAgIHNlbGYsIG5vZGUsIHNlbGYuX2RvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlRm9ybWF0dGluZyggc2VsZiwgbm9kZSwgY2xlYW4gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuO1xufVxuXG5wcm90by5yZW1vdmVBbGxGb3JtYXR0aW5nID0gZnVuY3Rpb24gKCByYW5nZSApIHtcbiAgICBpZiAoICFyYW5nZSAmJiAhKCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkgKSB8fCByYW5nZS5jb2xsYXBzZWQgKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgc3RvcE5vZGUgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB3aGlsZSAoIHN0b3BOb2RlICYmICFpc0Jsb2NrKCBzdG9wTm9kZSApICkge1xuICAgICAgICBzdG9wTm9kZSA9IHN0b3BOb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmICggIXN0b3BOb2RlICkge1xuICAgICAgICBleHBhbmRSYW5nZVRvQmxvY2tCb3VuZGFyaWVzKCByYW5nZSwgcm9vdCApO1xuICAgICAgICBzdG9wTm9kZSA9IHJvb3Q7XG4gICAgfVxuICAgIGlmICggc3RvcE5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIHVuZG8gcG9pbnRcbiAgICB0aGlzLnNhdmVVbmRvU3RhdGUoIHJhbmdlICk7XG5cbiAgICAvLyBBdm9pZCBzcGxpdHRpbmcgd2hlcmUgd2UncmUgYWxyZWFkeSBhdCBlZGdlcy5cbiAgICBtb3ZlUmFuZ2VCb3VuZGFyaWVzVXBUcmVlKCByYW5nZSwgc3RvcE5vZGUsIHN0b3BOb2RlLCByb290ICk7XG5cbiAgICAvLyBTcGxpdCB0aGUgc2VsZWN0aW9uIHVwIHRvIHRoZSBibG9jaywgb3IgaWYgd2hvbGUgc2VsZWN0aW9uIGluIHNhbWVcbiAgICAvLyBibG9jaywgZXhwYW5kIHJhbmdlIGJvdW5kYXJpZXMgdG8gZW5kcyBvZiBibG9jayBhbmQgc3BsaXQgdXAgdG8gcm9vdC5cbiAgICB2YXIgZG9jID0gc3RvcE5vZGUub3duZXJEb2N1bWVudDtcbiAgICB2YXIgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICB2YXIgZW5kQ29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgIHZhciBlbmRPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG5cbiAgICAvLyBTcGxpdCBlbmQgcG9pbnQgZmlyc3QgdG8gYXZvaWQgcHJvYmxlbXMgd2hlbiBlbmQgYW5kIHN0YXJ0XG4gICAgLy8gaW4gc2FtZSBjb250YWluZXIuXG4gICAgdmFyIGZvcm1hdHRlZE5vZGVzID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgY2xlYW5Ob2RlcyA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIG5vZGVBZnRlclNwbGl0ID0gc3BsaXQoIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0LCBzdG9wTm9kZSwgcm9vdCApO1xuICAgIHZhciBub2RlSW5TcGxpdCA9IHNwbGl0KCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHN0b3BOb2RlLCByb290ICk7XG4gICAgdmFyIG5leHROb2RlLCBjaGlsZE5vZGVzO1xuXG4gICAgLy8gVGhlbiByZXBsYWNlIGNvbnRlbnRzIGluIHNwbGl0IHdpdGggYSBjbGVhbmVkIHZlcnNpb24gb2YgdGhlIHNhbWU6XG4gICAgLy8gYmxvY2tzIGJlY29tZSBkZWZhdWx0IGJsb2NrcywgdGV4dCBhbmQgbGVhZiBub2RlcyBzdXJ2aXZlLCBldmVyeXRoaW5nXG4gICAgLy8gZWxzZSBpcyBvYmxpdGVyYXRlZC5cbiAgICB3aGlsZSAoIG5vZGVJblNwbGl0ICE9PSBub2RlQWZ0ZXJTcGxpdCApIHtcbiAgICAgICAgbmV4dE5vZGUgPSBub2RlSW5TcGxpdC5uZXh0U2libGluZztcbiAgICAgICAgZm9ybWF0dGVkTm9kZXMuYXBwZW5kQ2hpbGQoIG5vZGVJblNwbGl0ICk7XG4gICAgICAgIG5vZGVJblNwbGl0ID0gbmV4dE5vZGU7XG4gICAgfVxuICAgIHJlbW92ZUZvcm1hdHRpbmcoIHRoaXMsIGZvcm1hdHRlZE5vZGVzLCBjbGVhbk5vZGVzICk7XG4gICAgY2xlYW5Ob2Rlcy5ub3JtYWxpemUoKTtcbiAgICBub2RlSW5TcGxpdCA9IGNsZWFuTm9kZXMuZmlyc3RDaGlsZDtcbiAgICBuZXh0Tm9kZSA9IGNsZWFuTm9kZXMubGFzdENoaWxkO1xuXG4gICAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgICBjaGlsZE5vZGVzID0gc3RvcE5vZGUuY2hpbGROb2RlcztcbiAgICBpZiAoIG5vZGVJblNwbGl0ICkge1xuICAgICAgICBzdG9wTm9kZS5pbnNlcnRCZWZvcmUoIGNsZWFuTm9kZXMsIG5vZGVBZnRlclNwbGl0ICk7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gaW5kZXhPZi5jYWxsKCBjaGlsZE5vZGVzLCBub2RlSW5TcGxpdCApO1xuICAgICAgICBlbmRPZmZzZXQgPSBpbmRleE9mLmNhbGwoIGNoaWxkTm9kZXMsIG5leHROb2RlICkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gaW5kZXhPZi5jYWxsKCBjaGlsZE5vZGVzLCBub2RlQWZ0ZXJTcGxpdCApO1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSB0ZXh0IG5vZGVzIGF0IGVkZ2VzLCBpZiBwb3NzaWJsZVxuICAgIHJhbmdlLnNldFN0YXJ0KCBzdG9wTm9kZSwgc3RhcnRPZmZzZXQgKTtcbiAgICByYW5nZS5zZXRFbmQoIHN0b3BOb2RlLCBlbmRPZmZzZXQgKTtcbiAgICBtZXJnZUlubGluZXMoIHN0b3BOb2RlLCByYW5nZSApO1xuXG4gICAgLy8gQW5kIG1vdmUgYmFjayBkb3duIHRoZSB0cmVlXG4gICAgbW92ZVJhbmdlQm91bmRhcmllc0Rvd25UcmVlKCByYW5nZSApO1xuXG4gICAgdGhpcy5zZXRTZWxlY3Rpb24oIHJhbmdlICk7XG4gICAgdGhpcy5fdXBkYXRlUGF0aCggcmFuZ2UsIHRydWUgKTtcblxuICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG59O1xuXG5wcm90by5pbmNyZWFzZVF1b3RlTGV2ZWwgPSBjb21tYW5kKCAnbW9kaWZ5QmxvY2tzJywgaW5jcmVhc2VCbG9ja1F1b3RlTGV2ZWwgKTtcbnByb3RvLmRlY3JlYXNlUXVvdGVMZXZlbCA9IGNvbW1hbmQoICdtb2RpZnlCbG9ja3MnLCBkZWNyZWFzZUJsb2NrUXVvdGVMZXZlbCApO1xuXG5wcm90by5tYWtlVW5vcmRlcmVkTGlzdCA9IGNvbW1hbmQoICdtb2RpZnlCbG9ja3MnLCBtYWtlVW5vcmRlcmVkTGlzdCApO1xucHJvdG8ubWFrZU9yZGVyZWRMaXN0ID0gY29tbWFuZCggJ21vZGlmeUJsb2NrcycsIG1ha2VPcmRlcmVkTGlzdCApO1xucHJvdG8ucmVtb3ZlTGlzdCA9IGNvbW1hbmQoICdtb2RpZnlCbG9ja3MnLCByZW1vdmVMaXN0ICk7XG5cbi8vIE5vZGUuanMgZXhwb3J0c1xuU3F1aXJlLmlzSW5saW5lID0gaXNJbmxpbmU7XG5TcXVpcmUuaXNCbG9jayA9IGlzQmxvY2s7XG5TcXVpcmUuaXNDb250YWluZXIgPSBpc0NvbnRhaW5lcjtcblNxdWlyZS5nZXRCbG9ja1dhbGtlciA9IGdldEJsb2NrV2Fsa2VyO1xuU3F1aXJlLmdldFByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrO1xuU3F1aXJlLmdldE5leHRCbG9jayA9IGdldE5leHRCbG9jaztcblNxdWlyZS5hcmVBbGlrZSA9IGFyZUFsaWtlO1xuU3F1aXJlLmhhc1RhZ0F0dHJpYnV0ZXMgPSBoYXNUYWdBdHRyaWJ1dGVzO1xuU3F1aXJlLmdldE5lYXJlc3QgPSBnZXROZWFyZXN0O1xuU3F1aXJlLmlzT3JDb250YWlucyA9IGlzT3JDb250YWlucztcblNxdWlyZS5kZXRhY2ggPSBkZXRhY2g7XG5TcXVpcmUucmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aDtcblNxdWlyZS5lbXB0eSA9IGVtcHR5O1xuXG4vLyBSYW5nZS5qcyBleHBvcnRzXG5TcXVpcmUuZ2V0Tm9kZUJlZm9yZSA9IGdldE5vZGVCZWZvcmU7XG5TcXVpcmUuZ2V0Tm9kZUFmdGVyID0gZ2V0Tm9kZUFmdGVyO1xuU3F1aXJlLmluc2VydE5vZGVJblJhbmdlID0gaW5zZXJ0Tm9kZUluUmFuZ2U7XG5TcXVpcmUuZXh0cmFjdENvbnRlbnRzT2ZSYW5nZSA9IGV4dHJhY3RDb250ZW50c09mUmFuZ2U7XG5TcXVpcmUuZGVsZXRlQ29udGVudHNPZlJhbmdlID0gZGVsZXRlQ29udGVudHNPZlJhbmdlO1xuU3F1aXJlLmluc2VydFRyZWVGcmFnbWVudEludG9SYW5nZSA9IGluc2VydFRyZWVGcmFnbWVudEludG9SYW5nZTtcblNxdWlyZS5pc05vZGVDb250YWluZWRJblJhbmdlID0gaXNOb2RlQ29udGFpbmVkSW5SYW5nZTtcblNxdWlyZS5tb3ZlUmFuZ2VCb3VuZGFyaWVzRG93blRyZWUgPSBtb3ZlUmFuZ2VCb3VuZGFyaWVzRG93blRyZWU7XG5TcXVpcmUubW92ZVJhbmdlQm91bmRhcmllc1VwVHJlZSA9IG1vdmVSYW5nZUJvdW5kYXJpZXNVcFRyZWU7XG5TcXVpcmUuZ2V0U3RhcnRCbG9ja09mUmFuZ2UgPSBnZXRTdGFydEJsb2NrT2ZSYW5nZTtcblNxdWlyZS5nZXRFbmRCbG9ja09mUmFuZ2UgPSBnZXRFbmRCbG9ja09mUmFuZ2U7XG5TcXVpcmUuY29udGVudFdhbGtlciA9IGNvbnRlbnRXYWxrZXI7XG5TcXVpcmUucmFuZ2VEb2VzU3RhcnRBdEJsb2NrQm91bmRhcnkgPSByYW5nZURvZXNTdGFydEF0QmxvY2tCb3VuZGFyeTtcblNxdWlyZS5yYW5nZURvZXNFbmRBdEJsb2NrQm91bmRhcnkgPSByYW5nZURvZXNFbmRBdEJsb2NrQm91bmRhcnk7XG5TcXVpcmUuZXhwYW5kUmFuZ2VUb0Jsb2NrQm91bmRhcmllcyA9IGV4cGFuZFJhbmdlVG9CbG9ja0JvdW5kYXJpZXM7XG5cbi8vIENsaXBib2FyZC5qcyBleHBvcnRzXG5TcXVpcmUub25QYXN0ZSA9IG9uUGFzdGU7XG5cbi8vIEVkaXRvci5qcyBleHBvcnRzXG5TcXVpcmUuYWRkTGlua3MgPSBhZGRMaW5rcztcblNxdWlyZS5zcGxpdEJsb2NrID0gc3BsaXRCbG9jaztcblNxdWlyZS5zdGFydFNlbGVjdGlvbklkID0gc3RhcnRTZWxlY3Rpb25JZDtcblNxdWlyZS5lbmRTZWxlY3Rpb25JZCA9IGVuZFNlbGVjdGlvbklkO1xuXG5pZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNxdWlyZTtcbn0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNxdWlyZTtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgd2luLlNxdWlyZSA9IFNxdWlyZTtcblxuICAgIGlmICggdG9wICE9PSB3aW4gJiZcbiAgICAgICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1zcXVpcmVpbml0JyApID09PSAndHJ1ZScgKSB7XG4gICAgICAgIHdpbi5lZGl0b3IgPSBuZXcgU3F1aXJlKCBkb2MgKTtcbiAgICAgICAgaWYgKCB3aW4ub25FZGl0b3JMb2FkICkge1xuICAgICAgICAgICAgd2luLm9uRWRpdG9yTG9hZCggd2luLmVkaXRvciApO1xuICAgICAgICAgICAgd2luLm9uRWRpdG9yTG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbn0oIGRvY3VtZW50ICkgKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/resources/write/squire.js\n");

/***/ }),

/***/ "./src/resources/write/write.css":
/*!***************************************!*\
  !*** ./src/resources/write/write.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!./write.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\nif (true) {\n  if (!content.locals) {\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js!./write.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css\",\n      function () {\n        var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!./write.css */ \"./node_modules/css-loader/dist/cjs.js!./src/resources/write/write.css\");\n\n        if (typeof newContent === 'string') {\n          newContent = [[module.i, newContent, '']];\n        }\n        \n        update(newContent);\n      }\n    )\n  }\n\n  module.hot.dispose(function() { \n    update();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL3dyaXRlLmNzcz9lZGY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyx3SUFBNEQ7O0FBRWxGO0FBQ0EsY0FBYyxRQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlKQUE4RTs7QUFFbkc7QUFDQTtBQUNBOztBQUVBLElBQUksSUFBVTtBQUNkO0FBQ0E7QUFDQSxNQUFNLHdJQUE0RDtBQUNsRTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLHdJQUE0RDs7QUFFN0Y7QUFDQSx5QkFBeUIsUUFBUztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQztBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vc3JjL3Jlc291cmNlcy93cml0ZS93cml0ZS5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vd3JpdGUuY3NzXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2Fscykge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vd3JpdGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi93cml0ZS5jc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgXG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/resources/write/write.css\n");

/***/ }),

/***/ "./src/resources/write/write.js":
/*!**************************************!*\
  !*** ./src/resources/write/write.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("$(function () {\n  $(\".write_form\").submit(function (e) {\n    e.preventDefault();\n    var form = $(this).get(0);\n    var url = Constants.URL_CREATE_POST;\n    var btnSubmit = $('button.submit');\n    var data = new FormData(form);\n    var summaryBlob = new Blob([oEditorSum.getHTML()], {\n      type: \"text/xml\"\n    });\n    var contentBlob = new Blob([oEditorConts.getHTML()], {\n      type: \"text/xml\"\n    });\n    data.append('summary_file', summaryBlob);\n    data.append('content_file', contentBlob);\n    console.log(\"전송할 데이터 \\n\", ...data);\n    btnSubmit.prop('disabled', true);\n    $.ajax({\n      type: \"POST\",\n      url,\n      data,\n      enctype: 'multipart/form-data',\n      processData: false,\n      contentType: false,\n      cache: false,\n      success: function (data) {\n        page('/');\n      },\n      done: function (data) {\n        btnSubmit.prop('disabled', false);\n      }\n    });\n  });\n\n  function toggleBold() {\n    const bold = $(this).data('bold');\n    bold ? oEditor.bold() : oEditor.removeBold();\n    $(this).data('bold', !bold);\n  }\n\n  function toggleUnderline() {\n    const underline = $(this).data('underline');\n    underline ? oEditor.underline() : oEditor.removeUnderline();\n    $(this).data('underline', !underline);\n  }\n\n  function getImage(input) {\n    if (input.files && input.files[0]) {\n      if (/\\.(jpe?g|png|gif)$/i.test(input.files[0].name)) {\n        const reader = new FileReader();\n\n        reader.onload = function (e) {\n          oEditor.insertImage(reader.result, {\n            class: 'inserted_image'\n          });\n          input.value = \"\";\n        };\n\n        reader.readAsDataURL(input.files[0]);\n      } else {\n        alert('png, gif, jpg 파일만 업로드 가능합니다');\n      }\n    }\n  }\n\n  const $target = $('.write_cont');\n  const oEditorSum = new Squire($target.get(0), {\n    blockTag: 'P',\n    blockAttributes: {\n      style: 'font-size: 16px;',\n      class: \"summary\"\n    }\n  });\n  const oEditorConts = new Squire($target.get(1), {\n    blockTag: 'P',\n    blockAttributes: {\n      style: 'font-size: 16px;',\n      class: \"contents\"\n    }\n  });\n  let oEditor = oEditorSum;\n  $('.write_cont').click(function (e) {\n    const $target = $(e.delegateTarget);\n    const index = $('.write_cont').index($target);\n    oEditor = index === 0 ? oEditorSum : oEditorConts;\n  });\n  $('.colorpicker').each(function () {\n    $(this).minicolors({\n      control: $(this).attr('data-control') || 'hue',\n      defaultValue: $(this).attr('data-defaultValue') || '#000',\n      format: $(this).attr('data-format') || 'hex',\n      keywords: $(this).attr('data-keywords') || '',\n      inline: $(this).attr('data-inline') === 'true',\n      letterCase: $(this).attr('data-letterCase') || 'lowercase',\n      opacity: $(this).attr('data-opacity'),\n      position: $(this).attr('data-position') || 'bottom',\n      swatches: $(this).attr('data-swatches') ? $(this).attr('data-swatches').split('|') : [],\n      change: function (hex, opacity) {\n        var log;\n\n        try {\n          log = hex ? hex : '#000';\n          oEditor.setTextColour(log);\n          if (opacity) log += ', ' + opacity;\n          console.log(log);\n        } catch (e) {}\n      },\n      theme: 'default',\n      position: 'top bottom'\n    });\n  });\n  $('body').on('click', '.inserted_image', function (e) {\n    $(e.target).toggleClass('on');\n  });\n  $('.fontsize').on('blur keyup', 'input', function (e) {\n    if (e.type === \"keyup\" && e.keyCode != 13) return;\n    oEditor.setFontSize($(e.target).val() + 'px');\n    e.preventDefault();\n  });\n  $('.bold').click(toggleBold);\n  $('.underline').click(toggleUnderline);\n  $('.ordered').click(function () {\n    oEditor.makeOrderedList();\n  });\n  $('.unordered').click(function () {\n    oEditor.makeUnorderedList();\n  });\n  $('.indent').click(function () {\n    oEditor.increaseListLevel();\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL3dyaXRlL3dyaXRlLmpzPzdmMjgiXSwibmFtZXMiOlsiJCIsInN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImZvcm0iLCJnZXQiLCJ1cmwiLCJDb25zdGFudHMiLCJVUkxfQ1JFQVRFX1BPU1QiLCJidG5TdWJtaXQiLCJkYXRhIiwiRm9ybURhdGEiLCJzdW1tYXJ5QmxvYiIsIkJsb2IiLCJvRWRpdG9yU3VtIiwiZ2V0SFRNTCIsInR5cGUiLCJjb250ZW50QmxvYiIsIm9FZGl0b3JDb250cyIsImFwcGVuZCIsImNvbnNvbGUiLCJsb2ciLCJwcm9wIiwiYWpheCIsImVuY3R5cGUiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiY2FjaGUiLCJzdWNjZXNzIiwicGFnZSIsImRvbmUiLCJ0b2dnbGVCb2xkIiwiYm9sZCIsIm9FZGl0b3IiLCJyZW1vdmVCb2xkIiwidG9nZ2xlVW5kZXJsaW5lIiwidW5kZXJsaW5lIiwicmVtb3ZlVW5kZXJsaW5lIiwiZ2V0SW1hZ2UiLCJpbnB1dCIsImZpbGVzIiwidGVzdCIsIm5hbWUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiaW5zZXJ0SW1hZ2UiLCJyZXN1bHQiLCJjbGFzcyIsInZhbHVlIiwicmVhZEFzRGF0YVVSTCIsImFsZXJ0IiwiJHRhcmdldCIsIlNxdWlyZSIsImJsb2NrVGFnIiwiYmxvY2tBdHRyaWJ1dGVzIiwic3R5bGUiLCJjbGljayIsImRlbGVnYXRlVGFyZ2V0IiwiaW5kZXgiLCJlYWNoIiwibWluaWNvbG9ycyIsImNvbnRyb2wiLCJhdHRyIiwiZGVmYXVsdFZhbHVlIiwiZm9ybWF0Iiwia2V5d29yZHMiLCJpbmxpbmUiLCJsZXR0ZXJDYXNlIiwib3BhY2l0eSIsInBvc2l0aW9uIiwic3dhdGNoZXMiLCJzcGxpdCIsImNoYW5nZSIsImhleCIsInNldFRleHRDb2xvdXIiLCJ0aGVtZSIsIm9uIiwidGFyZ2V0IiwidG9nZ2xlQ2xhc3MiLCJrZXlDb2RlIiwic2V0Rm9udFNpemUiLCJ2YWwiLCJtYWtlT3JkZXJlZExpc3QiLCJtYWtlVW5vcmRlcmVkTGlzdCIsImluY3JlYXNlTGlzdExldmVsIl0sIm1hcHBpbmdzIjoiQUFBQUEsQ0FBQyxDQUFDLFlBQVk7QUFFZEEsR0FBQyxDQUFDLGFBQUQsQ0FBRCxDQUFpQkMsTUFBakIsQ0FBd0IsVUFBVUMsQ0FBVixFQUFhO0FBQ25DQSxLQUFDLENBQUNDLGNBQUY7QUFDQSxRQUFJQyxJQUFJLEdBQUdKLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUUssR0FBUixDQUFZLENBQVosQ0FBWDtBQUNBLFFBQUlDLEdBQUcsR0FBR0MsU0FBUyxDQUFDQyxlQUFwQjtBQUNBLFFBQUlDLFNBQVMsR0FBR1QsQ0FBQyxDQUFDLGVBQUQsQ0FBakI7QUFFQSxRQUFJVSxJQUFJLEdBQUcsSUFBSUMsUUFBSixDQUFhUCxJQUFiLENBQVg7QUFDQSxRQUFJUSxXQUFXLEdBQUcsSUFBSUMsSUFBSixDQUFTLENBQUNDLFVBQVUsQ0FBQ0MsT0FBWCxFQUFELENBQVQsRUFBaUM7QUFBRUMsVUFBSSxFQUFFO0FBQVIsS0FBakMsQ0FBbEI7QUFDQSxRQUFJQyxXQUFXLEdBQUcsSUFBSUosSUFBSixDQUFTLENBQUNLLFlBQVksQ0FBQ0gsT0FBYixFQUFELENBQVQsRUFBbUM7QUFBRUMsVUFBSSxFQUFFO0FBQVIsS0FBbkMsQ0FBbEI7QUFDQU4sUUFBSSxDQUFDUyxNQUFMLENBQVksY0FBWixFQUE0QlAsV0FBNUI7QUFDQUYsUUFBSSxDQUFDUyxNQUFMLENBQVksY0FBWixFQUE0QkYsV0FBNUI7QUFDQUcsV0FBTyxDQUFDQyxHQUFSLENBQVksWUFBWixFQUEwQixHQUFHWCxJQUE3QjtBQUVBRCxhQUFTLENBQUNhLElBQVYsQ0FBZSxVQUFmLEVBQTJCLElBQTNCO0FBRUF0QixLQUFDLENBQUN1QixJQUFGLENBQU87QUFDTFAsVUFBSSxFQUFFLE1BREQ7QUFDU1YsU0FEVDtBQUNjSSxVQURkO0FBRUxjLGFBQU8sRUFBRSxxQkFGSjtB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aUIxQixVQUFqQjtBQUVBL0IsR0FBQyxDQUFDLFlBQUQsQ0FBRCxDQUFnQnlELEtBQWhCLENBQXNCdEIsZUFBdEI7QUFFQW5DLEdBQUMsQ0FBQyxVQUFELENBQUQsQ0FBY3lELEtBQWQsQ0FBb0IsWUFBWTtBQUM5QnhCLFdBQU8sQ0FBQ2tELGVBQVI7QUFDRCxHQUZEO0FBSUFuRixHQUFDLENBQUMsWUFBRCxDQUFELENBQWdCeUQsS0FBaEIsQ0FBc0IsWUFBWTtBQUNoQ3hCLFdBQU8sQ0FBQ21ELGlCQUFSO0FBQ0QsR0FGRDtBQUlBcEYsR0FBQyxDQUFDLFNBQUQsQ0FBRCxDQUFheUQsS0FBYixDQUFtQixZQUFZO0FBQzdCeEIsV0FBTyxDQUFDb0QsaUJBQVI7QUFDRCxHQUZEO0FBSUQsQ0F0SUEsQ0FBRCIsImZpbGUiOiIuL3NyYy9yZXNvdXJjZXMvd3JpdGUvd3JpdGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIkKGZ1bmN0aW9uICgpIHtcblxuJChcIi53cml0ZV9mb3JtXCIpLnN1Ym1pdChmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciBmb3JtID0gJCh0aGlzKS5nZXQoMCk7XG4gIHZhciB1cmwgPSBDb25zdGFudHMuVVJMX0NSRUFURV9QT1NUO1xuICB2YXIgYnRuU3VibWl0ID0gJCgnYnV0dG9uLnN1Ym1pdCcpO1xuXG4gIHZhciBkYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xuICB2YXIgc3VtbWFyeUJsb2IgPSBuZXcgQmxvYihbb0VkaXRvclN1bS5nZXRIVE1MKCldLCB7IHR5cGU6IFwidGV4dC94bWxcIiB9KTtcbiAgdmFyIGNvbnRlbnRCbG9iID0gbmV3IEJsb2IoW29FZGl0b3JDb250cy5nZXRIVE1MKCldLCB7IHR5cGU6IFwidGV4dC94bWxcIiB9KTtcbiAgZGF0YS5hcHBlbmQoJ3N1bW1hcnlfZmlsZScsIHN1bW1hcnlCbG9iKTtcbiAgZGF0YS5hcHBlbmQoJ2NvbnRlbnRfZmlsZScsIGNvbnRlbnRCbG9iKTtcbiAgY29uc29sZS5sb2coXCLsoITshqHtlaAg642w7J207YSwIFxcblwiLCAuLi5kYXRhKTtcblxuICBidG5TdWJtaXQucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcblxuICAkLmFqYXgoe1xuICAgIHR5cGU6IFwiUE9TVFwiLCB1cmwsIGRhdGEsXG4gICAgZW5jdHlwZTogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgIHByb2Nlc3NEYXRhOiBmYWxzZSwgY29udGVudFR5cGU6IGZhbHNlLCBjYWNoZTogZmFsc2UsXG4gICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHBhZ2UoJy8nKTtcbiAgICB9LFxuICAgIGRvbmU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBidG5TdWJtaXQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcblxufSk7XG5cbmZ1bmN0aW9uIHRvZ2dsZUJvbGQoKSB7XG4gIGNvbnN0IGJvbGQgPSAkKHRoaXMpLmRhdGEoJ2JvbGQnKTtcbiAgYm9sZCA/IG9FZGl0b3IuYm9sZCgpIDogb0VkaXRvci5yZW1vdmVCb2xkKCk7XG4gICQodGhpcykuZGF0YSgnYm9sZCcsICFib2xkKTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlVW5kZXJsaW5lKCkge1xuICBjb25zdCB1bmRlcmxpbmUgPSAkKHRoaXMpLmRhdGEoJ3VuZGVybGluZScpO1xuICB1bmRlcmxpbmUgPyBvRWRpdG9yLnVuZGVybGluZSgpIDogb0VkaXRvci5yZW1vdmVVbmRlcmxpbmUoKTtcbiAgJCh0aGlzKS5kYXRhKCd1bmRlcmxpbmUnLCAhdW5kZXJsaW5lKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2UoaW5wdXQpIHtcbiAgaWYgKGlucHV0LmZpbGVzICYmIGlucHV0LmZpbGVzWzBdKSB7XG4gICAgaWYgKC9cXC4oanBlP2d8cG5nfGdpZikkL2kudGVzdChpbnB1dC5maWxlc1swXS5uYW1lKSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBvRWRpdG9yLmluc2VydEltYWdlKFxuICAgICAgICAgIHJlYWRlci5yZXN1bHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3M6ICdpbnNlcnRlZF9pbWFnZSdcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbnB1dC5maWxlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsZXJ0KCdwbmcsIGdpZiwganBnIO2MjOydvOunjCDsl4XroZzrk5wg6rCA64ql7ZWp64uI64ukJyk7XG4gICAgfVxuICB9XG59XG5cbiAgY29uc3QgJHRhcmdldCA9ICQoJy53cml0ZV9jb250Jyk7XG4gIGNvbnN0IG9FZGl0b3JTdW0gPSBuZXcgU3F1aXJlKCR0YXJnZXQuZ2V0KDApLFxuICAgIHtcbiAgICAgIGJsb2NrVGFnOiAnUCcsXG4gICAgICBibG9ja0F0dHJpYnV0ZXM6IHsgc3R5bGU6ICdmb250LXNpemU6IDE2cHg7JywgY2xhc3M6IFwic3VtbWFyeVwiIH1cbiAgICB9XG4gICk7XG4gIGNvbnN0IG9FZGl0b3JDb250cyA9IG5ldyBTcXVpcmUoJHRhcmdldC5nZXQoMSksXG4gIHtcbiAgICBibG9ja1RhZzogJ1AnLFxuICAgIGJsb2NrQXR0cmlidXRlczogeyBzdHlsZTogJ2ZvbnQtc2l6ZTogMTZweDsnLCBjbGFzczogXCJjb250ZW50c1wiIH1cbiAgfSlcbiAgbGV0IG9FZGl0b3IgPSBvRWRpdG9yU3VtO1xuXG4gICQoJy53cml0ZV9jb250JykuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChlLmRlbGVnYXRlVGFyZ2V0KTtcbiAgICBjb25zdCBpbmRleCA9ICQoJy53cml0ZV9jb250JykuaW5kZXgoJHRhcmdldCk7XG4gICAgb0VkaXRvciA9IGluZGV4ID09PSAwID8gb0VkaXRvclN1bSA6IG9FZGl0b3JDb250cztcbiAgfSlcblxuICAkKCcuY29sb3JwaWNrZXInKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAkKHRoaXMpLm1pbmljb2xvcnMoe1xuICAgICAgY29udHJvbDogJCh0aGlzKS5hdHRyKCdkYXRhLWNvbnRyb2wnKSB8fCAnaHVlJyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogJCh0aGlzKS5hdHRyKCdkYXRhLWRlZmF1bHRWYWx1ZScpIHx8ICcjMDAwJyxcbiAgICAgIGZvcm1hdDogJCh0aGlzKS5hdHRyKCdkYXRhLWZvcm1hdCcpIHx8ICdoZXgnLFxuICAgICAga2V5d29yZHM6ICQodGhpcykuYXR0cignZGF0YS1rZXl3b3JkcycpIHx8ICcnLFxuICAgICAgaW5saW5lOiAkKHRoaXMpLmF0dHIoJ2RhdGEtaW5saW5lJykgPT09ICd0cnVlJyxcbiAgICAgIGxldHRlckNhc2U6ICQodGhpcykuYXR0cignZGF0YS1sZXR0ZXJDYXNlJykgfHwgJ2xvd2VyY2FzZScsXG4gICAgICBvcGFjaXR5OiAkKHRoaXMpLmF0dHIoJ2RhdGEtb3BhY2l0eScpLFxuICAgICAgcG9zaXRpb246ICQodGhpcykuYXR0cignZGF0YS1wb3NpdGlvbicpIHx8ICdib3R0b20nLFxuICAgICAgc3dhdGNoZXM6ICQodGhpcykuYXR0cignZGF0YS1zd2F0Y2hlcycpID8gJCh0aGlzKS5hdHRyKCdkYXRhLXN3YXRjaGVzJykuc3BsaXQoJ3wnKSA6IFtdLFxuICAgICAgY2hhbmdlOiBmdW5jdGlvbiAoaGV4LCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBsb2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nID0gaGV4ID8gaGV4IDogJyMwMDAnO1xuICAgICAgICAgIG9FZGl0b3Iuc2V0VGV4dENvbG91cihsb2cpO1xuICAgICAgICAgIGlmIChvcGFjaXR5KSBsb2cgKz0gJywgJyArIG9wYWNpdHk7XG4gICAgICAgICAgY29uc29sZS5sb2cobG9nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICB9LFxuICAgICAgdGhlbWU6ICdkZWZhdWx0JyxcbiAgICAgIHBvc2l0aW9uOiAndG9wIGJvdHRvbSdcbiAgICB9KTtcbiAgfSk7XG5cbiAgJCgnYm9keScpLm9uKCdjbGljaycsICcuaW5zZXJ0ZWRfaW1hZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICQoZS50YXJnZXQpLnRvZ2dsZUNsYXNzKCdvbicpO1xuICB9KTtcblxuICAkKCcuZm9udHNpemUnKS5vbignYmx1ciBrZXl1cCcsICdpbnB1dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gXCJrZXl1cFwiICYmIGUua2V5Q29kZSAhPSAxMykgcmV0dXJuO1xuICAgIG9FZGl0b3Iuc2V0Rm9udFNpemUoJChlLnRhcmdldCkudmFsKCkgKyAncHgnKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gICQoJy5ib2xkJykuY2xpY2sodG9nZ2xlQm9sZCk7XG5cbiAgJCgnLnVuZGVybGluZScpLmNsaWNrKHRvZ2dsZVVuZGVybGluZSk7XG5cbiAgJCgnLm9yZGVyZWQnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgb0VkaXRvci5tYWtlT3JkZXJlZExpc3QoKTtcbiAgfSk7XG5cbiAgJCgnLnVub3JkZXJlZCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBvRWRpdG9yLm1ha2VVbm9yZGVyZWRMaXN0KCk7XG4gIH0pO1xuXG4gICQoJy5pbmRlbnQnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgb0VkaXRvci5pbmNyZWFzZUxpc3RMZXZlbCgpO1xuICB9KTtcblxufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/resources/write/write.js\n");

/***/ }),

/***/ 1:
/*!********************************************!*\
  !*** multi ./src/resources/write/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/resources/write/index.js */"./src/resources/write/index.js");


/***/ })

/******/ });